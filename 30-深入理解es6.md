###字符串和正则表达式

###其他字符串变更
    *字符串中的子串识别
        1-includes():在字符串中检测到指定文本返回true，否则返回false
        2-startsWith():在字符串的起始部分检测到指定文本则返回true，否则返回false
        3-endsWith():在字符串的结束部分检测到指定文本则返回true，否则返回false
        注意：1-以上3种方法都接受俩个参数，第一个参数指定要搜索的文本；第二个参数可选，指定一个开始搜索的位置的索引值
            如果指定了第二个参数则includes()方法和startsWith()方法会从这个索引值的位置开始匹配，endsWith()方法则从这个索引值减去欲搜索文本长度的位置开始正向匹配，对字符进行逐个比较
            2-对于startsWith(),endsWith(),includes()这3个方法，如果没有按照要求传入字符串而是传入了正则表达式，则会触发错误；而对于indexOf和lastIndexOf()这俩个方法，他们都会把传入的正则表达式转化为一个字符串并搜索它
    *repeat()方法
        'shihui'.repeat(2)==> shihuishihui
        其接受一个number类型的参数，表示该字符串的重复次数，返回当前字符串重复一定次数后的新字符串
###其他正则表达式的语法变更
    *正则表达式y修饰符
    *正则表达式的复制
        在es5中可以通过RegExp构造函数传递正则表达式作为参数复制这个正则表达式比如
```js
            var re1 = /ab/i;
            var re2 = new RegExp(re1)
            此处变量re2只是变量re1的一份拷贝，如果在es5中给RegExp构造函数提供第二个参数为正则表达式指定一个修饰符，则代码无法运行，但是在es6中这段代码是可以运行的
```
    *flags属性
        定义：能够更加简单的获取正则表达式的修饰符
        相关的source属性是es5中获取正则表达式的文本的属性，跟flags属性用法一样
            例子：let re= /ab/g
                 re.flags ==> g
                 re.source ==> ab


###模板字面量
    *基础语法
        只是用反撇号替换了单，双引号
        如果想在字符串中使用反撇号`，那么用反斜杠(\)将它转义就可以，而在模板字面量中不需要转义单，双引号
    *多行字符串
        在之前的版本中多行字符需要用到换行符，或者(\)承接上一行字符
        在es6版本中在反撇号内只需要直接换行，此处的换行将同步出现在结果中
        注意点：1-在反撇号中的所有空白符都属于字符串的一部分，所以千万要小心缩进
    *字符串占位符
        模板字符串和普通的字符串二者真正的区别在于模板字面量中的占位符功能
        用法 ${}  中间可以写任何的js的表达式
    *标签模板
        对标签模板的理解：每个标签模板都可以执行模板字面量上的转换并返回最终的字符串值
        1-标签
            定义：
            1-在模板字面量第一个反撇号(`)前方标注的字符串   如 let message = tag`hello world` tag则是模板字面量`hello world`的模板标签
            function tag(literals,...substitutions){}
            2-标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含以下元素：第一个占位符前的空字符串
                      第一，二个占位符之间的字符串
                      第二个占位符后的字符串
            3-函数的第二个参数也是数组包含：第一个占位符的值
                                       第二个占位符的值
        2-在模板字面量中使用原始值
            String.raw() 使用内建的String.raw()可以输出字符串的原生形式，包含转义的字符
            例如：let message = String.raw`shihui\nstring` ===> "shihui\\nstring" 
            不使用String.raw()则会解析\n   let message `shihui\nstring` ===> "shihui
                                                                           string"


                
###函数
    **函数形参的默认值
        1-函数形参的默认值
            定义：在函数定义中声明了多少个形参，都可以传入任意数量的参数，也可以在定义函数时添加针对参数数量的处理逻辑，当已定义的形参无对应的传入参数时为其指定一个默认值
        2-es6中的默认值参数值
            注意点：对于默认参数null是一个合法值，也就是说null会当做合法值处理则不会使用函数的默认值，而传入undefined时函数会使用参数的默认值
        3-默认参数对arguments对象的影响
            es6中总是可以通过arguments对象将参数恢复为初始值，无论当前是否在严格模式的环境下，也就是说arguments只代表函数参数初始值，函数传入一个值arguments长度为1
            注意：arguments指的是函数传入的实际参数的初始值，并不是指默认值。
        4-默认参数表达式
            定义：函数返回值作为默认值
            ```js
                例子：
                function getValue(){
                    return 5
                }
                function add(first,second=getValue()){
                    return first + second
                }
            ```
            执行逻辑：初次解析函数声明时不会调用getValue()方法，只有当调用add()函数且不传入第二个参数时才会调用
            注意：当使用函数调用结果作为默认参数值时，如果忘记写小括号，例如，second=getValue,则最终传入的是对函数的引用，而不是函数调用的结果

            错误示范：
            ```js
                function add(first=second,second){
                    return fisrt + second
                }
            ```
            调用add(undefind,1)会抛出错误，因为second比first晚定义，因此second不能作为first的默认值，可以用临时死区定义
    
    
    **处理无命名参数
        1-不定参数
            定义：在函数的命名参数前添加三个点(...)就表明这是一个不定参数，该参数为一个数组
            1-1不定参数的使用限制
                1-1-1：每个函数最多只能声明一个不定参数，而且一定要放在所有参数末尾
                1-1-2：不定参数不能用于对象字面量setter中，那么下面这段代码实例会导抛出语法错误
                        原因是：存在这条限制，是因为对象字面量setter的参数有且只能有一个
                ```js
                    let object = {
                        // 语法错误，这里不能再setter中使用不定参数
                        set name(...value){}
                    }
                ```
            1-2不定参数对arguments对象的影响
                结论：不定参数和对象arguments字面量同时存在
                    无论是否使用不定参数，arguments对象总是包含所有传入函数的参数

    **增强的function构造函数
        注意点：这种构造函数接受字符串形式的参数,使用不定参数时也需要家引号如"...arg"
        ```js
            var arr = new function('first','second','return first + second')
        ```

        1-展开运算符
            定义：展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数，也就是解构的方式将数组解构成一个个的值

    **name属性
        为什么：因为js中定义函数的方式有很多种，因而辨别函数就比较困难
        1-name属性的特殊情况
            1-1：
            ```js
                var doSomething = function doSomethingElse(){}
                var person = {
                    get firstName(){}
                }
                doSomething.name  //结果为 doSomethingElse  
                person.firstName.name //结果为 get firstName
            ```
            解释doSomething的name不是doSomething而是doSomethingElse,因为函数表达式有一个名字，这个名字比函数本身被赋值的变量的权限要高
            1-2：
                1-2-1通过bind()函数创建的函数，其名称带有bound前缀
                    ```js
                        var dosomething = function(){}
                        dosomething.bind().name  //结果为bound dosomething
                    ```
                1-2-2通过function构造函数创建的函数，其名称将是"anonymous"
                    ```js
                        (new function()).name  //结果为anonymous
                    ```
            
    **明确函数的多重用途
        解释：js函数有俩种不同的内部方法：[[Call]]和[[Construct]],当通过new关键字调用函数时,执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后在执行函数体，将this绑定到实体上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数
    
    **块级函数
        定义：在大括号{}里的函数被称为块级函数
        注意点：一旦if语句代码块结束执行，函数也就不复存在了，外部就访问不到函数了
        1-块级函数的使用场景
            注意点：块级函数会被提升至块的顶部，而用let定义的函数表达式不会被提升
        2-非严格模式下的块级函数
            特点：和严格模式下不同的是，非严格模式下的块级函数不再提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部
                 es6将这个行为标准化了，现在es6运行时环境都执行这个标准
    
    **箭头函数
        提示：箭头函数也有name，这和其他函数规则相同
        1-箭头函数语法
            1-1：当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后箭头右侧的表达式被求值后便立即返回
                ```js
                    let arr = value => value
                ```
            1-2：如果要传入俩个或者俩个以上的参数
                ```js
                    let sum = (num1,num2)=>num1 + num2
                ```
            1-3：如果函数没有参数
                ```js
                    let sum = () =>"shihui"
                ```
            1-4：有函数体且有箭头
                ```js
                    let sum = (num1,num2)=>{
                        return num1 + num2
                    }
                ```
            1-5:如果想创建空函数，需要写一对没有内容的花括号
                ```js
                    let dosomething = ()=>{}
                ```
            1-6:箭头函数返回一个对象字面量的写法
                ```js
                    let dosomething = (id) = ({id:id,name:"shihui"})
                ```

        2-创建立即执行函数表达式
            2-1：箭头函数立即执行函数的写法：只要将箭头函数包裹在小括号内，就可以用它实现立即执行函数的功能
                ```js
                    let person = ((name)=>{
                        return {
                            name:name
                        }
                    })("shihui")
                ```
        
        3-箭头函数和数组
            箭头函数结合数组方法(要求这里的数组方法接受的参数是函数)，所以箭头函数和数组方法结合的语法非常简洁
        4-箭头函数没有arguments绑定
            箭头函数灭有自己的arguments对象，但是箭头函数始终可以访问外围函数的arguments对象
        5-箭头函数的辨识方法
            注意：使用typeof和instanceof测试箭头函数类型和普通函数都是一样的
        6-尾调用
            定义：函数作为另一个函数的最后一条语句被调用
            es5关于尾调用的执行思路及存在的问题：创建一个新的栈桢，将其推入调用栈来表示函数调用。也就是说，在循环调用中，每一个未调用完的栈桢都会被保存在内存中，当调用栈过大时会造成程序问题
        7-es6关于尾调用优化
            7-1：关于es6优化尾调用需要满足的情况：
                    7-1-1：尾调用不访问当前栈桢的变量
                    7-1-2：在函数内部，尾调用是最后一条语句
                    7-1-3：尾调用的结果作为函数值返回
            7-2：尾调用无法优化的情况
                7-2-1：尾调用没有返回结果
                    ```js
                        function dosome(){
                            dosomeElse()
                        }
                    ```
                7-2-2：在返回值时添加其他操作
                    ```js
                        function dosome(){
                            return 1 + dosomeElse()
                        }

                    ```
                7-2-3：将函数调用的结果存储在一个变量里
                    ```js
                        function dosome(){
                            var result = dosomeElse()
                            return result
                        }
                    ```
                7-2-4：闭包情况，也就是访问函数作用域内的局部变量
                    ```js
                        function dosome(){
                            var num = 1
                            var func = () => num  //闭包func()访问了num变量
                            return func()
                        }
                    ```

        8-如何利用尾调用优化
            注意点：当写递归函数时，记得使用尾调用优化的特性，如果递归函数的计算量足够大，则尾递归优化可以大幅度提升程序性能


###扩展对象的功能性
    **对象字面量扩展语法
        对象字面量如此流行的原因：
            1-我们想要创建的对象，不再需要编写冗余的代码，直接通过它简洁的语法就可以实现
            2-就连json也是基于它的语法构建的
        1-属性初始值的简写
            定义：当一个对象的属性与本地变量同名时，不必再写冒号和值，只写属性名即可，这也是对象初始化语法

        2-对象方法的简写语法
            定义：消除了冒号和function关键字
                ```js
                    let person = {
                        sayName(){}
                    }
                ```
            对象方法的简写语法和普通的写法，二者唯一的区别是，简写语法可以使用super关键字
        
        3-可计算属性名
            3-1定义：在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号
                ```js
                    let lastName = "shihui"
                    let person ={
                        [lastName]:"zakas"
                    }
                    // person[lastName]会转换为 person["shihui"]
                ```
            3-2在对象字面量中使用方括号表示的该属性名称是可计算的，它的内容将被求值并被最终转化为一个字符串
                ```js
                    let suffer = "name"
                    let person = {
                        ["last" + suffer]:"zakas"
                    }
                    // person["last" + name] 转化为  person["lastname"]
                ```
        
    **新增方法
            1 Object.is()方法
                作用：弥补全等运算符的不准确运算
                用法：这个方法接受俩个参数，如果这俩个参数类型相同且具有相同的值，则返回true
                ```js
                    Object.is(5,5) //返回结果true
                    Object.is(5,"5")  //返回结果为false
                ```
            2 Object.assign()方法
                定义：该方法可以接受任意数量的源对象，并按指定的顺序将属性复制到接受对象中
                用法：第一个参数为接受对象，后面的参数为任意多的源对象，如果对个源对象具有相同属性，则排在后面的源对象会覆盖排位靠前的
                ```js
                    let receiver = {}
                    Object.assign(receiver,
                    {
                        type:'js',
                        name:'file.js'
                    },
                    {
                        name:'shihui.js'
                    })
                    // 返回结果receiver.name = shihui.js   receiver.type = js 
                ```
                2-1：Object.getOwnPropertyDescriptor()
                    用法：参数一:要在其中查找的对象，参数二：要查找的属性；返回值：给定对象自身的属性(不存在原型链中)通过value可以拿到值
                    ```js
                        let supplier={
                            name:"shihui"
                        }
                        let receiver = Object.getOwnPropertyDescriptor(supplier,'name')
                        // receiver.value 返回结果为 name对象的值  shihui
                    ```

    **重复的对象字面量属性
            es5和es6处理重复属性的处理办法
            ```js
                var person = {
                    name:"nikesong",
                    name:"gray"
                }
            ```
            上述例子：当运行es5严格模式时，第二个name属性会触发一个语法错误；
                    但在es6中无论是在严格模式下还是费严格模式，对于每一组重复属性，都会选取最后一个取值
        
    **自有属性枚举顺序
            1自有属性枚举的基本规则:
                    1-1:所有数字按键升序排序
                    1-2:所有字符串键按照它们被加入对象的顺序排序
                    1-3:所有symbol键按照它们被加入对象顺序排序
            2：es6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到Object.getOwnPropertyNames()方法及Reflect.   ownKeys返回属性的方式，Object.assign()方法处理属性的顺序也会随之改变
            3：Object.keys()方法和JSON.stringfy()方法都指明与for-in使用相同的枚举顺序，因此他们的枚举顺序目前也不明晰
        
    **增强对象原型
            1：改变对象的原型
                1-1：Object.create()：该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__
                        例子：将person对象放到friend原型上
                            ```js
                                let person = {
                                    name:"shihui"
                                }
                                let friend = Object.create(person)
                            ```
                1-2:对象原型的真实值被储存在内部专有属性[[Prototype]]中，
                    调用Object.getPrototypeOf()方法返回对象原型中储存在其中的值
                    调用Object.setPrototypeOf()方法改变对象原型中的值 
                        用法：Object.setPrototypeOf(Object,prototype)  object要设置的对象，prototypey该对象的新原型
            
            2：简化原型方法的super引用
                注意点：super要在使用简写方法的对象中使用，如果在其他方法声明中使用会导致语法错误
                    例子：方法的简写方式  getGreeting(){}  而不是 function getGreeting(){}
                
                2-1:super关键字用于访问和调用一个对象的父对象上的函数
                    注意点：构造函数中使用super必须在this之前使用
                
                es6 super方法总结：super方法不是动态变化的，他总是指向正确的对象(指向一个对象则会始终指向这个对象)
        
    **正式的方法定义
            super深层原(这边可以不用太多理解)


###解构:使数据访问更便捷
    **为何使用解构功能
    **对象解构
        注意点：不要忘记初始化程序，就是给程序定义的时候设定值；如果使用var,let,const解构声明变量，则必须要初始化
              事例：var {type,name}  语法会报错因为没有初始化
        1-解构赋值
            ```js
                let node = {
                    type:"good",
                    name:"foo"
                },
                type = "books",
                name = 5;
                ({type,name} = node) 
            ```
            1-1 //这里一定要用小括号包裹解构赋值语句，原因：js引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程
            1-2 
            ```js
                let node = {
                    type:"good",
                    name:"foo"
                },
                type = "books",
                name = 5;
                function output(value){
                    console.log(value === node)
                }
                output({type,name} = node)  
            ```
            //这里函数参数传入解构形式参数解释：js表达式的值为右侧的值，因而此处传入的参数等同于node，且变量type和name被重新赋值，最终将node传入output()函数
        
        2-默认值
            2-1在解构赋值大括号里，没有被解构对象对应的属性名，那就会被赋值undefined
               用法：当指定的属性不存在时，可以随意定义一个默认值，在属性名称后面添加一个等号(=)和相应的默认值即可
                ```js
                    let node = {
                        type:'food',
                        name:'foo'
                    }
                    let {type,name,value = true} = node
                ```
                2-1-1默认值的生效条件：只有当node上没有该属性或者该属性值为undefined时该值才会生效

        3-为非同名局部变量赋值
            3-1解构非同名属性名的语法：
                type:localType语法的含义是读取名为type的属性并将其值存储在变量localType中，这种语法实际上与传统对象字面量的语法相悖，原来的语法名称在左边，值在右边；现在变量名称在冒号右边，而需要读取的位置(对象的属性名)在左边
                实例：
                ```js
                    let node = {
                            type:'food',
                            name:'foo'
                        }
                    let {type:localType,name:localName} = node
                    // localType是type对应的非同名的属性名，localType和type打印出的结果是一样的
                ```
            3-2使用其他变量名赋值添加默认值
                当使用其他变量名进行赋值时也可以添加默认值，只需要在变量名后添加等号和默认值即可
                ```js
                    let node = {
                        type:'food',
                        name:'foo'
                    }
                    let {type:localType,name:localName,value:localValue = "bar"} = node
                ```

        4-嵌套对象解构
            4-1：对象深层解构
            4-2：不同局部变量名解构(和非同名局部变量赋值差不多)
    

    **数组解构
        数组解构可以任意命名，这一点与对象解构不同
        注意点：数组结果过程中，数组本身不会发生任何变化
        1-解构赋值
            数组解构可以用于赋值上下文，但不需要用小括号包裹起来，这点与对象解构不同
            ```js
                let color = ["red","green","blue"],
                    firstColor = "white",
                    secondColor =  "black"
                [firstColor,secondColor] = color
            ```
            1-1数组解构还有一个特别的用例：交换俩个变量值
            ```js
                let a = 1, b = 2
                [a,b] = [b,a]
            ```
            注意点：如果右侧数组解构赋值表达式的值为null或undefined，则会导致程序抛出错误，这一特性与对象解构赋值很相似

        2-默认值
            定义：数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或其值为undefined时使用默认值，数组解构的默认值和对象解构默认值差不多
            用法：let [firstColor,secondColor = "black"] = color
        
        3-嵌套数组解构
            定义：嵌套数组解构和嵌套对象解构的语法相似
        
        4-不定元素
            概念：不定元素，在数组中，可以通过(...)语法将数组中的其余元素赋值给一个特定的变量
            用例
            ```js
                let colors = ['red','blue','orange']
                let [firstColor,...secondColor] = colors
                // secondColor 返回结果为['blue','orange']的数组
            ```
            注意点：不定元素必须为最后一个条目，在后面继续添加逗号会导致程序抛出错误

        
    **混合结构
        对象解构+数组解构可以混合起来用
        不管结构多复杂，都可轻松的提取任意想要的信息
    
    **解构参数
        定义：结构参数需要使用对象或数组解构模式代替函数参数
        注意点：解构参数支持对象解构和数组解构的所有特性

        1-必须传值的解构参数
            解构参数也就是当函数参数中有对象解构或者数组解构时，js引擎实际上做了这些事儿(解构参数的原理)
            ```js
                function setcookie(name,value,opiton){
                    let {secure,path,domain,expires} = option
                }
            ```
            由此可见，如果解构赋值表达式的右值为null或undefined，则程序会报错，同理如果调用setcookie()函数时不传入第3个参数，也会导致程序报错
            
            1-1解决结构参数不传值报错的问题
                方法：如果希望解构参数定义为可选，那么就必须为其提供默认值来解决这个问题
                    ```js
                        function setcookie(name,value,{secure,path,domain,expires} = {})
                    ```
        
        2-解构参数的默认值
            概念：可以为解构参数指定默认值，就像在解构赋值语句中做的那样，只需在参数后添加等号并且指定一个默认程序
                 结合为了函数解构参数不传值会导出程序抛出错误
                实例：
                ```js
                    const setcookiedefault = {
                        secure:false,
                        path:'/',
                        domain:'example.com'
                    }
                    function setcookie(name,value,{
                        secure = setcookiedefault.secure,
                        path = setcookiedefault.path,
                        domain = setcookiedefault.domain
                    } = setcookiedefault
                    ){} 
                    // 即是setcookie函数不传入第三个参数程序也不会报错
                ```

###set和map集合
    **es6中的set集合
        set集合定义：set类型是一种有序列表，其中含有一些独立的非重复值，通过set集合可以快速访问其中的数据，更有效追踪离散值
        1-创建set集合并添加元素
            1-1用法：调用new Set()创建set集合；
                    调用add()方法向集合中添加元素；
                    访问集合size属性可以获取集合中目前的元素数量；
        
            1-2：set集合中，不会对所存值进行强制类型转换，比如数字5和字符串'5'可以作为俩个独立的元素存在
                注意点：Object.is()方法检测俩个值是否一致，唯一的例外是，set集合中的+0和-0被认为是相等的
            1-3：向集合中添加多个对象，则他们之间彼此保持独立
                ```js
                    let set = new Set(),
                    key1 = {},
                    key2 = {};
                    set.add(key1)
                    set.add(key2)
                    set.size  //返回结果为2 
                ```
                原理是：由于key1和key2不会被转成字符串，因而他们在set集合中是俩个独立的元素
            1-4：多次调用add()方法并传入相同的值作为参数，那么后续的调用实际上会被忽略
                1-4-1：可以用数组来初始化set集合，set构造函数同样会过滤掉重复的值从而保证集合中的元素各自唯一
            1-5：has()方法
                定义：可以检测set集合中是否存在某个值
                ```js
                    let set = new Set()
                    set.add(5)
                    set.has(5) //返回true
                ```
        
        2-移除元素
            2-1：delete方法可以移除set集合中的某一个元素
                ```js
                    let set = new Set()
                    set.add(5)
                    set.add('5')
                    set.delete(5) 
                    set.has(5)  //返回false，说明5被删除了
                ```
            2-2：clear方法会移除集合中所有的元素
                ```js
                    let set = new Set()
                    set.add(5)
                    set.add('5')
                    set.clear() //调用clear方法删除集合中所有的元素
                ```         

        3-set集合的forEach()方法
            3-1用法：set集合的forEach()方法接受3个参数
                    3-1-1：set集合中下一次索引的位置
                    3-1-2：与第一个参数一样的值
                    3-1-3：被遍历的set集合本身
            3-2数组和set集合的forEach()方法的相同点和不同点
                3-2-1：set集合和数组的forEach()方法的回调函数都接受3个参数，前俩个分别是值和键(对于数组来说就是数值和索引)
                      set集合回调函数前俩个参数的值是一样的，因为set集合没有键名所以set集合的forEach方法的回调函数前俩个参数是一样的
                    ```js
                        let set = new Set([1,2])
                        set.forEach(function(value,key,ownerset){
                            console.log(value === key) //value和key的值是一样的 返回结果true
                            console.log(ownderset === set)  // 回调函数第三个参数是set集合本身，返回结果true
                        }) 
                    ```
                3-2-2：在set集合的forEach()方法中，第二个参数也与数组的一样，如果需要在回调函数中使用this，则可以将它作为第二个参数传入forEach()
                    ```js
                        let set = new Set([1,2])
                        let process = {
                            output(value){
                                console.log(value)
                            },
                            process(dataset){
                                dataset.forEach(function(value){
                                    this.output(value)
                                },this)   //set集合和数组方法forEach()第二个参数this的作用是一样的，
                                            是将this.output的this绑定到process上
                                            可以通过箭头函数直接从外围读取this
                            }
                        }
                    ```

        4-将set集合转化为数组
            4-1：将数组转换为set集合过程很简单，只需要给set构造函数传入数组即可
            4-2：将set集合再转换为数组的过程同样很简单，只需要用展开运算符(...),它可以将数组中的元素分解为各自独立的函数参数
                ```js
                    let set = new Set([1,2,3,3,3,4,5])
                    let arr = [...set]  //返回结果为去过重的数组[1,2,3,4,5]
                ```

        5-WeakSet集合
            5-1为什么要用弱引用WeakSet？
                    因为强引用只要实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间，容易造成内存泄漏
                        ```js
                            let set = new Set()
                            let key = {}
                            set.add(key)
                            key = null
                            console.log([...set][0]) //返回的值为{}   
                                                        这便是强引用的特点：将key值设置为null时
                                                        便清除了对初始对象的引用，但是set集合却保留了这个引用，你任然可以使用展开运算符将set集合转成数组格式从数组中取出该引用
                        ```
            5-2创建WeakSet集合
                用法：weakSet集合支持3个方法：add(),has(),delete()
                5-2-1:weakSet集合和set集合的不同点是：
                        5-2-1-1：weakSet构造函数不接受任何原始值(不接受任何非对象的值)，如果WeakSet集合中包含了其他非对象的值，程序就会报错。
                            ```js
                                let set = new WeakSet()
                                let key = {}
                                set.add(key)
                                key = null
                                set.has(key)//返回结果为false 
                            ```
                        5-2-1-2：俩种set类型之间的最大区别是weakSet保存的是对象值的弱引用(弱引用的含义是当被引用的对象的值为null时，WeakSet对该对象的引用也会消除)
                        5-2-1-3：WeakSet集合不可迭代，所以不能被用于for-of
                        5-2-1-4：WeakSet集合不支持forEach()方法
                        5-2-1-5：WeakSet集合不支持size属性
                        5-2-1-6：WeakSet集合，向has()和delete()方法中传入非对象参数则会返回false

    
    **es6中的map集合
        概念：
            map类型是一种储存着许多键值对的有序列表，其中的键名和对应的值支持所有的数据类型。键名的等价性判断是通过调用Object.is()方法实现的。

        map集合和对象的不同点：
            1.map集合键名不会进行类型转换，而对象的属性名总是会被强制转换成字符串；
            2.无法用对象作为对象的键名，但是在map集合中却可以这么做
                ```js
                    let map = new Map()
                    let key1 = {}
                    let key2 = {}
                    map.set(key1,5)
                    map.set(key1,12)
                    map.get(key1)  //返回的结果为5
                ```
                原因是：因为这些键名不会被强制转换成其他形式，所以这俩个对象在集合中是独立存在的。

        用法：调用set()方法分别传入键名和对应值作为俩个参数
             调用get()方法从集合中获取信息

        1-map集合支持的方法
            map集合跟set几个设计了3个通用的方法：has(),delete(),clear()
        
        2-map集合的初始化
            2-1概念：
                可以向map构造函数传入数组来初始化一个map集合，这点同样与set集合相似，数组中的每个元素都是一个子数组，子数组中包含一个键值对的键名与值俩个元素
                实例：
                    ```js
                        let map = new Map([['name','石惠'],['age',25]])
                        map.get('name') // 返回结果为 石惠
                        map.get('age')  //返回结果为25
                    ```
                问题：数组中包裹数组的模式比较奇怪的解释
                    因为map集合中可以接受任意数据类型键名，为了确保他们在被存储的到map集合中之前不会被强制转换成其他数据类型，因为只能将他们放到数组中，因为这种方式是唯一一种可以准确地呈现键名类型的方式，map集合的forEach()方法也可以证明数组中包裹数组的方式可以被遍历。但是数组中包裹数组的方式能被遍历仅限于map集合

        3-map集合的forEach()方法
            3-1用法：回调函数接受三个参数   forEach()方法接受2个参数 第二个参数this跟set集合用法一样
                     3-1-1map集合中索引的位置(索引对应的值)
                     3-1-2值对应的键名
                     3-1-3map集合本身
                实例：
                    ```js
                        let map = new Map([['name','shihui'],['age',25]])
                        map.forEach(function(value,key,ownermap){
                            console.log(value)  //返回shihui 对应的名称
                            console.log(key)    //返回name  对应的键名
                        })
                    ```
        
        4-weak map集合
            4-1特性：
                4-1-1weak map集合中的键名必须是一个对象，如果使用非对象键名会报错
                4-1-2键名遵从这个原则，键名对应的值如果是一个对象，则保存的是对象的强引用，不会触发垃圾回收机制

            4-2使用weak map集合用法：
                4-2-1：weak map类型是一种存储着许多键值对的无序列表，列表的键名必须是非null类型的对象，键名对应的值则可以是任意类型
                4-2-2：通过set()方法添加数据，通过get()方法获取数据
            
            4-3weak map集合的初始化方法
                4-3-1用法：
                        调用weakmap构造函数传入一个数组，容器内包含其他数组，每个数组由俩个元素构成：第一个元素是一个键名，传入的值必须是非null的对象；第二个元素是这个键对应的值(可以是任意类型)
                    注意点：如果键名为非对象的键则程序会报错
                实例：
                    ```js
                        let key1 = {}
                        let key2 = {}
                        let map = new WeakMap([[key1,'hello'],[key2,'shihui']])
                        console.log(map.get(key1))  //返回结果为hello
                        console.log(map.hsa(key1))  //返回结果为true
                    ```
                
            4-4weak map集合支持的方法
                4-4-1weakmap集合仅支持俩个方法：has(),delete(),weak map和weak set一样俩者都不支持键名枚举
            
            4-5私有对象数据
                概念：应用了weak map集合弱引用特性；当被引用的对象实例被销毁时(实例对象作为weak map的键名)，引用的数据也会被销毁，从而保证信息的私有性(键名被销毁，相应的数据会被垃圾回收机制回收)

            4-5weak map集合的使用方式及使用限制
                不支持通过forEach()方法，size属性，clear()方法来管理集合中的元素      


###迭代器(Iterator)和生成器(Generator)
    **什么是迭代器
        定义：迭代器是一种特殊对象，它具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有一个next()方法，每次调用都返回一个结果对象。结果对象有俩个属性：一个是value,表示下一个将要返回的值；另一个是done，它是一个布尔类型的值，当没有更多可返回的数据时返回true
        实际操作：用es5语法创建一个迭代器
            ```js
                function createIterator(items){
                    var i = 0
                    return {
                        next:function(){
                            var done = (i>=items.length)
                            var value = !done?items[i++]:undefined
                            return {
                                done:done,
                                value:value
                            }
                        }
                    }
                }
                var iterator = createIterator([1,2,3])  //必须要将createIterator()的函数调用赋值给iterator变量，因为每次调用createIterator()都会将函数初始化，i永远从0开始，所以赋值给iterator变量之后，每次调用函数i的值会被保存下来
                iterator.next() //返回 {value:1,done:false}
                iterator.next() //返回 {value:2,done:false}
                iterator.next() //返回 {value:3,done:false}
            ```

    **什么是生成器
        概念：生成器是一种返回迭代器的函数，通过function关键字后的星号(*)来表示，函数中会用到新的关键字yield。星号可以紧挨着function，也可以中间添加一个空格



            
            
            
        
        

            






    





