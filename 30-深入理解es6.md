###字符串和正则表达式

###其他字符串变更
    *字符串中的子串识别
        1-includes():在字符串中检测到指定文本返回true，否则返回false
        2-startsWith():在字符串的起始部分检测到指定文本则返回true，否则返回false
        3-endsWith():在字符串的结束部分检测到指定文本则返回true，否则返回false
        注意：1-以上3种方法都接受俩个参数，第一个参数指定要搜索的文本；第二个参数可选，指定一个开始搜索的位置的索引值
            如果指定了第二个参数则includes()方法和startsWith()方法会从这个索引值的位置开始匹配，endsWith()方法则从这个索引值减去欲搜索文本长度的位置开始正向匹配，对字符进行逐个比较
            2-对于startsWith(),endsWith(),includes()这3个方法，如果没有按照要求传入字符串而是传入了正则表达式，则会触发错误；而对于indexOf和lastIndexOf()这俩个方法，他们都会把传入的正则表达式转化为一个字符串并搜索它
    *repeat()方法
        'shihui'.repeat(2)==> shihuishihui
        其接受一个number类型的参数，表示该字符串的重复次数，返回当前字符串重复一定次数后的新字符串
###其他正则表达式的语法变更
    *正则表达式y修饰符
    *正则表达式的复制
        在es5中可以通过RegExp构造函数传递正则表达式作为参数复制这个正则表达式比如
```js
            var re1 = /ab/i;
            var re2 = new RegExp(re1)
            此处变量re2只是变量re1的一份拷贝，如果在es5中给RegExp构造函数提供第二个参数为正则表达式指定一个修饰符，则代码无法运行，但是在es6中这段代码是可以运行的
```
    *flags属性
        定义：能够更加简单的获取正则表达式的修饰符
        相关的source属性是es5中获取正则表达式的文本的属性，跟flags属性用法一样
            例子：let re= /ab/g
                 re.flags ==> g
                 re.source ==> ab


###模板字面量
    *基础语法
        只是用反撇号替换了单，双引号
        如果想在字符串中使用反撇号`，那么用反斜杠(\)将它转义就可以，而在模板字面量中不需要转义单，双引号
    *多行字符串
        在之前的版本中多行字符需要用到换行符，或者(\)承接上一行字符
        在es6版本中在反撇号内只需要直接换行，此处的换行将同步出现在结果中
        注意点：1-在反撇号中的所有空白符都属于字符串的一部分，所以千万要小心缩进
    *字符串占位符
        模板字符串和普通的字符串二者真正的区别在于模板字面量中的占位符功能
        用法 ${}  中间可以写任何的js的表达式
    *标签模板
        对标签模板的理解：每个标签模板都可以执行模板字面量上的转换并返回最终的字符串值
        1-标签
            定义：
            1-在模板字面量第一个反撇号(`)前方标注的字符串   如 let message = tag`hello world` tag则是模板字面量`hello world`的模板标签
            function tag(literals,...substitutions){}
            2-标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含以下元素：第一个占位符前的空字符串
                      第一，二个占位符之间的字符串
                      第二个占位符后的字符串
            3-函数的第二个参数也是数组包含：第一个占位符的值
                                       第二个占位符的值
        2-在模板字面量中使用原始值
            String.raw() 使用内建的String.raw()可以输出字符串的原生形式，包含转义的字符
            例如：let message = String.raw`shihui\nstring` ===> "shihui\\nstring" 
            不使用String.raw()则会解析\n   let message `shihui\nstring` ===> "shihui
                                                                           string"


                
###函数
    **函数形参的默认值
        1-函数形参的默认值
            定义：在函数定义中声明了多少个形参，都可以传入任意数量的参数，也可以在定义函数时添加针对参数数量的处理逻辑，当已定义的形参无对应的传入参数时为其指定一个默认值
        2-es6中的默认值参数值
            注意点：对于默认参数null是一个合法值，也就是说null会当做合法值处理则不会使用函数的默认值，而传入undefined时函数会使用参数的默认值
        3-默认参数对arguments对象的影响
            es6中总是可以通过arguments对象将参数恢复为初始值，无论当前是否在严格模式的环境下，也就是说arguments只代表函数参数初始值，函数传入一个值arguments长度为1
            注意：arguments指的是函数传入的实际参数的初始值，并不是指默认值。
        4-默认参数表达式
            定义：函数返回值作为默认值
            ```js
                例子：
                function getValue(){
                    return 5
                }
                function add(first,second=getValue()){
                    return first + second
                }
            ```
            执行逻辑：初次解析函数声明时不会调用getValue()方法，只有当调用add()函数且不传入第二个参数时才会调用
            注意：当使用函数调用结果作为默认参数值时，如果忘记写小括号，例如，second=getValue,则最终传入的是对函数的引用，而不是函数调用的结果

            错误示范：
            ```js
                function add(first=second,second){
                    return fisrt + second
                }
            ```
            调用add(undefind,1)会抛出错误，因为second比first晚定义，因此second不能作为first的默认值，可以用临时死区定义
    
    
    **处理无命名参数
        1-不定参数
            定义：在函数的命名参数前添加三个点(...)就表明这是一个不定参数，该参数为一个数组
            1-1不定参数的使用限制
                1-1-1：每个函数最多只能声明一个不定参数，而且一定要放在所有参数末尾
                1-1-2：不定参数不能用于对象字面量setter中，那么下面这段代码实例会导抛出语法错误
                        原因是：存在这条限制，是因为对象字面量setter的参数有且只能有一个
                ```js
                    let object = {
                        // 语法错误，这里不能再setter中使用不定参数
                        set name(...value){}
                    }
                ```
            1-2不定参数对arguments对象的影响
                结论：不定参数和对象arguments字面量同时存在
                    无论是否使用不定参数，arguments对象总是包含所有传入函数的参数

    **增强的function构造函数
        注意点：这种构造函数接受字符串形式的参数,使用不定参数时也需要家引号如"...arg"
        ```js
            var arr = new function('first','second','return first + second')
        ```

        1-展开运算符
            定义：展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数，也就是解构的方式将数组解构成一个个的值

    **name属性
        为什么：因为js中定义函数的方式有很多种，因而辨别函数就比较困难
        1-name属性的特殊情况
            1-1：
            ```js
                var doSomething = function doSomethingElse(){}
                var person = {
                    get firstName(){}
                }
                doSomething.name  //结果为 doSomethingElse  
                person.firstName.name //结果为 get firstName
            ```
            解释doSomething的name不是doSomething而是doSomethingElse,因为函数表达式有一个名字，这个名字比函数本身被赋值的变量的权限要高
            1-2：
                1-2-1通过bind()函数创建的函数，其名称带有bound前缀
                    ```js
                        var dosomething = function(){}
                        dosomething.bind().name  //结果为bound dosomething
                    ```
                1-2-2通过function构造函数创建的函数，其名称将是"anonymous"
                    ```js
                        (new function()).name  //结果为anonymous
                    ```
            
    **明确函数的多重用途
        解释：js函数有俩种不同的内部方法：[[Call]]和[[Construct]],当通过new关键字调用函数时,执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后在执行函数体，将this绑定到实体上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数
    
    **块级函数
        定义：在大括号{}里的函数被称为块级函数
        注意点：一旦if语句代码块结束执行，函数也就不复存在了，外部就访问不到函数了
        1-块级函数的使用场景
            注意点：块级函数会被提升至块的顶部，而用let定义的函数表达式不会被提升
        2-非严格模式下的块级函数
            特点：和严格模式下不同的是，非严格模式下的块级函数不再提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部
                 es6将这个行为标准化了，现在es6运行时环境都执行这个标准
    
    **箭头函数
        提示：箭头函数也有name，这和其他函数规则相同
        1-箭头函数语法
            1-1：当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后箭头右侧的表达式被求值后便立即返回
                ```js
                    let arr = value => value
                ```
            1-2：如果要传入俩个或者俩个以上的参数
                ```js
                    let sum = (num1,num2)=>num1 + num2
                ```
            1-3：如果函数没有参数
                ```js
                    let sum = () =>"shihui"
                ```
            1-4：有函数体且有箭头
                ```js
                    let sum = (num1,num2)=>{
                        return num1 + num2
                    }
                ```
            1-5:如果想创建空函数，需要写一对没有内容的花括号
                ```js
                    let dosomething = ()=>{}
                ```
            1-6:箭头函数返回一个对象字面量的写法
                ```js
                    let dosomething = (id) = ({id:id,name:"shihui"})
                ```

        2-创建立即执行函数表达式
            2-1：箭头函数立即执行函数的写法：只要将箭头函数包裹在小括号内，就可以用它实现立即执行函数的功能
                ```js
                    let person = ((name)=>{
                        return {
                            name:name
                        }
                    })("shihui")
                ```
        
        3-箭头函数和数组
            箭头函数结合数组方法(要求这里的数组方法接受的参数是函数)，所以箭头函数和数组方法结合的语法非常简洁
        4-箭头函数没有arguments绑定
            箭头函数灭有自己的arguments对象，但是箭头函数始终可以访问外围函数的arguments对象
        5-箭头函数的辨识方法
            注意：使用typeof和instanceof测试箭头函数类型和普通函数都是一样的
        6-尾调用
            定义：函数作为另一个函数的最后一条语句被调用
            es5关于尾调用的执行思路及存在的问题：创建一个新的栈桢，将其推入调用栈来表示函数调用。也就是说，在循环调用中，每一个未调用完的栈桢都会被保存在内存中，当调用栈过大时会造成程序问题
        7-es6关于尾调用优化
            7-1：关于es6优化尾调用需要满足的情况：
                    7-1-1：尾调用不访问当前栈桢的变量
                    7-1-2：在函数内部，尾调用是最后一条语句
                    7-1-3：尾调用的结果作为函数值返回
            7-2：尾调用无法优化的情况
                7-2-1：尾调用没有返回结果
                    ```js
                        function dosome(){
                            dosomeElse()
                        }
                    ```
                7-2-2：在返回值时添加其他操作
                    ```js
                        function dosome(){
                            return 1 + dosomeElse()
                        }

                    ```
                7-2-3：将函数调用的结果存储在一个变量里
                    ```js
                        function dosome(){
                            var result = dosomeElse()
                            return result
                        }
                    ```
                7-2-4：闭包情况，也就是访问函数作用域内的局部变量
                    ```js
                        function dosome(){
                            var num = 1
                            var func = () => num  //闭包func()访问了num变量
                            return func()
                        }
                    ```

        8-如何利用尾调用优化
            注意点：当写递归函数时，记得使用尾调用优化的特性，如果递归函数的计算量足够大，则尾递归优化可以大幅度提升程序性能
            


