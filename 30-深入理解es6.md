###字符串和正则表达式

###其他字符串变更
    *字符串中的子串识别
        1-includes():在字符串中检测到指定文本返回true，否则返回false
        2-startsWith():在字符串的起始部分检测到指定文本则返回true，否则返回false
        3-endsWith():在字符串的结束部分检测到指定文本则返回true，否则返回false
        注意：1-以上3种方法都接受俩个参数，第一个参数指定要搜索的文本；第二个参数可选，指定一个开始搜索的位置的索引值
            如果指定了第二个参数则includes()方法和startsWith()方法会从这个索引值的位置开始匹配，endsWith()方法则从这个索引值减去欲搜索文本长度的位置开始正向匹配，对字符进行逐个比较
            2-对于startsWith(),endsWith(),includes()这3个方法，如果没有按照要求传入字符串而是传入了正则表达式，则会触发错误；而对于indexOf和lastIndexOf()这俩个方法，他们都会把传入的正则表达式转化为一个字符串并搜索它
    *repeat()方法
        'shihui'.repeat(2)==> shihuishihui
        其接受一个number类型的参数，表示该字符串的重复次数，返回当前字符串重复一定次数后的新字符串
###其他正则表达式的语法变更
    *正则表达式y修饰符
    *正则表达式的复制
        在es5中可以通过RegExp构造函数传递正则表达式作为参数复制这个正则表达式比如
```js
            var re1 = /ab/i;
            var re2 = new RegExp(re1)
            此处变量re2只是变量re1的一份拷贝，如果在es5中给RegExp构造函数提供第二个参数为正则表达式指定一个修饰符，则代码无法运行，但是在es6中这段代码是可以运行的
```
    *flags属性
        定义：能够更加简单的获取正则表达式的修饰符
        相关的source属性是es5中获取正则表达式的文本的属性，跟flags属性用法一样
            例子：let re= /ab/g
                 re.flags ==> g
                 re.source ==> ab


###模板字面量
    *基础语法
        只是用反撇号替换了单，双引号
        如果想在字符串中使用反撇号`，那么用反斜杠(\)将它转义就可以，而在模板字面量中不需要转义单，双引号
    *多行字符串
        在之前的版本中多行字符需要用到换行符，或者(\)承接上一行字符
        在es6版本中在反撇号内只需要直接换行，此处的换行将同步出现在结果中
        注意点：1-在反撇号中的所有空白符都属于字符串的一部分，所以千万要小心缩进
    *字符串占位符
        模板字符串和普通的字符串二者真正的区别在于模板字面量中的占位符功能
        用法 ${}  中间可以写任何的js的表达式
    *标签模板
        对标签模板的理解：每个标签模板都可以执行模板字面量上的转换并返回最终的字符串值
        1-标签
            定义：
            1-在模板字面量第一个反撇号(`)前方标注的字符串   如 let message = tag`hello world` tag则是模板字面量`hello world`的模板标签
            function tag(literals,...substitutions){}
            2-标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含以下元素：第一个占位符前的空字符串
                      第一，二个占位符之间的字符串
                      第二个占位符后的字符串
            3-函数的第二个参数也是数组包含：第一个占位符的值
                                       第二个占位符的值
        2-在模板字面量中使用原始值
            String.raw() 使用内建的String.raw()可以输出字符串的原生形式，包含转义的字符
            例如：let message = String.raw`shihui\nstring` ===> "shihui\\nstring" 
            不使用String.raw()则会解析\n   let message `shihui\nstring` ===> "shihui
                                                                           string"


                
###函数
    



