###字符串和正则表达式

###其他字符串变更
    *字符串中的子串识别
        1-includes():在字符串中检测到指定文本返回true，否则返回false
        2-startsWith():在字符串的起始部分检测到指定文本则返回true，否则返回false
        3-endsWith():在字符串的结束部分检测到指定文本则返回true，否则返回false
        注意：1-以上3种方法都接受俩个参数，第一个参数指定要搜索的文本；第二个参数可选，指定一个开始搜索的位置的索引值
            如果指定了第二个参数则includes()方法和startsWith()方法会从这个索引值的位置开始匹配，endsWith()方法则从这个索引值减去欲搜索文本长度的位置开始正向匹配，对字符进行逐个比较
            2-对于startsWith(),endsWith(),includes()这3个方法，如果没有按照要求传入字符串而是传入了正则表达式，则会触发错误；而对于indexOf和lastIndexOf()这俩个方法，他们都会把传入的正则表达式转化为一个字符串并搜索它
    *repeat()方法
        'shihui'.repeat(2)==> shihuishihui
        其接受一个number类型的参数，表示该字符串的重复次数，返回当前字符串重复一定次数后的新字符串
###其他正则表达式的语法变更
    *正则表达式y修饰符
    *正则表达式的复制
        在es5中可以通过RegExp构造函数传递正则表达式作为参数复制这个正则表达式比如
```js
            var re1 = /ab/i;
            var re2 = new RegExp(re1)
            此处变量re2只是变量re1的一份拷贝，如果在es5中给RegExp构造函数提供第二个参数为正则表达式指定一个修饰符，则代码无法运行，但是在es6中这段代码是可以运行的
```
    *flags属性
        定义：能够更加简单的获取正则表达式的修饰符
        相关的source属性是es5中获取正则表达式的文本的属性，跟flags属性用法一样
            例子：let re= /ab/g
                 re.flags ==> g
                 re.source ==> ab


###模板字面量
    *基础语法
        只是用反撇号替换了单，双引号
        如果想在字符串中使用反撇号`，那么用反斜杠(\)将它转义就可以，而在模板字面量中不需要转义单，双引号
    *多行字符串
        在之前的版本中多行字符需要用到换行符，或者(\)承接上一行字符
        在es6版本中在反撇号内只需要直接换行，此处的换行将同步出现在结果中
        注意点：1-在反撇号中的所有空白符都属于字符串的一部分，所以千万要小心缩进
    *字符串占位符
        模板字符串和普通的字符串二者真正的区别在于模板字面量中的占位符功能
        用法 ${}  中间可以写任何的js的表达式
    *标签模板
        对标签模板的理解：每个标签模板都可以执行模板字面量上的转换并返回最终的字符串值
        1-标签
            定义：
            1-在模板字面量第一个反撇号(`)前方标注的字符串   如 let message = tag`hello world` tag则是模板字面量`hello world`的模板标签
            function tag(literals,...substitutions){}
            2-标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含以下元素：第一个占位符前的空字符串
                      第一，二个占位符之间的字符串
                      第二个占位符后的字符串
            3-函数的第二个参数也是数组包含：第一个占位符的值
                                       第二个占位符的值
        2-在模板字面量中使用原始值
            String.raw() 使用内建的String.raw()可以输出字符串的原生形式，包含转义的字符
            例如：let message = String.raw`shihui\nstring` ===> "shihui\\nstring" 
            不使用String.raw()则会解析\n   let message `shihui\nstring` ===> "shihui
                                                                           string"


                
###函数
    **函数形参的默认值
        1-函数形参的默认值
            定义：在函数定义中声明了多少个形参，都可以传入任意数量的参数，也可以在定义函数时添加针对参数数量的处理逻辑，当已定义的形参无对应的传入参数时为其指定一个默认值
        2-es6中的默认值参数值
            注意点：对于默认参数null是一个合法值，也就是说null会当做合法值处理则不会使用函数的默认值，而传入undefined时函数会使用参数的默认值
        3-默认参数对arguments对象的影响
            es6中总是可以通过arguments对象将参数恢复为初始值，无论当前是否在严格模式的环境下，也就是说arguments只代表函数参数初始值，函数传入一个值arguments长度为1
            注意：arguments指的是函数传入的实际参数的初始值，并不是指默认值。
        4-默认参数表达式
            定义：函数返回值作为默认值
            ```js
                例子：
                function getValue(){
                    return 5
                }
                function add(first,second=getValue()){
                    return first + second
                }
            ```
            执行逻辑：初次解析函数声明时不会调用getValue()方法，只有当调用add()函数且不传入第二个参数时才会调用
            注意：当使用函数调用结果作为默认参数值时，如果忘记写小括号，例如，second=getValue,则最终传入的是对函数的引用，而不是函数调用的结果

            错误示范：
            ```js
                function add(first=second,second){
                    return fisrt + second
                }
            ```
            调用add(undefind,1)会抛出错误，因为second比first晚定义，因此second不能作为first的默认值，可以用临时死区定义
    
    
    **处理无命名参数
        1-不定参数
            定义：在函数的命名参数前添加三个点(...)就表明这是一个不定参数，该参数为一个数组
            1-1不定参数的使用限制
                1-1-1：每个函数最多只能声明一个不定参数，而且一定要放在所有参数末尾
                1-1-2：不定参数不能用于对象字面量setter中，那么下面这段代码实例会导抛出语法错误
                        原因是：存在这条限制，是因为对象字面量setter的参数有且只能有一个
                ```js
                    let object = {
                        // 语法错误，这里不能再setter中使用不定参数
                        set name(...value){}
                    }
                ```
            1-2不定参数对arguments对象的影响
                结论：不定参数和对象arguments字面量同时存在
                    无论是否使用不定参数，arguments对象总是包含所有传入函数的参数

    **增强的function构造函数
        注意点：这种构造函数接受字符串形式的参数,使用不定参数时也需要家引号如"...arg"
        ```js
            var arr = new function('first','second','return first + second')
        ```

        1-展开运算符
            定义：展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数，也就是解构的方式将数组解构成一个个的值

    **name属性
        为什么：因为js中定义函数的方式有很多种，因而辨别函数就比较困难
        1-name属性的特殊情况
            1-1：
            ```js
                var doSomething = function doSomethingElse(){}
                var person = {
                    get firstName(){}
                }
                doSomething.name  //结果为 doSomethingElse  
                person.firstName.name //结果为 get firstName
            ```
            解释doSomething的name不是doSomething而是doSomethingElse,因为函数表达式有一个名字，这个名字比函数本身被赋值的变量的权限要高
            1-2：
                1-2-1通过bind()函数创建的函数，其名称带有bound前缀
                    ```js
                        var dosomething = function(){}
                        dosomething.bind().name  //结果为bound dosomething
                    ```
                1-2-2通过function构造函数创建的函数，其名称将是"anonymous"
                    ```js
                        (new function()).name  //结果为anonymous
                    ```
            
    **明确函数的多重用途
        解释：js函数有俩种不同的内部方法：[[Call]]和[[Construct]],当通过new关键字调用函数时,执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后在执行函数体，将this绑定到实体上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数
    
    **块级函数
        定义：在大括号{}里的函数被称为块级函数
        注意点：一旦if语句代码块结束执行，函数也就不复存在了，外部就访问不到函数了
        1-块级函数的使用场景
            注意点：块级函数会被提升至块的顶部，而用let定义的函数表达式不会被提升
        2-非严格模式下的块级函数
            特点：和严格模式下不同的是，非严格模式下的块级函数不再提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部
                 es6将这个行为标准化了，现在es6运行时环境都执行这个标准
    
    **箭头函数
        提示：箭头函数也有name，这和其他函数规则相同
        1-箭头函数语法
            1-1：当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后箭头右侧的表达式被求值后便立即返回
                ```js
                    let arr = value => value
                ```
            1-2：如果要传入俩个或者俩个以上的参数
                ```js
                    let sum = (num1,num2)=>num1 + num2
                ```
            1-3：如果函数没有参数
                ```js
                    let sum = () =>"shihui"
                ```
            1-4：有函数体且有箭头
                ```js
                    let sum = (num1,num2)=>{
                        return num1 + num2
                    }
                ```
            1-5:如果想创建空函数，需要写一对没有内容的花括号
                ```js
                    let dosomething = ()=>{}
                ```
            1-6:箭头函数返回一个对象字面量的写法
                ```js
                    let dosomething = (id) = ({id:id,name:"shihui"})
                ```

        2-创建立即执行函数表达式
            2-1：箭头函数立即执行函数的写法：只要将箭头函数包裹在小括号内，就可以用它实现立即执行函数的功能
                ```js
                    let person = ((name)=>{
                        return {
                            name:name
                        }
                    })("shihui")
                ```
        
        3-箭头函数和数组
            箭头函数结合数组方法(要求这里的数组方法接受的参数是函数)，所以箭头函数和数组方法结合的语法非常简洁
        4-箭头函数没有arguments绑定
            箭头函数灭有自己的arguments对象，但是箭头函数始终可以访问外围函数的arguments对象
        5-箭头函数的辨识方法
            注意：使用typeof和instanceof测试箭头函数类型和普通函数都是一样的
        6-尾调用
            定义：函数作为另一个函数的最后一条语句被调用
            es5关于尾调用的执行思路及存在的问题：创建一个新的栈桢，将其推入调用栈来表示函数调用。也就是说，在循环调用中，每一个未调用完的栈桢都会被保存在内存中，当调用栈过大时会造成程序问题
        7-es6关于尾调用优化
            7-1：关于es6优化尾调用需要满足的情况：
                    7-1-1：尾调用不访问当前栈桢的变量
                    7-1-2：在函数内部，尾调用是最后一条语句
                    7-1-3：尾调用的结果作为函数值返回
            7-2：尾调用无法优化的情况
                7-2-1：尾调用没有返回结果
                    ```js
                        function dosome(){
                            dosomeElse()
                        }
                    ```
                7-2-2：在返回值时添加其他操作
                    ```js
                        function dosome(){
                            return 1 + dosomeElse()
                        }

                    ```
                7-2-3：将函数调用的结果存储在一个变量里
                    ```js
                        function dosome(){
                            var result = dosomeElse()
                            return result
                        }
                    ```
                7-2-4：闭包情况，也就是访问函数作用域内的局部变量
                    ```js
                        function dosome(){
                            var num = 1
                            var func = () => num  //闭包func()访问了num变量
                            return func()
                        }
                    ```

        8-如何利用尾调用优化
            注意点：当写递归函数时，记得使用尾调用优化的特性，如果递归函数的计算量足够大，则尾递归优化可以大幅度提升程序性能


###扩展对象的功能性
    **对象字面量扩展语法
        对象字面量如此流行的原因：
            1-我们想要创建的对象，不再需要编写冗余的代码，直接通过它简洁的语法就可以实现
            2-就连json也是基于它的语法构建的
        1-属性初始值的简写
            定义：当一个对象的属性与本地变量同名时，不必再写冒号和值，只写属性名即可，这也是对象初始化语法

        2-对象方法的简写语法
            定义：消除了冒号和function关键字
                ```js
                    let person = {
                        sayName(){}
                    }
                ```
            对象方法的简写语法和普通的写法，二者唯一的区别是，简写语法可以使用super关键字
        
        3-可计算属性名
            3-1定义：在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号
                ```js
                    let lastName = "shihui"
                    let person ={
                        [lastName]:"zakas"
                    }
                    // person[lastName]会转换为 person["shihui"]
                ```
            3-2在对象字面量中使用方括号表示的该属性名称是可计算的，它的内容将被求值并被最终转化为一个字符串
                ```js
                    let suffer = "name"
                    let person = {
                        ["last" + suffer]:"zakas"
                    }
                    // person["last" + name] 转化为  person["lastname"]
                ```
        
    **新增方法
            1 Object.is()方法
                作用：弥补全等运算符的不准确运算
                用法：这个方法接受俩个参数，如果这俩个参数类型相同且具有相同的值，则返回true
                ```js
                    Object.is(5,5) //返回结果true
                    Object.is(5,"5")  //返回结果为false
                ```
            2 Object.assign()方法
                定义：该方法可以接受任意数量的源对象，并按指定的顺序将属性复制到接受对象中
                用法：第一个参数为接受对象，后面的参数为任意多的源对象，如果对个源对象具有相同属性，则排在后面的源对象会覆盖排位靠前的
                ```js
                    let receiver = {}
                    Object.assign(receiver,
                    {
                        type:'js',
                        name:'file.js'
                    },
                    {
                        name:'shihui.js'
                    })
                    // 返回结果receiver.name = shihui.js   receiver.type = js 
                ```
                2-1：Object.getOwnPropertyDescriptor()
                    用法：参数一:要在其中查找的对象，参数二：要查找的属性；返回值：给定对象自身的属性(不存在原型链中)通过value可以拿到值
                    ```js
                        let supplier={
                            name:"shihui"
                        }
                        let receiver = Object.getOwnPropertyDescriptor(supplier,'name')
                        // receiver.value 返回结果为 name对象的值  shihui
                    ```

    **重复的对象字面量属性
            es5和es6处理重复属性的处理办法
            ```js
                var person = {
                    name:"nikesong",
                    name:"gray"
                }
            ```
            上述例子：当运行es5严格模式时，第二个name属性会触发一个语法错误；
                    但在es6中无论是在严格模式下还是费严格模式，对于每一组重复属性，都会选取最后一个取值
        
    **自有属性枚举顺序
            1自有属性枚举的基本规则:
                    1-1:所有数字按键升序排序
                    1-2:所有字符串键按照它们被加入对象的顺序排序
                    1-3:所有symbol键按照它们被加入对象顺序排序
            2：es6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到Object.getOwnPropertyNames()方法及Reflect.   ownKeys返回属性的方式，Object.assign()方法处理属性的顺序也会随之改变
            3：Object.keys()方法和JSON.stringfy()方法都指明与for-in使用相同的枚举顺序，因此他们的枚举顺序目前也不明晰
        
    **增强对象原型
            1：改变对象的原型
                1-1：Object.create()：该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__
                        例子：将person对象放到friend原型上
                            ```js
                                let person = {
                                    name:"shihui"
                                }
                                let friend = Object.create(person)
                            ```
                1-2:对象原型的真实值被储存在内部专有属性[[Prototype]]中，
                    调用Object.getPrototypeOf()方法返回对象原型中储存在其中的值
                    调用Object.setPrototypeOf()方法改变对象原型中的值 
                        用法：Object.setPrototypeOf(Object,prototype)  object要设置的对象，prototypey该对象的新原型
            
            2：简化原型方法的super引用
                注意点：super要在使用简写方法的对象中使用，如果在其他方法声明中使用会导致语法错误
                    例子：方法的简写方式  getGreeting(){}  而不是 function getGreeting(){}
                
                2-1:super关键字用于访问和调用一个对象的父对象上的函数
                    注意点：构造函数中使用super必须在this之前使用
                
                es6 super方法总结：super方法不是动态变化的，他总是指向正确的对象(指向一个对象则会始终指向这个对象)
        
    **正式的方法定义
            super深层原(这边可以不用太多理解)


###解构:使数据访问更便捷
    **为何使用解构功能
    **对象解构
        注意点：不要忘记初始化程序，就是给程序定义的时候设定值；如果使用var,let,const解构声明变量，则必须要初始化
              事例：var {type,name}  语法会报错因为没有初始化
        1-解构赋值
            ```js
                let node = {
                    type:"good",
                    name:"foo"
                },
                type = "books",
                name = 5;
                ({type,name} = node) 
            ```
            1-1 //这里一定要用小括号包裹解构赋值语句，原因：js引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程
            1-2 
            ```js
                let node = {
                    type:"good",
                    name:"foo"
                },
                type = "books",
                name = 5;
                function output(value){
                    console.log(value === node)
                }
                output({type,name} = node)  
            ```
            //这里函数参数传入解构形式参数解释：js表达式的值为右侧的值，因而此处传入的参数等同于node，且变量type和name被重新赋值，最终将node传入output()函数
        
        2-默认值
            2-1在解构赋值大括号里，没有被解构对象对应的属性名，那就会被赋值undefined
               用法：当指定的属性不存在时，可以随意定义一个默认值，在属性名称后面添加一个等号(=)和相应的默认值即可
                ```js
                    let node = {
                        type:'food',
                        name:'foo'
                    }
                    let {type,name,value = true} = node
                ```
                2-1-1默认值的生效条件：只有当node上没有该属性或者该属性值为undefined时该值才会生效

        3-为非同名局部变量赋值
            3-1解构非同名属性名的语法：
                type:localType语法的含义是读取名为type的属性并将其值存储在变量localType中，这种语法实际上与传统对象字面量的语法相悖，原来的语法名称在左边，值在右边；现在变量名称在冒号右边，而需要读取的位置(对象的属性名)在左边
                实例：
                ```js
                    let node = {
                            type:'food',
                            name:'foo'
                        }
                    let {type:localType,name:localName} = node
                    // localType是type对应的非同名的属性名，localType和type打印出的结果是一样的
                ```
            3-2使用其他变量名赋值添加默认值
                当使用其他变量名进行赋值时也可以添加默认值，只需要在变量名后添加等号和默认值即可
                ```js
                    let node = {
                        type:'food',
                        name:'foo'
                    }
                    let {type:localType,name:localName,value:localValue = "bar"} = node
                ```

        4-嵌套对象解构
            4-1：对象深层解构
            4-2：不同局部变量名解构(和非同名局部变量赋值差不多)
    

    **数组解构
        数组解构可以任意命名，这一点与对象解构不同
        注意点：数组结果过程中，数组本身不会发生任何变化
        1-解构赋值
            数组解构可以用于赋值上下文，但不需要用小括号包裹起来，这点与对象解构不同
            ```js
                let color = ["red","green","blue"],
                    firstColor = "white",
                    secondColor =  "black"
                [firstColor,secondColor] = color
            ```
            1-1数组解构还有一个特别的用例：交换俩个变量值
            ```js
                let a = 1, b = 2
                [a,b] = [b,a]
            ```
            注意点：如果右侧数组解构赋值表达式的值为null或undefined，则会导致程序抛出错误，这一特性与对象解构赋值很相似

        2-默认值
            定义：数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或其值为undefined时使用默认值，数组解构的默认值和对象解构默认值差不多
            用法：let [firstColor,secondColor = "black"] = color
        
        3-嵌套数组解构
            定义：嵌套数组解构和嵌套对象解构的语法相似
        
        4-不定元素
            概念：不定元素，在数组中，可以通过(...)语法将数组中的其余元素赋值给一个特定的变量
            用例
            ```js
                let colors = ['red','blue','orange']
                let [firstColor,...secondColor] = colors
                // secondColor 返回结果为['blue','orange']的数组
            ```
            注意点：不定元素必须为最后一个条目，在后面继续添加逗号会导致程序抛出错误

        
    **混合结构
        对象解构+数组解构可以混合起来用
        不管结构多复杂，都可轻松的提取任意想要的信息
    
    **解构参数
        定义：结构参数需要使用对象或数组解构模式代替函数参数
        注意点：解构参数支持对象解构和数组解构的所有特性

        1-必须传值的解构参数
            解构参数也就是当函数参数中有对象解构或者数组解构时，js引擎实际上做了这些事儿(解构参数的原理)
            ```js
                function setcookie(name,value,opiton){
                    let {secure,path,domain,expires} = option
                }
            ```
            由此可见，如果解构赋值表达式的右值为null或undefined，则程序会报错，同理如果调用setcookie()函数时不传入第3个参数，也会导致程序报错
            
            1-1解决结构参数不传值报错的问题
                方法：如果希望解构参数定义为可选，那么就必须为其提供默认值来解决这个问题
                    ```js
                        function setcookie(name,value,{secure,path,domain,expires} = {})
                    ```
        
        2-解构参数的默认值
            概念：可以为解构参数指定默认值，就像在解构赋值语句中做的那样，只需在参数后添加等号并且指定一个默认程序
                 结合为了函数解构参数不传值会导出程序抛出错误
                实例：
                ```js
                    const setcookiedefault = {
                        secure:false,
                        path:'/',
                        domain:'example.com'
                    }
                    function setcookie(name,value,{
                        secure = setcookiedefault.secure,
                        path = setcookiedefault.path,
                        domain = setcookiedefault.domain
                    } = setcookiedefault
                    ){} 
                    // 即是setcookie函数不传入第三个参数程序也不会报错
                ```




    





