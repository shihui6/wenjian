###字符串和正则表达式

###其他字符串变更
    *字符串中的子串识别
        1-includes():在字符串中检测到指定文本返回true，否则返回false
        2-startsWith():在字符串的起始部分检测到指定文本则返回true，否则返回false
        3-endsWith():在字符串的结束部分检测到指定文本则返回true，否则返回false
        注意：1-以上3种方法都接受俩个参数，第一个参数指定要搜索的文本；第二个参数可选，指定一个开始搜索的位置的索引值
            如果指定了第二个参数则includes()方法和startsWith()方法会从这个索引值的位置开始匹配，endsWith()方法则从这个索引值减去欲搜索文本长度的位置开始正向匹配，对字符进行逐个比较
            2-对于startsWith(),endsWith(),includes()这3个方法，如果没有按照要求传入字符串而是传入了正则表达式，则会触发错误；而对于indexOf和lastIndexOf()这俩个方法，他们都会把传入的正则表达式转化为一个字符串并搜索它
    *repeat()方法
        'shihui'.repeat(2)==> shihuishihui
        其接受一个number类型的参数，表示该字符串的重复次数，返回当前字符串重复一定次数后的新字符串
###其他正则表达式的语法变更
    *正则表达式y修饰符
    *正则表达式的复制
        在es5中可以通过RegExp构造函数传递正则表达式作为参数复制这个正则表达式比如
```js
            var re1 = /ab/i;
            var re2 = new RegExp(re1)
            此处变量re2只是变量re1的一份拷贝，如果在es5中给RegExp构造函数提供第二个参数为正则表达式指定一个修饰符，则代码无法运行，但是在es6中这段代码是可以运行的
```
    *flags属性
        定义：能够更加简单的获取正则表达式的修饰符
        相关的source属性是es5中获取正则表达式的文本的属性，跟flags属性用法一样
            例子：let re= /ab/g
                 re.flags ==> g
                 re.source ==> ab


###模板字面量
    *基础语法
        只是用反撇号替换了单，双引号
        如果想在字符串中使用反撇号`，那么用反斜杠(\)将它转义就可以，而在模板字面量中不需要转义单，双引号
    *多行字符串
        在之前的版本中多行字符需要用到换行符，或者(\)承接上一行字符
        在es6版本中在反撇号内只需要直接换行，此处的换行将同步出现在结果中
        注意点：1-在反撇号中的所有空白符都属于字符串的一部分，所以千万要小心缩进
    *字符串占位符
        模板字符串和普通的字符串二者真正的区别在于模板字面量中的占位符功能
        用法 ${}  中间可以写任何的js的表达式
    *标签模板
        对标签模板的理解：每个标签模板都可以执行模板字面量上的转换并返回最终的字符串值
        1-标签
            定义：
            1-在模板字面量第一个反撇号(`)前方标注的字符串   如 let message = tag`hello world` tag则是模板字面量`hello world`的模板标签
            function tag(literals,...substitutions){}
            2-标签可以是一个函数，调用时传入加工过的模板字面量各部分数据，但必须结合每个部分来创建结果。第一个参数是一个数组，包含以下元素：第一个占位符前的空字符串
                      第一，二个占位符之间的字符串
                      第二个占位符后的字符串
            3-函数的第二个参数也是数组包含：第一个占位符的值
                                       第二个占位符的值
        2-在模板字面量中使用原始值
            String.raw() 使用内建的String.raw()可以输出字符串的原生形式，包含转义的字符
            例如：let message = String.raw`shihui\nstring` ===> "shihui\\nstring" 
            不使用String.raw()则会解析\n   let message `shihui\nstring` ===> "shihui
                                                                           string"


                
###函数
    **函数形参的默认值
        1-函数形参的默认值
            定义：在函数定义中声明了多少个形参，都可以传入任意数量的参数，也可以在定义函数时添加针对参数数量的处理逻辑，当已定义的形参无对应的传入参数时为其指定一个默认值
        2-es6中的默认值参数值
            注意点：对于默认参数null是一个合法值，也就是说null会当做合法值处理则不会使用函数的默认值，而传入undefined时函数会使用参数的默认值
        3-默认参数对arguments对象的影响
            es6中总是可以通过arguments对象将参数恢复为初始值，无论当前是否在严格模式的环境下，也就是说arguments只代表函数参数初始值，函数传入一个值arguments长度为1
            注意：arguments指的是函数传入的实际参数的初始值，并不是指默认值。
        4-默认参数表达式
            定义：函数返回值作为默认值
            ```js
                例子：
                function getValue(){
                    return 5
                }
                function add(first,second=getValue()){
                    return first + second
                }
            ```
            执行逻辑：初次解析函数声明时不会调用getValue()方法，只有当调用add()函数且不传入第二个参数时才会调用
            注意：当使用函数调用结果作为默认参数值时，如果忘记写小括号，例如，second=getValue,则最终传入的是对函数的引用，而不是函数调用的结果

            错误示范：
            ```js
                function add(first=second,second){
                    return fisrt + second
                }
            ```
            调用add(undefind,1)会抛出错误，因为second比first晚定义，因此second不能作为first的默认值，可以用临时死区定义
    
    
    **处理无命名参数
        1-不定参数
            定义：在函数的命名参数前添加三个点(...)就表明这是一个不定参数，该参数为一个数组
            1-1不定参数的使用限制
                1-1-1：每个函数最多只能声明一个不定参数，而且一定要放在所有参数末尾
                1-1-2：不定参数不能用于对象字面量setter中，那么下面这段代码实例会导抛出语法错误
                        原因是：存在这条限制，是因为对象字面量setter的参数有且只能有一个
                ```js
                    let object = {
                        // 语法错误，这里不能再setter中使用不定参数
                        set name(...value){}
                    }
                ```
            1-2不定参数对arguments对象的影响
                结论：不定参数和对象arguments字面量同时存在
                    无论是否使用不定参数，arguments对象总是包含所有传入函数的参数

    **增强的function构造函数
        注意点：这种构造函数接受字符串形式的参数,使用不定参数时也需要家引号如"...arg"
        ```js
            var arr = new function('first','second','return first + second')
        ```

        1-展开运算符
            定义：展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数，也就是解构的方式将数组解构成一个个的值

    **name属性
        为什么：因为js中定义函数的方式有很多种，因而辨别函数就比较困难
        1-name属性的特殊情况
            1-1：
            ```js
                var doSomething = function doSomethingElse(){}
                var person = {
                    get firstName(){}
                }
                doSomething.name  //结果为 doSomethingElse  
                person.firstName.name //结果为 get firstName
            ```
            解释doSomething的name不是doSomething而是doSomethingElse,因为函数表达式有一个名字，这个名字比函数本身被赋值的变量的权限要高
            1-2：
                1-2-1通过bind()函数创建的函数，其名称带有bound前缀
                    ```js
                        var dosomething = function(){}
                        dosomething.bind().name  //结果为bound dosomething
                    ```
                1-2-2通过function构造函数创建的函数，其名称将是"anonymous"
                    ```js
                        (new function()).name  //结果为anonymous
                    ```
            
    **明确函数的多重用途
        解释：js函数有俩种不同的内部方法：[[Call]]和[[Construct]],当通过new关键字调用函数时,执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后在执行函数体，将this绑定到实体上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数
    
    **块级函数
        定义：在大括号{}里的函数被称为块级函数
        注意点：一旦if语句代码块结束执行，函数也就不复存在了，外部就访问不到函数了
        1-块级函数的使用场景
            注意点：块级函数会被提升至块的顶部，而用let定义的函数表达式不会被提升
        2-非严格模式下的块级函数
            特点：和严格模式下不同的是，非严格模式下的块级函数不再提升至代码块的顶部，而是提升至外围函数或全局作用域的顶部
                 es6将这个行为标准化了，现在es6运行时环境都执行这个标准
    
    **箭头函数
        提示：箭头函数也有name，这和其他函数规则相同
        1-箭头函数语法
            1-1：当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后箭头右侧的表达式被求值后便立即返回
                ```js
                    let arr = value => value
                ```
            1-2：如果要传入俩个或者俩个以上的参数
                ```js
                    let sum = (num1,num2)=>num1 + num2
                ```
            1-3：如果函数没有参数
                ```js
                    let sum = () =>"shihui"
                ```
            1-4：有函数体且有箭头
                ```js
                    let sum = (num1,num2)=>{
                        return num1 + num2
                    }
                ```
            1-5:如果想创建空函数，需要写一对没有内容的花括号
                ```js
                    let dosomething = ()=>{}
                ```
            1-6:箭头函数返回一个对象字面量的写法
                ```js
                    let dosomething = (id) = ({id:id,name:"shihui"})
                ```

        2-创建立即执行函数表达式
            2-1：箭头函数立即执行函数的写法：只要将箭头函数包裹在小括号内，就可以用它实现立即执行函数的功能
                ```js
                    let person = ((name)=>{
                        return {
                            name:name
                        }
                    })("shihui")
                ```
        
        3-箭头函数和数组
            箭头函数结合数组方法(要求这里的数组方法接受的参数是函数)，所以箭头函数和数组方法结合的语法非常简洁
        4-箭头函数没有arguments绑定
            箭头函数灭有自己的arguments对象，但是箭头函数始终可以访问外围函数的arguments对象
        5-箭头函数的辨识方法
            注意：使用typeof和instanceof测试箭头函数类型和普通函数都是一样的
        6-尾调用
            定义：函数作为另一个函数的最后一条语句被调用
            es5关于尾调用的执行思路及存在的问题：创建一个新的栈桢，将其推入调用栈来表示函数调用。也就是说，在循环调用中，每一个未调用完的栈桢都会被保存在内存中，当调用栈过大时会造成程序问题
        7-es6关于尾调用优化
            7-1：关于es6优化尾调用需要满足的情况：
                    7-1-1：尾调用不访问当前栈桢的变量
                    7-1-2：在函数内部，尾调用是最后一条语句
                    7-1-3：尾调用的结果作为函数值返回
            7-2：尾调用无法优化的情况
                7-2-1：尾调用没有返回结果
                    ```js
                        function dosome(){
                            dosomeElse()
                        }
                    ```
                7-2-2：在返回值时添加其他操作
                    ```js
                        function dosome(){
                            return 1 + dosomeElse()
                        }

                    ```
                7-2-3：将函数调用的结果存储在一个变量里
                    ```js
                        function dosome(){
                            var result = dosomeElse()
                            return result
                        }
                    ```
                7-2-4：闭包情况，也就是访问函数作用域内的局部变量
                    ```js
                        function dosome(){
                            var num = 1
                            var func = () => num  //闭包func()访问了num变量
                            return func()
                        }
                    ```

        8-如何利用尾调用优化
            注意点：当写递归函数时，记得使用尾调用优化的特性，如果递归函数的计算量足够大，则尾递归优化可以大幅度提升程序性能


###扩展对象的功能性
    **对象字面量扩展语法
        对象字面量如此流行的原因：
            1-我们想要创建的对象，不再需要编写冗余的代码，直接通过它简洁的语法就可以实现
            2-就连json也是基于它的语法构建的
        1-属性初始值的简写
            定义：当一个对象的属性与本地变量同名时，不必再写冒号和值，只写属性名即可，这也是对象初始化语法

        2-对象方法的简写语法
            定义：消除了冒号和function关键字
                ```js
                    let person = {
                        sayName(){}
                    }
                ```
            对象方法的简写语法和普通的写法，二者唯一的区别是，简写语法可以使用super关键字
        
        3-可计算属性名
            3-1定义：在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号
                ```js
                    let lastName = "shihui"
                    let person ={
                        [lastName]:"zakas"
                    }
                    // person[lastName]会转换为 person["shihui"]
                ```
            3-2在对象字面量中使用方括号表示的该属性名称是可计算的，它的内容将被求值并被最终转化为一个字符串
                ```js
                    let suffer = "name"
                    let person = {
                        ["last" + suffer]:"zakas"
                    }
                    // person["last" + name] 转化为  person["lastname"]
                ```
        
    **新增方法
            1 Object.is()方法
                作用：弥补全等运算符的不准确运算
                用法：这个方法接受俩个参数，如果这俩个参数类型相同且具有相同的值，则返回true
                ```js
                    Object.is(5,5) //返回结果true
                    Object.is(5,"5")  //返回结果为false
                ```
            2 Object.assign()方法
                定义：该方法可以接受任意数量的源对象，并按指定的顺序将属性复制到接受对象中
                用法：第一个参数为接受对象，后面的参数为任意多的源对象，如果对个源对象具有相同属性，则排在后面的源对象会覆盖排位靠前的
                ```js
                    let receiver = {}
                    Object.assign(receiver,
                    {
                        type:'js',
                        name:'file.js'
                    },
                    {
                        name:'shihui.js'
                    })
                    // 返回结果receiver.name = shihui.js   receiver.type = js 
                ```
                2-1：Object.getOwnPropertyDescriptor()
                    用法：参数一:要在其中查找的对象，参数二：要查找的属性；返回值：给定对象自身的属性(不存在原型链中)通过value可以拿到值
                    ```js
                        let supplier={
                            name:"shihui"
                        }
                        let receiver = Object.getOwnPropertyDescriptor(supplier,'name')
                        // receiver.value 返回结果为 name对象的值  shihui
                    ```

    **重复的对象字面量属性
            es5和es6处理重复属性的处理办法
            ```js
                var person = {
                    name:"nikesong",
                    name:"gray"
                }
            ```
            上述例子：当运行es5严格模式时，第二个name属性会触发一个语法错误；
                    但在es6中无论是在严格模式下还是费严格模式，对于每一组重复属性，都会选取最后一个取值
        
    **自有属性枚举顺序
            1自有属性枚举的基本规则:
                    1-1:所有数字按键升序排序
                    1-2:所有字符串键按照它们被加入对象的顺序排序
                    1-3:所有symbol键按照它们被加入对象顺序排序
            2：es6严格规定了对象的自有属性被枚举时的返回顺序，这会影响到Object.getOwnPropertyNames()方法及Reflect.   ownKeys返回属性的方式，Object.assign()方法处理属性的顺序也会随之改变
            3：Object.keys()方法和JSON.stringfy()方法都指明与for-in使用相同的枚举顺序，因此他们的枚举顺序目前也不明晰
        
    **增强对象原型
            1：改变对象的原型
                1-1：Object.create()：该方法创建一个新对象，使用现有的对象提供新创建对象的__proto__
                        例子：将person对象放到friend原型上
                            ```js
                                let person = {
                                    name:"shihui"
                                }
                                let friend = Object.create(person)
                            ```
                1-2:对象原型的真实值被储存在内部专有属性[[Prototype]]中，
                    调用Object.getPrototypeOf()方法返回对象原型中储存在其中的值
                    调用Object.setPrototypeOf()方法改变对象原型中的值 
                        用法：Object.setPrototypeOf(Object,prototype)  object要设置的对象，prototypey该对象的新原型
            
            2：简化原型方法的super引用
                注意点：super要在使用简写方法的对象中使用，如果在其他方法声明中使用会导致语法错误
                    例子：方法的简写方式  getGreeting(){}  而不是 function getGreeting(){}
                
                2-1:super关键字用于访问和调用一个对象的父对象上的函数
                    注意点：构造函数中使用super必须在this之前使用
                
                es6 super方法总结：super方法不是动态变化的，他总是指向正确的对象(指向一个对象则会始终指向这个对象)
        
    **正式的方法定义
            super深层原(这边可以不用太多理解)


###解构:使数据访问更便捷
    **为何使用解构功能
    **对象解构
        注意点：不要忘记初始化程序，就是给程序定义的时候设定值；如果使用var,let,const解构声明变量，则必须要初始化
              事例：var {type,name}  语法会报错因为没有初始化
        1-解构赋值
            ```js
                let node = {
                    type:"good",
                    name:"foo"
                },
                type = "books",
                name = 5;
                ({type,name} = node) 
            ```
            1-1 //这里一定要用小括号包裹解构赋值语句，原因：js引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程
            1-2 
            ```js
                let node = {
                    type:"good",
                    name:"foo"
                },
                type = "books",
                name = 5;
                function output(value){
                    console.log(value === node)
                }
                output({type,name} = node)  
            ```
            //这里函数参数传入解构形式参数解释：js表达式的值为右侧的值，因而此处传入的参数等同于node，且变量type和name被重新赋值，最终将node传入output()函数
        
        2-默认值
            2-1在解构赋值大括号里，没有被解构对象对应的属性名，那就会被赋值undefined
               用法：当指定的属性不存在时，可以随意定义一个默认值，在属性名称后面添加一个等号(=)和相应的默认值即可
                ```js
                    let node = {
                        type:'food',
                        name:'foo'
                    }
                    let {type,name,value = true} = node
                ```
                2-1-1默认值的生效条件：只有当node上没有该属性或者该属性值为undefined时该值才会生效

        3-为非同名局部变量赋值
            3-1解构非同名属性名的语法：
                type:localType语法的含义是读取名为type的属性并将其值存储在变量localType中，这种语法实际上与传统对象字面量的语法相悖，原来的语法名称在左边，值在右边；现在变量名称在冒号右边，而需要读取的位置(对象的属性名)在左边
                实例：
                ```js
                    let node = {
                            type:'food',
                            name:'foo'
                        }
                    let {type:localType,name:localName} = node
                    // localType是type对应的非同名的属性名，localType和type打印出的结果是一样的
                ```
            3-2使用其他变量名赋值添加默认值
                当使用其他变量名进行赋值时也可以添加默认值，只需要在变量名后添加等号和默认值即可
                ```js
                    let node = {
                        type:'food',
                        name:'foo'
                    }
                    let {type:localType,name:localName,value:localValue = "bar"} = node
                ```

        4-嵌套对象解构
            4-1：对象深层解构
            4-2：不同局部变量名解构(和非同名局部变量赋值差不多)
    

    **数组解构
        数组解构可以任意命名，这一点与对象解构不同
        注意点：数组结果过程中，数组本身不会发生任何变化
        1-解构赋值
            数组解构可以用于赋值上下文，但不需要用小括号包裹起来，这点与对象解构不同
            ```js
                let color = ["red","green","blue"],
                    firstColor = "white",
                    secondColor =  "black"
                [firstColor,secondColor] = color
            ```
            1-1数组解构还有一个特别的用例：交换俩个变量值
            ```js
                let a = 1, b = 2
                [a,b] = [b,a]
            ```
            注意点：如果右侧数组解构赋值表达式的值为null或undefined，则会导致程序抛出错误，这一特性与对象解构赋值很相似

        2-默认值
            定义：数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或其值为undefined时使用默认值，数组解构的默认值和对象解构默认值差不多
            用法：let [firstColor,secondColor = "black"] = color
        
        3-嵌套数组解构
            定义：嵌套数组解构和嵌套对象解构的语法相似
        
        4-不定元素
            概念：不定元素，在数组中，可以通过(...)语法将数组中的其余元素赋值给一个特定的变量
            用例
            ```js
                let colors = ['red','blue','orange']
                let [firstColor,...secondColor] = colors
                // secondColor 返回结果为['blue','orange']的数组
            ```
            注意点：不定元素必须为最后一个条目，在后面继续添加逗号会导致程序抛出错误

        
    **混合结构
        对象解构+数组解构可以混合起来用
        不管结构多复杂，都可轻松的提取任意想要的信息
    
    **解构参数
        定义：结构参数需要使用对象或数组解构模式代替函数参数
        注意点：解构参数支持对象解构和数组解构的所有特性

        1-必须传值的解构参数
            解构参数也就是当函数参数中有对象解构或者数组解构时，js引擎实际上做了这些事儿(解构参数的原理)
            ```js
                function setcookie(name,value,opiton){
                    let {secure,path,domain,expires} = option
                }
            ```
            由此可见，如果解构赋值表达式的右值为null或undefined，则程序会报错，同理如果调用setcookie()函数时不传入第3个参数，也会导致程序报错
            
            1-1解决结构参数不传值报错的问题
                方法：如果希望解构参数定义为可选，那么就必须为其提供默认值来解决这个问题
                    ```js
                        function setcookie(name,value,{secure,path,domain,expires} = {})
                    ```
        
        2-解构参数的默认值
            概念：可以为解构参数指定默认值，就像在解构赋值语句中做的那样，只需在参数后添加等号并且指定一个默认程序
                 结合为了函数解构参数不传值会导出程序抛出错误
                实例：
                ```js
                    const setcookiedefault = {
                        secure:false,
                        path:'/',
                        domain:'example.com'
                    }
                    function setcookie(name,value,{
                        secure = setcookiedefault.secure,
                        path = setcookiedefault.path,
                        domain = setcookiedefault.domain
                    } = setcookiedefault
                    ){} 
                    // 即是setcookie函数不传入第三个参数程序也不会报错
                ```

###set和map集合
    **es6中的set集合
        set集合定义：set类型是一种有序列表，其中含有一些独立的非重复值，通过set集合可以快速访问其中的数据，更有效追踪离散值
        1-创建set集合并添加元素
            1-1用法：调用new Set()创建set集合；
                    调用add()方法向集合中添加元素；
                    访问集合size属性可以获取集合中目前的元素数量；
        
            1-2：set集合中，不会对所存值进行强制类型转换，比如数字5和字符串'5'可以作为俩个独立的元素存在
                注意点：Object.is()方法检测俩个值是否一致，唯一的例外是，set集合中的+0和-0被认为是相等的
            1-3：向集合中添加多个对象，则他们之间彼此保持独立
                ```js
                    let set = new Set(),
                    key1 = {},
                    key2 = {};
                    set.add(key1)
                    set.add(key2)
                    set.size  //返回结果为2 
                ```
                原理是：由于key1和key2不会被转成字符串，因而他们在set集合中是俩个独立的元素
            1-4：多次调用add()方法并传入相同的值作为参数，那么后续的调用实际上会被忽略
                1-4-1：可以用数组来初始化set集合，set构造函数同样会过滤掉重复的值从而保证集合中的元素各自唯一
            1-5：has()方法
                定义：可以检测set集合中是否存在某个值
                ```js
                    let set = new Set()
                    set.add(5)
                    set.has(5) //返回true
                ```
        
        2-移除元素
            2-1：delete方法可以移除set集合中的某一个元素
                ```js
                    let set = new Set()
                    set.add(5)
                    set.add('5')
                    set.delete(5) 
                    set.has(5)  //返回false，说明5被删除了
                ```
            2-2：clear方法会移除集合中所有的元素
                ```js
                    let set = new Set()
                    set.add(5)
                    set.add('5')
                    set.clear() //调用clear方法删除集合中所有的元素
                ```         

        3-set集合的forEach()方法
            3-1用法：set集合的forEach()方法接受3个参数
                    3-1-1：set集合中下一次索引的位置
                    3-1-2：与第一个参数一样的值
                    3-1-3：被遍历的set集合本身
            3-2数组和set集合的forEach()方法的相同点和不同点
                3-2-1：set集合和数组的forEach()方法的回调函数都接受3个参数，前俩个分别是值和键(对于数组来说就是数值和索引)
                      set集合回调函数前俩个参数的值是一样的，因为set集合没有键名所以set集合的forEach方法的回调函数前俩个参数是一样的
                    ```js
                        let set = new Set([1,2])
                        set.forEach(function(value,key,ownerset){
                            console.log(value === key) //value和key的值是一样的 返回结果true
                            console.log(ownderset === set)  // 回调函数第三个参数是set集合本身，返回结果true
                        }) 
                    ```
                3-2-2：在set集合的forEach()方法中，第二个参数也与数组的一样，如果需要在回调函数中使用this，则可以将它作为第二个参数传入forEach()
                    ```js
                        let set = new Set([1,2])
                        let process = {
                            output(value){
                                console.log(value)
                            },
                            process(dataset){
                                dataset.forEach(function(value){
                                    this.output(value)
                                },this)   //set集合和数组方法forEach()第二个参数this的作用是一样的，
                                            是将this.output的this绑定到process上
                                            可以通过箭头函数直接从外围读取this
                            }
                        }
                    ```

        4-将set集合转化为数组
            4-1：将数组转换为set集合过程很简单，只需要给set构造函数传入数组即可
            4-2：将set集合再转换为数组的过程同样很简单，只需要用展开运算符(...),它可以将数组中的元素分解为各自独立的函数参数
                ```js
                    let set = new Set([1,2,3,3,3,4,5])
                    let arr = [...set]  //返回结果为去过重的数组[1,2,3,4,5]
                ```

        5-WeakSet集合
            5-1为什么要用弱引用WeakSet？
                    因为强引用只要实例中的引用存在，垃圾回收机制就不能释放该对象的内存空间，容易造成内存泄漏
                        ```js
                            let set = new Set()
                            let key = {}
                            set.add(key)
                            key = null
                            console.log([...set][0]) //返回的值为{}   
                                                        这便是强引用的特点：将key值设置为null时
                                                        便清除了对初始对象的引用，但是set集合却保留了这个引用，你任然可以使用展开运算符将set集合转成数组格式从数组中取出该引用
                        ```
            5-2创建WeakSet集合
                用法：weakSet集合支持3个方法：add(),has(),delete()
                5-2-1:weakSet集合和set集合的不同点是：
                        5-2-1-1：weakSet构造函数不接受任何原始值(不接受任何非对象的值)，如果WeakSet集合中包含了其他非对象的值，程序就会报错。
                            ```js
                                let set = new WeakSet()
                                let key = {}
                                set.add(key)
                                key = null
                                set.has(key)//返回结果为false 
                            ```
                        5-2-1-2：俩种set类型之间的最大区别是weakSet保存的是对象值的弱引用(弱引用的含义是当被引用的对象的值为null时，WeakSet对该对象的引用也会消除)
                        5-2-1-3：WeakSet集合不可迭代，所以不能被用于for-of
                        5-2-1-4：WeakSet集合不支持forEach()方法
                        5-2-1-5：WeakSet集合不支持size属性
                        5-2-1-6：WeakSet集合，向has()和delete()方法中传入非对象参数则会返回false

    
    **es6中的map集合
        概念：
            map类型是一种储存着许多键值对的有序列表，其中的键名和对应的值支持所有的数据类型。键名的等价性判断是通过调用Object.is()方法实现的。

        map集合和对象的不同点：
            1.map集合键名不会进行类型转换，而对象的属性名总是会被强制转换成字符串；
            2.无法用对象作为对象的键名，但是在map集合中却可以这么做
                ```js
                    let map = new Map()
                    let key1 = {}
                    let key2 = {}
                    map.set(key1,5)
                    map.set(key1,12)
                    map.get(key1)  //返回的结果为5
                ```
                原因是：因为这些键名不会被强制转换成其他形式，所以这俩个对象在集合中是独立存在的。

        用法：调用set()方法分别传入键名和对应值作为俩个参数
             调用get()方法从集合中获取信息

        1-map集合支持的方法
            map集合跟set几个设计了3个通用的方法：has(),delete(),clear()
        
        2-map集合的初始化
            2-1概念：
                可以向map构造函数传入数组来初始化一个map集合，这点同样与set集合相似，数组中的每个元素都是一个子数组，子数组中包含一个键值对的键名与值俩个元素
                实例：
                    ```js
                        let map = new Map([['name','石惠'],['age',25]])
                        map.get('name') // 返回结果为 石惠
                        map.get('age')  //返回结果为25
                    ```
                问题：数组中包裹数组的模式比较奇怪的解释
                    因为map集合中可以接受任意数据类型键名，为了确保他们在被存储的到map集合中之前不会被强制转换成其他数据类型，因为只能将他们放到数组中，因为这种方式是唯一一种可以准确地呈现键名类型的方式，map集合的forEach()方法也可以证明数组中包裹数组的方式可以被遍历。但是数组中包裹数组的方式能被遍历仅限于map集合

        3-map集合的forEach()方法
            3-1用法：回调函数接受三个参数   forEach()方法接受2个参数 第二个参数this跟set集合用法一样
                     3-1-1map集合中索引的位置(索引对应的值)
                     3-1-2值对应的键名
                     3-1-3map集合本身
                实例：
                    ```js
                        let map = new Map([['name','shihui'],['age',25]])
                        map.forEach(function(value,key,ownermap){
                            console.log(value)  //返回shihui 对应的名称
                            console.log(key)    //返回name  对应的键名
                        })
                    ```
        
        4-weak map集合
            4-1特性：
                4-1-1weak map集合中的键名必须是一个对象，如果使用非对象键名会报错
                4-1-2键名遵从这个原则，键名对应的值如果是一个对象，则保存的是对象的强引用，不会触发垃圾回收机制

            4-2使用weak map集合用法：
                4-2-1：weak map类型是一种存储着许多键值对的无序列表，列表的键名必须是非null类型的对象，键名对应的值则可以是任意类型
                4-2-2：通过set()方法添加数据，通过get()方法获取数据
            
            4-3weak map集合的初始化方法
                4-3-1用法：
                        调用weakmap构造函数传入一个数组，容器内包含其他数组，每个数组由俩个元素构成：第一个元素是一个键名，传入的值必须是非null的对象；第二个元素是这个键对应的值(可以是任意类型)
                    注意点：如果键名为非对象的键则程序会报错
                实例：
                    ```js
                        let key1 = {}
                        let key2 = {}
                        let map = new WeakMap([[key1,'hello'],[key2,'shihui']])
                        console.log(map.get(key1))  //返回结果为hello
                        console.log(map.hsa(key1))  //返回结果为true
                    ```
                
            4-4weak map集合支持的方法
                4-4-1weakmap集合仅支持俩个方法：has(),delete(),weak map和weak set一样俩者都不支持键名枚举
            
            4-5私有对象数据
                概念：应用了weak map集合弱引用特性；当被引用的对象实例被销毁时(实例对象作为weak map的键名)，引用的数据也会被销毁，从而保证信息的私有性(键名被销毁，相应的数据会被垃圾回收机制回收)

            4-5weak map集合的使用方式及使用限制
                不支持通过forEach()方法，size属性，clear()方法来管理集合中的元素      


###迭代器(Iterator)和生成器(Generator)
    **什么是迭代器
        定义：迭代器是一种特殊对象，它具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有一个next()方法，每次调用都返回一个结果对象。结果对象有俩个属性：一个是value,表示下一个将要返回的值；另一个是done，它是一个布尔类型的值，当没有更多可返回的数据时返回true
        实际操作：用es5语法创建一个迭代器
            ```js
                function createIterator(items){
                    var i = 0
                    return {
                        next:function(){
                            var done = (i>=items.length)
                            var value = !done?items[i++]:undefined
                            return {
                                done:done,
                                value:value
                            }
                        }
                    }
                }
                var iterator = createIterator([1,2,3])  //必须要将createIterator()的函数调用赋值给iterator变量，因为每次调用createIterator()都会将函数初始化，i永远从0开始，所以赋值给iterator变量之后，每次调用函数i的值会被保存下来
                iterator.next() //返回 {value:1,done:false}
                iterator.next() //返回 {value:2,done:false}
                iterator.next() //返回 {value:3,done:false}
            ```

    **什么是生成器
        1-概念：生成器是一种返回迭代器的函数，通过function关键字后的星号(*)来表示，函数中会用到新的关键字yield。星号可以紧挨着function，也可以中间添加一个空格
            1-1实例：下面这俩种写法都可以
                ```js
                    function*createIterator(){}
                    function *createIterator(){}
                ```
            1-2实例
                ```js
                    function*createIterator(){
                        yield 1;
                        yield 2;
                        yield 3;
                    }
                    let iterator = createItreator()    //生成器的调用方式和普通函数一样，只不过返回的是迭代器
                    iterator.next().value //返回1
                    iterator.next().value //返回2
                    iterator.next().value //返回3
                ```
            1-3：yield关键字是es6的新特性
            1-4：生成器的特点：
                    1-4-1：生成器函数最有趣的部分大概是，每当执行完一条yield语句后函数就会自动停止
                    1-4-2：使用yield关键字可以返回任何值或表达式
            1-5：生成器函数是es6中的一个重要特征，可以将其用于所有支持函数使用的地方
            1-6：yield的使用限制：
                    1-6-1：yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出语法错误，即便是在生成器内部的函数里使用也是会包语法错误
            
        2-生成器函数表达式
            2-1通过函数表达式来创建生成器，只需要在function关键字和小括号间添加一个星号(*)即可
                实例：
                ```js
                    let createIterator = function *(items){
                        for(let i=0;i<items.length;i++){
                            yield items[i]
                        }
                    }
                    let iterator = createIterator()  //通过生成器创建迭代器
                ``
                    2-1-1解释：在这段代码中，createIterator()是一个生成器函数表达式，而不是一个函数声明，由于函数表达式是匿名的，因此星号直接放在function关键字和小括号之间
            2-2注意点：不能用箭头函数来创建生成器
        
        3-生成器对象的方法
            概念：由于生成器本本身就是函数，因而可以将它们添加到对象中
                例子：可以通过es6方法的简写方式来创建生成器，只需要在函数名前添加一个星号(*)
                        ```js
                            let o = {
                                *createItertor(items){
                                    for(let i=0;i<items.length;i++){
                                        yield items[i]
                                    }
                                }
                            }
                            let iterator = o.createIterator([1,2,3]) 
                        ```
                    
    **可迭代对象和for-of循环
        1-概念(对可迭代对象的定义)：
            可迭代对象具有Symbol.iterator属性，是一种与迭代器密切相关的对象。Symbol.iterator属性通过指定的函数可以返回可返回迭代器。
            在es6中，所有的集合对象(数组，Set集合及Map集合)和字符串都是可迭代对象，这些对象中都有默认的迭代器
        2-注意点：由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象
        3：for-of循环执行机制：
            3-1(一种解释)for-of循环每执行一次都会调用可迭代对象的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中
                
            3-2(另外一种解释深入原理的解释)：for-of循环的代码通过调用values数组的Symbol.iterator方法来获取迭代器，这一过程是在javascript引擎背后完成的。随后迭代器next()方法被多次调用，从其返回的对象value属性读取值并存储起来
                例子：
                    ```js
                        let values = [1,2,3]
                        for(let num of values){
                            console.log(num)  //返回的结果 1，2，3
                        }
                    ```
            3-3：注意点：如果将for-of语句用于不可迭代的对象、null或undefined将会导致程序报错
            3-4：for-of使用场景：
                    如果只需要迭代数组或集合中的值，用for-of代替for循环将是一个不错的选择
        
        4-访问默认迭代器
            4-1概念：可以通过Symbol.iterator来访问对象默认的迭代器
                例子：
                    ```js
                        let values = [1,2,3]
                        let iterator = values[Symbol.iterator]()  //通过对values数组的Symbol.iterator属性访问生成迭代器
                        iterator.next()   //{values:1,done:false}
                        iterator.next()   //{values:2,done:false}
                        iterator.next()   //{values:3,done:false}
                    ```
            4-2：用Symbol.iterator属性来判断对象是否为可迭代对象  解释：
                    由于具有Symbol.iterator属性的对象都有默认的迭代器，因此可以用它来检测对象是否为可迭代对象
                例子：
                    ```js
                        function isIterator(object){
                            return typeof object[Symbel.iterator] === 'function' 
                        }
                    ```
        
        5-创建可迭代对象
            5-1概念：默认情况下开发者定义的对象是不可迭代对象，但如果给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象
                例子：
                ```js
                    let collection = {
                        items:[],
                        *[Symbol.iterator](){
                            for(let item of this.items){
                                yield item;
                            }
                        }
                    }
                    collection.items.push(1);
                    collection.items.push(2);
                    collection.items.push(3);

                    for(let num of collection){ //原理：for-of自动调用collection对象中的Symbol.iterator方法获取迭代器
                        console.log(num)  
                    }
                ```
    
    **内建迭代器
        1-集合对象迭代器
            1-1：概念：es6中有3中类型的集合对象：数组，Map集合与Set集合。为了更好的访问对象中的内容，这3种对象都内建了以下三种迭代器
                1-1-1：entries()返回一个迭代器，其值为对个键值对
                1-1-2：values()返回一个迭代器，其值为集合的值
                1-1-3：keys()返回一个迭代器，其值为集合中的所有键名
            1-2：不集合类型的默认迭代器
                在for-of循环中，数组和set集合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法
            1-3：解构与for-of循环
                for-of循环中使用解构语法可以简化代码
                    例子：
                    ```js
                        let data = new Map()
                        data.set('title','understand es6')
                        for(let [key,value] of data){
                            console.log(key,value)   
                        }
                    ```
        
        2-字符串迭代器
            2-1：在es5中规定可以通过方括号访问字符串中的字符(也就是说text[0],可以获取字符串text的第一个字符)。
                局限性：由于方括号操作的是编码单元而非字符，因此无法正确访问双字节字符
            2-2：在es6中目标是全面支持Unicode，使其操作字符而不是编码单元
        
        3-Nodelist迭代器
            概念：自从es6添加了默认迭代器后，DOM定义中的Nodelist类型也拥有了默认迭代器，其行为与数组的默认迭代器完全一致。所可以将Nodelist应用于for-of循环及其他支持对象迭代器的地方
                例子
                ```js
                    var divs = document.getElementsByTagName('div')   //divs是Nodelist类型节点
                    for (let div of divs){
                        console.log(div.id)
                    }
                ```
    
    **展开运算符与非数组可迭代对象
        1-展开运算符的原理：展开运算符可以操作所有的可迭代对象(只要是可迭代对象都可以用展开运算符)，并根据默认迭代器来选取要引用的值，从迭代器读取所有的值。

    **高级迭代器功能
        1-给迭代器传递参数
            1-1概念：给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值
                例子：
                    ```js
                        function *createIterator(){
                            let first = yield 1;
                            let second = yield first + 2;
                            yield second + 3
                        }
                        let iterator = createIterator()
                        iterator.next()      //{value:1,done:false}
                        iterator.next(4)   //{value:5,done:false}   4会赋值给 yield 1 左边的first 
                        iterator.next(5)    //{value:8,done:false}  5会赋值给 second  
                    ```
                    1-1-1：原理解释(执行逻辑)：第一次调用next()方法时无论传入什么参数都会被丢弃；第二次调用next()方法传入数值4，它最后被赋值给生成器函数内部的变量first，返回6，以此类推，第三次调用next()传入参数5，会给生成器内部的变量second，返回8
                    1-1-2：注意点：这里有一个过程很复杂，在执行左侧代码前，右侧的每一个表达式会先执行再停止
            
        2-在迭代器中抛出错误
            2-1概念：通过throw()方法，在迭代器中抛出错误
            例子：
                ```js
                    function *createIterator(){
                            let first = yield 1;
                            let second = yield first + 2;
                            yield second + 3
                        }
                    let iterator = createIterator()
                        terator.next()   
                        terator.next(4)
                        terator.throw(new Error('抛出错误'))  

                ```
                解释：迭代器通过throw抛出错误的位置，此后的代码都终止执行。
            2-2我们对上面的代码进行更改可以在生成器内部通过try-catch代码块来捕获这些错误，即是抛出错误代码也能正常执行
                例子：
                ```js
                    function *createIterator(){
                            let first = yield 1;
                            let second 
                            try {
                                second = yield first + 2;
                            }catch(ex){
                                second = 6 //如果捕获到错误 second则会被赋值6
                            }
                            
                            yield second + 3
                        }
                    let iterator = createIterator()
                        terator.next()      
                        terator.next(4)
                        terator.throw(new Error('抛出错误')) 
                        terator.next()
                ```

        3-生成器返回语句
            3-1概念：在生成器中，return表示所有操作已经完成，属性done被设置为true；如果同时提供了相应的值，则属性value会被设置为这个值
            例子：
                ```js
                    function *createIterator(){
                        yield 1;
                        return 2
                    }
                    let iterator = createIterator()
                    iterator.next()  //返回{value:1,done:false}
                    iterator.next()  //返回{value:2,done:true}
                ```
            3-2注意点：展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，只要done一变为true就立即停止读取其他的值

        4-委托生成器
            4-1概念：将俩个迭代器合二为一，这是可以创建一个生成器，再给yield语句添加一个星号，就可以将生成数据的过程委托给其他迭代器
            例子：
                ```js
                    function *createNumber(){
                        yield 1;
                        yield 2;
                    }
                    function *createColor(){
                        yield 'red';
                        yield 'green';
                    }
                    function *createCombined(){
                        yield *createNumber();  //yield *createNumber()意思是将会使用createNumber默认迭代器
                        yield *createColor();
                        yield true
                    }
                    let iterator = createCombined()
                    iterator.next() //{value:1,done:false}
                    iterator.next() //{value:2,done:false}
                    iterator.next() //{value:'red',done:false}
                    iterator.next() //{value:'green',done:false}
                    iterator.next() //{value:true,done:false}
                ```
                4-1-1解释：每次调用next()方法就会委托相应的迭代器生成相应的值，直到最后由createNumber和createColor创建的迭代器无法返回更多的值的时候，此时执行最后一条yield语句并返回true
            4-2：for循环不会自动触发next()方法
            4-3：注意点：yield *也可直接应用于字符串，例如：yield *'hello'，此时将使用字符串的默认迭代器

    **异步任务执行
        1-简单任务执行器
        2-向任务执行器传递数据
            2-1概念：给任务执行器传递数据最简单的办法是，把yield返回的值传入下一次next()方法的调用
                例子：
                    ```js
                        function run(taskdef){
                            let task = taskdef()
                            let result = task.next()
                            function step(){
                                if(!result.done){
                                    result = task.next(result.value)
                                    console.log(result)
                                    step()
                                }
                            }
                            step()
                        }
                        run(function*(){
                            let value = yield 1;
                            value = yield value + 3
                        })
                    ```

        3-异步任务执行器



###javascript中的类
    **类的声明
        1-基本的类声明语法
            1-1用法：要声明一个类，首先编写class关键字，紧跟着的是类的名字，其他部分的语法类似于对象字面量方法的简写形式，但不需要在类的各元素之间使用逗号分隔
                ```js
                    class PersonClass {
                        constructor(name){
                            this.name = name
                        }
                        
                        sayName(){}    // 等价于在PersonType.prototype.sayName
                    }
                ```
            1-2：类中自有属性的定义：自有属性是实例中的属性，不会出现在原型上，且只能在类的构造函数或方法中创建(尽可能是在构造函数中创建)
            1-3：类声明的作用：类声明仅仅是基于已有自定义类型声明的语法糖
            1-4：为什么说类的声明是语法糖呢？
                解释：因为typeOf PersonClass 最终返回的结果为function，所以PersonClass声明实际上创建了一个具有构造函数方法行为的函数

        2-为何使用类语法
            2-1：类与自定义类型(函数类型)之间有诸多类似之处，但我们任需要牢记它们的这些差异：
                2-1-1：函数声明可以被提升，而类声明于let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死去
                2-1-2：类声明中的所有代码将自动运行严格模式，而且无法强行让代码脱离严格模式执行
                2-1-3：在自定义类型中，需要通过Object.defineProperty()方法手工指定某个方法不可枚举；而在类中，所有方法都是不可枚举的
                2-1-4：每个类都有一个名为[[Construct]]的内部方法，通过关键字new调用那些不含[[Construct]]的方法会导致程序报错
                2-1-5：使用除关键字new以外的方式调用类的构造函数会导致程序抛出错误
                2-1-6：在类中修改类名会导致程序报错

    **类表达式
        1-类和函数都有俩种形式
            声明形式和表达式形式
            1-1声明形式：
                声明形式的函数和类都由相应的关键字(分别为function和class)进行定义，随后紧跟着标识符
            1-2表达式形式：
                表达式形式的函数和类与之类似，只是不需要在关键字后添加标识符。
        
        2-基本的类表达式语法
            用法实例
            ```js
                let PersonClass = class {
                    constructor(name){
                        this.name = name
                    }
                    sayName(){
                        console.log(this.name)
                    }
                }
                let person = new PersonClass('shihui')
            ```
            2-1:instanceof方法用法：
                用于检测PersonClass构造函数是否是在person实例对象的原型上
            2-2:类声明和类表达式的不同点
                类声明和类表达式的功能极为相似，只是代码编写方式略有差异，二者均不会像函数声明和函数表达式一样被提升，所以在运行时状态下无论选择哪一种代码最终结果都没有太大差别
        
        3-命名类表达式
            3-1概念：我们定义的类表达式是匿名的，其实类与函数一样，都可以定义为命名表达式。在关键字class后添加一个标识符即可定义为命名类表达式
                ```js
                    let PersonClass = class PersonClass2 {
                        constructor(name){
                            this.name = name
                        }
                        sayName(){
                            console.log(this.name)
                        }
                    }
                    typeof PersonClass  // 'function'
                    typeof PersonClass2 // 'undefined'
                            //PersonClass2类型为什么是undefined的解释：看下面代码
                ```
                3-1下面的代码是上面代码的源码：
                ```js
                    let PersonClass = (function(){
                        'use strict'
                        const PersonClass2 = function(name){
                            // 确保通过关键字new调用该函数
                            if(typeof new.target === "undefined"){
                                throw new Error('必须通过关键字new调用构造函数')
                            }
                            this.name = name;
                        }
                        Object.defineProperty(PersonClass2.prototype,"sayName",{
                            value:function(){
                                // 确保不会通过关键字new调用该方法
                                if(typeof new.target !== "undefined"){
                                    throw new Error('不可使用关键字new调用该方法')
                                }
                            },
                            enumerable:false,
                            writable:true,
                            configurable:true
                        })
                        return PersonClass2
                    }())
                ```
                    3-1-1：解释:命名表达式通过const定义名称，从而PersonClass2只能在类的内部使用

    
    **作为一等公明的类
        1：概念：一等公民是指一个可以传入函数(指可以将类作为参数传入函数中)，可以从函数返回，并且可以赋值给变量
        2：类的另外一种使用方式
            定义：通过立即调用类构造函数可以穿件单例
            用法：用new调用类表达式，紧接着通过一对小括号调用这个表达式
            实例：
                ```js
                    let person = new class {
                        constructor(name){
                            this.name = name
                        }
                        sayName(){
                            console.log(this.name)
                        }
                    }('shihui')
                    person.sayname(); //解释：将new和构造函数结合简写了；返回结果为shihui
                ```
    **访问器属性
        1-定义：类支持在原型上定义访问器属性。
        2-用法：创建getter时，需要在关键字get后紧跟一个空格和相应的标识符；创建setter时，只需要把关键字get替换为set即可
        3-实例：
            ```js
                class CustomHTMLElement {
                    constructor(element){
                        this.element = element
                    }
                    get html(){
                        return this.element.innerHTML
                    }
                    set html(value){
                        this.element.innerHTML = value
                    }
                }    
            ```

    **可计算成员属性
        1-概念：类和对象字面量还有更多相似之处，类方法和访问器属性也支持使用可计算名称
        2-用法：
            2-1就像对象字面量一样，用方括号包裹一个表达式即可使用可计算属性名称
                ```js
                    let methodName = "sayName"
                    class Person {
                        constructor(name){
                            this.name = name
                        }
                        [methodName](){
                            console.log(this.name)
                        }
                    }
                ```
            2-2通过相同的方式可以在访问器属性中应用可计算属性
                ```js
                    let propertyName = "html"
                    class CustomHtml {
                        constructor(element){
                            this.element = element
                        }
                        get [propertyName](){
                            return this.element.innerHTML
                        }
                        set [propertyName](value){
                            this.element.innerHTML = value
                        }
                    }
                ```

    **生成器方法
        1-为类定义默认的迭代器
            1-1通过Symbol.iterator定义生成器方法即可为类定义默认的迭代器
            实例：
                ```js
                    class Collection {
                        constructor(){
                            this.items = []
                        }
                        *[Symbol.iterator](){
                            yield *this.items.values()
                        }
                    }
                    let collection = new Collection()
                    collection.items.push(1)
                    collection.items.push(2)
                    collection.items.push(3)
                    for(let x of collection){
                        console.log(x)  //返回结果 1 ，2 ，3
                    }
                ```
    
    **静态成员
        1-概念：创建的方法或者属性不属于实例，因而被称为静态方法或方法
        2-用法：在类中用关键字static定义的方法为静态方法，静态属性也可以这么定义
        3-注意点：
            3-1：不能将static用于定义构造函数
            3-2：不可在实例中访问静态成员，必须要直接在类中访问静态成员
    
    **继承和派生类
        1-概念：
            继承自其他类的类被称作派生类，如果在派生类中指定了构造函数则必须要调用super()，如果不这样做程序就会报错。如果选择不使用构造函数，则当创建新的类实例时会自动调用super()并传入所有参数
            例子：
                ```js
                    class Square extends Rectangle {
                        //没有构造函数   类中没有构造函数则像下面这个例子一样，自动补全
                    }
                    class Square extends Rectangle {
                        constructor(...args){
                            super(...args)
                        }
                    }
                ```
        2-用法：使用extends关键字可以指定类继承的函数。原型会自动调整，通过super()方法派生类即可直接访问基类的构造函数
        3-使用super()注意点：
            3-1：只可在派生类的构造函数中使用super()，如果尝试在非派生类(不使用extends声明的类)或函数中使用则会导致程序抛出错误
            3-2：在构造函数中访问this之前一定要调用super()，它负责初始化this，如果在调用super()之前尝试访问this会导致程序出错
            3-3：如果不想调用super()，则唯一的方法是让类的构造函数返回一个对象
        4-类方法遮蔽
            4-1概念：
                4-1-1派生类中的方法总会覆盖基类中的同名方法
                实例：
                    ```js
                        class Square extends Rectangle {
                            constructor(length){
                                super(length.length)
                            }
                            // 派生类中的getArea()方法，会覆盖Rectangle.prototype.getArea()方法
                            getArea(){
                                return this.length*this.length
                            }
                        }
                    ```
                4-1-2如果想要调用基类中的该方法，则可以调用super.getArea()方法
                实例：
                    ```js
                        class Square extends Rectangle {
                            constructor(length){
                                super(length.length)
                            }
                            // 派生类中的getArea()方法覆盖遮蔽基类中的getArea()方法后，但是还想调用基类中该方法则调用
                            getArea(){
                                return super.getArea()
                            }
                        }
                    ```

        5-静态成员继承
            5-1概念：派生类可以调用基类的静态成员
            实例：
                ```js
                    class father {
                        static sayhello(){
                            console.log('woshishihui')
                        }
                    }
                    class son extends father {
                        constructor(){
                            super()
                        }
                    }
                    son.sayhello()
                ```
        6-派生自表达式的类
            6-1概念：es6最强大的一面或许是从表达式导出类的功能了，只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生(继承);这也是extends强大之处
            实例：
                ```js
                    function Rectangle(length,width){
                        this.length = length;
                        this.width = width
                    }
                    Rectangle.prototype.getArea(){
                        return this.length*this.width
                    }
                    class Square extends Rectangle {
                        constructor(length){
                            super(length,length)
                        }
                    }
                    let x = new Square(3)
                    x.getArea()  //返回9
                    x instanceof Rectangle //返回true 
                ```
                解释：因为father具有[[Construct]]属性和原型，因此son可以继承他

            6-2 extends+也可以跟函数调用
            实例：
                ```js
                    function Rectangle(length,width){
                            this.length = length;
                            this.width = width
                        }
                    Rectangle.prototype.getArea(){
                        return this.length*this.width
                    }
                    function getBase(){
                        return Rectangle
                    }
                    class Square extends getBase() {
                        constructor(length){
                            super(length,length)
                        }
                    }
                ```
            6-3注意点：在extends后可以使用任意表达式，如果使用null或生成器函数会导致错误，类在这些情况下没有[[Construct]]属性，尝试为其创建新的实例会导致程序无法调用[[Construct]]而报错

        7-Symbol.species属性
            7-1定义：Symbol.species属性被用于定义返回函数的静态访问器属性。被返回的函数是一个构造函数，每当要在实例的方法中创建类的实例时必须使用这个构造函数；
            7-2说明：通过实例的方法返回实例背后的原理就是通过Symbol.species属性；
            7-3下面这些内建类型均已定义Symbol.species属性
                7-3-1：Array
                7-3-2：ArrayBuffer
                7-3-3：Map
                7-3-4：Promise
                7-3-5：RegExp
                7-3-6：Set
                7-3-7：Typed arrays
            
            7-4:自定义实现Symbol.species属性的功能
                ```js
                    class Myclass {
                        static get [Symbol.species](){
                            return this
                        }
                        constructor(value){
                            this.value = value
                        }
                        clone(){
                            return new this.constructor[Symbol.species](this.value); 
                        }
                    }
                ```
                解释：this.constructor指的是构造函数   this.constructor[Symbol.species]指的也是构造函数

            7-5：通过Symbol.species属性可以决定派生类返回的实例是哪个
                实例：
                    ```js
                        class Myclass {
                            static get [Symbol.species](){
                                return this
                            }
                            constructor(value){
                                this.value = value
                            }
                            clone(){
                                return new this.constructor[Symbol.species](this.value); 
                            }
                        }
                        class MyDerivedclass1 extends Myclass {

                        }
                        class MyDerivedclass2 extends Myclass {   
                            static get [Symbol.species](){
                                return Myclass
                            }
                        }
                        //在派生类中重新定义Symbol.species属性的返回值，可以覆盖基类中的Symbol.species属性的返回，因此可以通过Symbol.species定义返回实例
                    ```

    **在类的构造函数中使用new.target
        1-概念：在类的构造函数中可以通过new.target来确定类是如何被调用的。new.target等于类的构造函数
        实例：
            ```js
                class Rectangle {
                    constructor(){
                        console.log(new.target === Rectangle) 
                    }
                }
            ```
            1-1解释：当通过new关键字调用new Rectangle()时等价于，new.target就等于构造函数
        2-注意点：因为类必须通过new关键才能调用，所以在类的构造函数中，new.target属性永远不会是undefined


###改进的数组功能
    **创建数组
        1-创建数组的方式有2种：一种是调用Array构造函数，另一种是用数组字面量语法，这俩种方法均需要列举数组中的元素，功能非常受限

        2-es6中增加了Array.of()和Array.from()俩个方法
            2-1：用数组的构造函数创建数组，会有以下这几种可能，传入值的类型不同，会导致一些问题
                2-1-1：构造函数传入一个数值型的值，那么数组的length属性会被设为该值
                2-1-2：传入一个非数值型的值，那么这个值会成为目标数据的唯一项
                2-1-3：传入多个值，此时无论这些值是不是数值型的，都会变成数组的元素
            2-2：Array.of()方法
                2-2-1：概念：Array.of()方法，无论有多少个参数，无论参数是什么类型(解决了用数组构造函数创建数组的缺陷)，Array.of()方法总会创建一个包含所有参数的数组，
                2-2-2：用法：和数组的构造函数用法一样，在Array.of()中传入参数即可
                2-2-3：对比：Array.of()在大多数时候和数组字面量方法相似，所以在大多数时候可以用数组字面量来创建原生数组
                2-2-4：注意点：Array.of()方法不通过Symbol.species属性确定返回值类型，它使用当前构造函数(也就是of()方法中的this值)来确定正确的返回数据的类型
            2-3：Array.from()方法
                2-3-1：概念：Array.from()方法将对象转化为数组
                2-3-2：用法：
                        2-3-2-1：Array.from()方法可以接受可迭代对象或类数组对象作为第一参数，最终返回一个数组
                                ```js
                                    function dosomething(){
                                        let args = Array.from(arguments)
                                    }
                                ```
                        2-3-2-2：Array.from()方法也是通过this确定返回数组的类型的
                        2-3-2-3：映射转换
                                    可以提供一个映射函数作为Array.from()的第二个参数
                                ```js
                                    function translate(){
                                        return Array.from(arguments,(value)=>value+1)
                                    }
                                    let number = translate(1,2,3)
                                    // number返回结果为2，3，4
                                ```
                        2-3-2-4:可以给Array.from()方法传入第三个参数来表示映射函数的this值
                                ```js
                                    let helper = {
                                        diff:1,
                                        add(value){
                                            return value + this.diff
                                        }
                                    }
                                    function translate(){
                                        return Array.from(argument,helper.add,helper)  //第三个参数指定this的指向
                                    }
                                    let number = translate(1,2,3)
                                    // number返回结果为2，3，4
                                ```
                        2-3-2-5：用Array.from()转换可迭代对象
                                    概念：Array.from()方法可以处理类数组对象和可迭代对象，也就是说该方法能够将所有含有Symbol.iterator属性的对象转换为数组
                                    实例：
                                    ```js
                                        let number = {
                                            *[Symbol.iterator](){
                                                yield 1;
                                                yield 2;
                                                yield 3;
                                            }
                                        }
                                        let number2 = Array.from(numbers,(value)=>value+1)
                                        // number2返回结果为 2，3，4
                                    ```
                        2-3-2-6：注意点：如果一个对象既是类数组又是可迭代的，那么Array.from()方法会根据迭代器来决定转换哪个值
    
    **为所有数组添加的新方法
        1-find()方法和findIndex()方法
            1-1：这俩种方法的用法：
                概念：都接受俩个参数：一个是回调函数；另一个是可选参数，用于指定回调函数中的this的值。执行回调函数时，传入的参数分别为：数组中的某个元素和该元素在数组中的索引及数组本身；(传入的参数和map()，forEach()方法参数是一样的)。如果给定的值满足定义的标准，回调函数应返回true，一旦回调函数返回true，find()和findIndex()方法都会立即停止搜索数组剩余部分
            1-2：find()和findIndex()俩个方法的唯一区别是：find()方法返回的查找的值，findIndex()方法返回查找到的值的索引
                实例：
                ```js
                    let number = [1,2,33,4,5,6]
                    console.log(number.find(value=>value>3))  //返回33 返回值
                    console.log(number.findIndex(value=>value>3))  //返回2  返回值对应的索引
                ```
        2-find(),findIndex(),indexOf(),lastIndexOf()这四种方法的使用场景
            2-1：根据某个条件查找匹配的元素，使用find(),findIndex()方法可以更好的完成任务
            2-2：指向查找与某个值匹配的元素，则indexOf(),lastIndexOf()方法是更好的选择
        
        3-fill()方法
            3-1概念：fill()方法可以用指定的值填充一至多个数组元素。
            3-2用法：
                3-2-1fill(value,start,end),三个参数：value表示要填充的值；start：可选，开始填充的位置；end：可选，默认为数组长度，停止填充的位置
                3-2-2当传入一个值时，fill()方法会用这个值重写数组中的所有值
                    ``` js
                        let numbers = [1,2,3,4]
                        numbers.fill(1)
                        // numbers返回值为[1,1,1,1]
                    ```
                3-2-3传入开始索引和不包含结束索引这两个参数
                    ```js
                        let numbers = [1,2,3,4]
                        numbers.fill(1,2)  //numbers返回结果为[1,2,1,1]
                        numbers.fill(0,1,3)  //numbers返回结果为[1,0,0,1]
                    ```
        4-copyWithin()方法
            概念：copyWithin()方法和fill()方法相似，其也可以改变数组中多个元素，copyWithin()方法是从数组中复制元素的值
            用法：copyWithin()方法传入3个参数：copyWithin(target,start,end) target:值为索引值，表示从索引值位置开始粘贴；start：开始复制值的索引位置；end：结束复制值的索引位置(不包含)
            实例：
                ```js
                    let numbers = [1,2,3,4,5,6]
                    console.log(numbers.copyWithin(2,0,2))  //返回结果为[1,2,1,2,5,6]
                ```


###Promise与异步编程
    **异步编程的背景知识
        1-js引擎基于单线程事件循环的执行机制
            概念：跟踪即将运行的代码，那些代码被放在一个任务队列中，每当一段代码准备执行时，都会被添加到任务队列。每当JavaScript引擎中的一段代码结束执行，事件循环会执行队列中的下一个任务
        
        2-事件模型
            2-1：事件模型底层原理：
                    用户点击按钮或按下键盘上的按键会触发类似的onclick这样的事件，它会向任务队列添加一个新任务来响应用户的操作，这是js中最基础的异步编程形式，直到事件触发时才执行事件处理程序
        
        3-回调函数
            3-1：回调函数的概念：
                    nodejs通过普及回调函数来改进异步编程模型，回调模式与事件模型类似，异步代码都会在未来的某个时间点执行，二者的区别是回调模式中被调用的函数是作为参数传入的
            3-2：实例+解释回调函数的执行机制
                ```js
                    readFile('example.txt',function(err,contents){
                        if(err){
                            throw err;
                        }
                        writeFile('example.txt',function(err){
                            if(err){
                                throw err;
                            }
                        })
                    })
                ```
                    执行机制说明：当readFile()函数执行完成之后，会向任务队列中添加一个任务，如果没有错误产生，则执行writeFile()函数，然后当writeFile()函数执行结束后也会向任务队列中添加一个任务
     
    
    **Promise的基础知识
        1-Promise的优点：
            1-1：并行执行俩个异步操作，当两个操作都结束时通知你；(这是回调函数和时间模型很难做到的)
        2-概念：Promise相当于异步操作结果的占位符，它不会去订阅一个事件，也不会传递一个回调函数给目标函数，而是让函数返回一个Promise

        3-Promise的生命周期
            3-1：每个Promise都会经历一个短暂的生命周期：先是处于进行中(pending)的状态，此时操作尚未完成，所以它也是未处理的；一旦异步操作执行结束，Promise则变为已处理的状态；
            3-2：promise操作结束后可能会进入到以下两个状态中的一个
                3-2-1：Fulfilled  Promise异步操作成功完成
                3-2-2：Rejected  由于程序错误或一些其他原因，Promise异步操作未能完成
            
            3-3：Promise内部属性[[PromiseState]]
                3-3-1:概念：
                    内部睡属性[[PromiseState]]被用来表示promise3种状态：'pending','fulfilled','rejected'。这个属性不暴露在Promise对象上，所以不能以编程的方式检测Promise的状态，只有当Promise的状态改变时，通过then()方法来采取特定的行动

            3-4：用法：
                所有Promise都有then()方法，它接受两个参数：第一个是当Promise的状态变为fulfilled时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数；第二个是当Promise的状态变为rejected时要调用的函数，其与完成时调用的函数类似，所有与失败状态相关的附加数据都会传递给这个拒绝函数

                3-4-1：注意点：如果一个对象实现了上述的then()方法，那这个对象我们称之为thenable对象。所有的Promise都是thenable对象，但并非所有的thenable对象都是Promise

            3-5：Promies的catch方法用法
                Promise有一个catch()方法，相当于只给其传入拒绝处理程序的then()方法。
                例如，下面这个catch()方法和then()方法实现的功能是等价的
                    ```js
                        Promise.catch(function(err){
                            console.error(err.message)
                        })
                        // 上面的catch()方法调用与以下方法调用相同
                        Promise.then(null,function(err){
                            console.error(err.message)
                        })
                    ```

            3-6:如果一个Promise处于已处理状态，在这之后添加到任务队列中的处理程序将执行
                实例：
                    ```js
                        // 最初完成的处理程序
                        promise.then(function(content){
                            console.log(content)
                            // 现在又添加一个
                            promise.then(function(contents){
                                console.log(contents)
                            })
                        })
                    ```
                    解释：一个完成处理程序被调用时向同一个Promise添加了另一个完成的处理程序，此时这个Promise已经完成，所以新的处理程序会被添加到任务队列中，当前面的任务完成后其才被调用。这对拒绝处理程序也同样适用


        4-创建未完成的Promise
            4-1：用法：用Promise构造函数可以创建新的Promise，构造函数只接受一个参数：包含初始化Promise代码的执行器(executor)函数。执行器接受两个参数，分别是resolve()函数和reject()函数。执行器成功完成时调用resolve()函数，反之，失败时调动reject()函数。

                实例：
                ```js
                    let fs = require('fs')
                    function readFile(filename){
                        return new Promise(function(resolve,reject){
                            // 触发异步操作
                            fs.readFile(filename,{encoding:'utf8'},function(err,content){
                                // 触发异步操作
                                if(err){
                                    reject(err)
                                    return;
                                }
                                // 成功读取文件
                                resolve(contents)
                            })
                        })
                    }
                    let promise = readFile('example.txt')

                    // 同时监听执行完成和执行被拒
                    promise.then(function(contents){
                        // 完成
                        console.log(contents)
                    }).catch(err=>{
                        // 拒绝
                        console.log(err.message)
                    })
                ```
                    实例代码执行机制：用Promise包裹了一个原生的Nodejs的fs.readFile()异步调用，如果失败，执行器向reject()函数传递错误对象；如果成功，执行器向resolve()函数传递文件内容
            
            4-2：Promise的工作原理
            
                4-2-1：promise的执行器会立即执行，然后才执行后续中的代码
                    事例：
                        ```js
                            let promise = new Promise(function(resolve,reject){
                                console.log('promise')
                                resolve()
                            })
                            console.log('Hi')
                            // 返回结果
                            // promise
                            // Hi
                        ```

                4-2-2：调用resolve()后会触发一个异步操作，传入then()和catch()方法的函数会被添加到任务队列中并异步执行
                    事例：
                        ```js
                            let promise = new Promise(function(resolve,reject){
                                console.log('promise')
                                resolve()
                            })
                            promise.then(function(){
                                console.log('resolved')
                            })
                            console.log("Hi")
                            // 返回结果
                            // promise
                            // Hi
                            // resolved
                        ```
                            事例解释：即使在代码中then()调用位于console.log('Hi')之前，但其与执行器不同，他并没有立即执行。这是因为，完成处理程序和拒绝处理程序总是在执行器完成后被添加到任务队列的末尾

        5-创建已处理的Promise
            5-1：promise表示已知值，有以下两种方法

                5-1-1：使用Promise.resolve()
                    用法：promise.resolve()方法只接受一个参数并返回一个完成状态的Promise
                        ```js
                            let promise = Promise.resolve(42)
                            promise.then(function(value){
                                console.log(value) //返回42
                            })
                        ```
                        说明：该Promise永远不会存在拒绝状态，因而该Promise的拒绝处理程序永不会被调用

                5-1-2：使用Promise.reject()
                    用法：通过Promise.reject()方法来创建已拒绝的Promise
                        ```js
                            let promise = Promise.reject(42)
                            promise.catch(function(value){
                                console.log(value) //返回42
                            })
                        ```
                        说明：该Promise永远不会存在完成状态，因而该Promise的完成处理程序永不会被调用

                5-1-3：注意点：
                        如果向Promise.resolve()方法或Promise.reject()方法传入一个Promise,那么这个Promise会被直接返回
            
            5-2：非Promise的thenable对象
                5-2-1：用法：
                    Promise.resolve()和Promise.reject()方法都可以接受非Promise的Thenable对象作为参数。如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise，并在then()函数中调用

                5-2-2：概念：
                    拥有then()方法并且接受resolve和reject这俩个参数的普通对象就是非Promise的Thenable对象
                    例如：
                    ```js
                        let thenable = {
                            then:function(resolve,reject){
                                resolve(42)
                            }
                        }
                    ```

                5-2-3：Thenable对象和Promise之间只有then()方法这一个相似之处，可以调用Promise.resolve()方法将Thenable对象转换成一个已完成的Promise，
                    事例
                    ```js
                        let thenable = {
                            then:function(resolve,reject){
                                resolve(42)
                            }
                        }
                        let p1 = Promise.resolve(thenable)
                        p1.then(function(value){
                            console.log(value)  //返回42
                        })
                    ```
                    说明：此实例中，Promise.resolve()调用的是thenable.then()，所以Promise的状态可以被检测到
                
                5-2-4：使用与Promise.resolve()相同的过程创建基于Thenable对象的与拒绝Promise
                    事例：
                        ```js
                        let thenable = {
                            then:function(resolve,reject){
                                reject(42)
                            }
                        }
                        let p1 = Promise.resolve(thenable)
                        p1.catch(function(value){
                            console.log(value)  //返回42
                        })
                        ```
                        解释：执行机制：执行thenable.then()时会用值42创建一个已拒绝状态的Promise，这个值随后会被传入p1的拒绝处理程序
            
        
        6-执行器错误
            6-1：如果执行器内部抛出一个错误，则Promise的拒绝处理程序就会被调用
                事例：
                    ```js
                        let promise  = new Promise(function(resolve,reject){
                            throw new Error('抛出错误')
                        })
                        promise.catch(function(error){
                            console.log(error) // 返回抛出错误
                        })
                    ```

            6-2:原理：执行器抛出错误，每个执行器中都隐含一个try-catch块，所以错误会被捕获并传入拒绝处理程序
                事例：
                    ```js
                        let promise  = new Promise(function(resolve,reject){
                            try{
                                throw new Error('抛出错误')
                            }catch(ex){
                                resolve(ex)
                            }
                            
                        })
                        
                        promise.catch(function(error){
                            console.log(error) // 返回抛出错误
                        })
                    ```

    **全局的Promise拒绝处理
        1-Nodejs环境的拒绝处理
            1-1处理Promise拒绝时会触发process对象上的两个事件
                unhandledRejection:在一个事件循环中，当promise被拒绝，并且没有提供拒绝处理程序时，触发该事件
                rejectionHandled:在一个事件循环之后，当promise被拒绝时，若拒绝处理程序被调用，触发该事件
    

    **串联Promise
        1-串联Promise的执行机制：
            每次调用then()方法或catch()方法时实际上创建并返回了另一个Promise，只有 当第一个Promise完成或被拒之后，第二个才会被解决
            事例：
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        resolve(42)
                    })
                    p1.then(function(value){
                        console.log(value)
                    }).then(function(){
                        console.log('finished')
                    })
                ```
                    解释：调用p1.then()返回第二个promise，紧接着又调用它的then()方法，只有当第一个promise被解决之后才会调用第二个then()方法的完成处理程序。

                    上面代码的分步骤事例：
                        ```js
                            let p1 = new Promise(function(resolve,reject){
                                resolve(42)
                            })
                            let p2 = p1.then(function(value){
                                console.log(value)
                            })
                            p2.then(function(){
                                console.log('finished')
                            })
                        ```
        
        2-捕获错误
            2-1概念：在完成处理程序或拒绝处理程序中可能发生错误，而promise链可以用来捕获这些错误
                事例：
                    ```js
                        let p1 = new Promise(function(resolve,reject){
                            resolve(42)
                        })
                        p1.then(function(value){
                            throw new Error('Boom')
                        }).catch(function(error){
                            console.log(error.message)  //返回结果 'Boom'
                        })
                    ```
                    解释执行机制：在这段代码中，P1的完成处理程序抛出一个错误，链式调用第二个Promise的catch()方法后，可以通过它的拒绝处理程序接受这个这个错误

            2-2：决绝处理程序抛出错误，也可以通过相同的方式接收到这个错误
                实例：
                    ```js
                        let p1 = new Promise(function(resolve,reject){
                            throw new Error('explosion')
                        })
                        p1.catch(function(error){
                            console.log(error.message)  //返回 explosion
                            throw new Error('Boom')
                        }).catch(function(error){
                            console.log(error.message)  //返回结果 'Boom'
                        })
                    ```
                    解释执行机制：此处的执行器抛出错误并处触发Promise p1的拒绝处理程序，这个处理程序又抛出另外一个错误，并且被第二个Promise的拒绝处理程序捕获。链式Promise调用可以感知到链中其他Promise的错误
            
            2-3：注意点：务必在Promise链的末尾留有一个拒绝处理程序以确保能够正确处理所有可能发生的错误

    
        3-Promise链的返回值

            3-1：概念：Promise链的另一个重要特性是可以给下游Promise传递数据，从执行器resolve()处理程序到Promise完成处理程序的数据传递过程，如果在完成处理程序中指定一个返回值，则可以沿着这条链继续传递数据
            实例：
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        resolve(42)
                    })
                    p1.then(function(value){
                        console.log(value)  //返回42
                        return value + 1
                    }).then(function(value){
                        console.log(value)  //返回 43
                    })
                ```
                    解释执行机制：执行器传入的value为42，p1的完成处理程序执行后返回value+1也就是43.这个值随后被传递给第二个Promise的完成处理程序并输出到控制台

            
            3-2：拒绝处理程序中也可以做相同的事情，当它被调用时可以返回一个值，然后用这个值完成链条中后续的Promise
                实例：
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        reject(42)
                    })
                    p1.catch(function(value){
                        console.log(value)  //返回42
                        return value + 1
                    }).then(function(value){
                        console.log(value)  //返回 43
                    })
                ```
                    解释执行机制：执行器调用reject()放方法向Promise的拒绝处理程序传入值42，最终返回value+1。拒绝处理程序中返回的值仍可用在下一个Promise的完成处理程序中
                    
        4-在Promise链中返回Promise
            4-1：Promise可以通过完成和拒绝处理程序返回Promise对象
                事例：
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        resolve(42)
                    })
                    let p2 = new Promise(function(resolve,reject){
                        resolve(43)
                    })
                    p1.then(function(value){
                        // 第一个完成处理程序
                        console.log(value)  //返回42
                        return p2
                    }).then(function(value){
                        // 第二个完成处理程序
                        console.log(value)  //返回43
                    })
                ```
                    解释执行机制：p1编排的任务解决并传入42，然后p1的完成处理程序返回一个已解决状态的Promise p2，由于P2已经被完成，因此第二个完成处理程序被调用；如果p2被拒绝，则调用拒绝处理程序

                        4-1-1：已下代码等价于上面事例
                    ```js
                        let p1 = new Promise(function(resolve,reject){
                            resolve(42)
                        })
                        let p2 = new Promise(function(resolve,reject){
                            resolve(43)
                        })
                        let p3 = p1.then(value=>{
                            // 第一个完成处理程序
                            console.log(value) //返回42
                            return p2
                        })
                        p3.then(value=>{
                            // 第二个完成处理程序
                            console.log(value)  //返回43
                        })
                    ```
                        解释执行机制：此处第二个完成处理程序被添加到p3而非p2，这个差异虽然小但非常重要
            
            4-2：在完成处理或拒绝处理程序中返回thenable对象不会改变Promise执行器的执行实际，先定义的Promise的执行器先执行，后定义的后执行，以此类推。返回thenable对象仅允许你为这些Promise结果定义额外的响应。在完成处理程序中创建新的Promise可以推迟程序的执行
                事例：
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        resolve(42)
                    })
                    p1.then(function(value){
                        console.log(value)  //返回42
                        // 创建一个新的promise
                        let p2 = new Promise(function(resolve,reject){
                            resolve(43)
                        })
                        return p2
                    }).then(function(value){
                        console.log(value)  //返回43
                    })
                ```
                    事例解释：在p1的完成处理程序里创建一个新的Promise，直到p2被完成才会执行第二个完成处理程序。
    

    **响应多个Promise
        1：概念：监听多个Promise来决定下一步的操作，使用Promise.all()和Promise.race()两个方法来监听多个Promise

        2：Promise.all()方法
            2-1：用法：Promise.all()方法只接受并返回一个Promise，该参数是一个含有多个受监视Promise的可迭代对象(例如：一个数组)

            2-2：只有当可迭代对象中所有的Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成
            事例：
            ```js
                let p1 = new Promise(function(resolve,reject){
                    resolve(42)
                })
                let p2 = new Promise(function(resolve,reject){
                    resolve(43)
                })
                let p3 = new Promise(function(resolve,reject){
                    resolve(44)
                }

                let p4 = Promise.all([p1,p2,p3])
                p4.then(function(value){
                    console.log(value[0]) //返回42
                    console.log(value[0]) //返回43
                    console.log(value[0]) //返回44
                })
                // Promise.all()处理的值和传入的promise一一对应
            ```
                事例执行机制：每个Promise解决时都传入一个数字，调用Promise.all()方法创建Promise p4，最终当Promise p1,p2和p3都处于完成状态后p4才被完成。传入p4完成处理程序的结果是一个包含每个解决值(42,43,44)的数组，这些值按照传入参数数组中的Promise的顺序存储，所以可以根据每个结果来匹配对应的Promise

            2-3：所有传入的Promise.all()方法的Promise只要有一个被拒绝，那么返回的Promise没等所有Promise都完成就立即被拒绝
            事例：
            ```js
                let p1 = new Promise(function(resolve,reject){
                    resolve(42)
                })
                let p2 = new Promise(function(resolve,reject){
                    reject(43)
                })
                let p3 = new Promise(function(resolve,reject){
                    resolve(44)
                }

                let p4 = Promise.all([p1,p2,p3])
                p4.catch(function(value){
                    console.log(value) //返回43
                })
            ```
                事例解释：p2被拒绝并传入值43，没等p1或p3结束执行，p4的拒绝处理程序就立即被调用。拒绝处理程序总是接受一个值而非数组，该值来自被拒绝Promise的拒绝值


        3-Promise.race()方法
            3-1：用法：Promise.race()方法监听多个Promise的方法稍有不同：它也接受含多个受监视Promise的可迭代对象作为唯一参数并返回Promise。但只要有一个Promise被解决返回的Promise就被解决，无需等到所有promise都被完成

                事例：
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        resolve(42)
                    })
                    let p2 = new Promise(function(resolve,reject){
                        resolve(43)
                    })
                    let p3 = new Promise(function(resolve,reject){
                        resolve(44)
                    }

                    let p4 = Promise.race([p1,p2,p3])
                    p4.then(function(value){
                        console.log(value) //返回42
                    })
                ```
                事例原理：传给Promise.race()方法的Promise会进行竞选，以决出哪一个先被解决，若果先解决的是已完成Promise，则返回已完成Promise；如果先解决的是已拒绝的Promise，则返回已拒绝的Promise
            
            3-2：如果先解决的是已拒绝的Promise，则返回已拒绝的Promise

                事例
                ```js
                    let p1 = new Promise(function(resolve,reject){
                        setTimeout(function{resolve(42)},0)
                    })
                    let p2 = Promise.reject(43)
                    let p3 = new Promise(function(resolve,reject){
                        resolve(44)
                    }
                    let p4 = Promise.race([p1,p2,p3])
                    p4.catch(value=>{
                        console.log(value) //43
                    })
                ```
                    拒绝执行机制解释：由于p2已处于被拒绝状态，因而当Promise.race()方法被调用时p4也被拒绝了，尽管p1和p3最终被完成，但由于是发生在p2被拒后，因此它们的结果被忽略掉
    

    **Promise继承
        1：概念：Promise与其他内建类型一样，也可以作为基类派生其他类，所以你可以定义自己的promise变量来扩展内建Promise的功能。
            事例：创建一个既支持then()方法和catch()方法又支持success()方法和failure()方法的Promise
            ```js
                class MyPromise extends Promise {
                    success(){
                        return this.then(resolve,reject)
                    }
                    failure(){
                        return this.catch(reject)
                    }
                }
                let promise = new MyPromise(function(resolve,reject){
                    resolve(42)
                })
                promise.success(value=>{
                    console.log(value)  //返回42
                }).catch(value=>{
                    console.log(value) 
                })
            ```
        
            1-1：静态方法会被继承，因此派生的Promise也拥有MyPromise.resolve()，MyPromise.reject(),MyPromise.race(),MyPromise.all(),后二者与内建方法完全一致，而前二者稍有不同
                1-1-1：解释MyPromise.resolve()和MyPromise.reject()与基类的Promise.resolve(),Promise.reject()的不同：
                    由于MyPromise.resolve()和MyPromise.reject()方法通过Symbol.species属性来决定返回的Promise的类型，故调用者两个方法时无论传入什么值都会返回一个MyPromise实例
    
    **基于Promise的异步任务执行
        1:概念：Promise和生成器的结合

        2：async标记的函数代替生成器，用await代替yield来调用函数(await关键字返回一个Promise);添加关键字async表示该函数以异步模式运行



###代理(Proxy)和反射(Reflection)API
    1：定义：
        代理是一种可以连接并改变底层js引擎操作的包装器，在新语言中通过它暴露内部运作对象
    
    **数组问题
        

    

        
            
            










        

        


            





        






            
            
            
        
        

            






    





