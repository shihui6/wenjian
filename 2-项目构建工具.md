***gulp基本的api
    gulp.task -- 定义任务
    gulp.src -- 找到需要执行任务的文件
    gulp.dest -- 执行任务的文件的出口
    gulp.watch -- 观察文件是否发生变化

***项目构建
    1-要创建package.json文件(作用：项目要安装依赖包就是npm包的时候必须要有package.json文件)，这个文件可以手动创建也可以自动创建，这里就自动创建使用npm init  初始化生成package.json文件  后面可以一直回车 
    2-生成package.json就可以用npm命令安装我们所需要的依赖包了
    3-创建一个设置babel编译工具的配置文件 .babelrc
    4-创建gulpfile.babel.js
        gulp官网都是创建的gulpfile.js 为什么这里创建gulpfile.babel.js名呢？    原因：即将要写的构建脚本都是写的es6语法，如果说不加babel.js的话在执行gulp脚本的时候会报错，所以这个名称也是固定的就是gulpfile.babel.js


1-引入gulp包 import gulp from 'gulp' 因为所有的构建都是在gulp包之上的
2-引入gulp-if 是用gulp语句中做if判断的 import gulpif from 'gulp-if'
3-在gulp处理文件拼接的 gulp-concat import concat from 'gulp-concat'
4-对整个的打包是用webpack来做的 import webpack from 'webpack'
5-我们知道gulp处理的都是些文件流他是基于stream，对于webpack的处理是结合webpack-stream  import gulpwebpack from 'webpack-stream'
6-对文件重命名做标志的包 import named from 'vinyl-named' 
7-需要热更新包  import livereload from 'gulp-livereload'
8-用来处理文件信息流的包 import plumber from 'gulp-plumber'
9-对文件重命名的包 import rename from 'gulp-rename'
10-处理js和css压缩的包 import uglify from 'gulp-uglify'
11-在命令行工具输出的包 import {log,colors} from 'gulp-util'
12对命令行参数解析的包(自己之前写过的)  import args from './util/args'




***创建gulp脚本编译的任务

```js
    // 第一种情况
    gulp.task('scripts',()=>{   task是gulp的api代表创建一个任务，任务的名称为scripts
        return gulp.src(['app/js/index.js'])  这是任务要做的内容 这里的src也是gulp提供的api 打开index.js这个目录，然后打开这个文件之后要做什么呢？首先要处理常规的错误逻辑，我们处理文件都需要一个很长的流程，为了避免在某个环节报错，我们需要集中处理这个错误，所以我们需要改变默认处理错误的机制，接下类就是用plumber来处理
        .pipe(plumber({
            errorHandle:function(){

            }
        }))
    })
```
```js
    // 第二中情况对同一个文件进行连续处理
    var gulp = require('gulp')
    var concat = require('gulp-concat') 引入插件gulp-contact使用concat
    gulp.task('restConcat',function(){
        gulp.src('src/js*.js')      所需要改变文件的路径，这里是改变所有的js,把js整合在一起
             .pipe(concat('all.js')) 
            //  知识点：pipe()的作用
            // pipe()是写你通过什么方法来处理src()中的文件，可以多个pipe调多个方法 pipe()就是执行的方法的添加
             .pipe(gulp.dest('dist/js'))
    })
```


###执行gulp命令时，程序执行的机制
1-先找到gulpfile.babel.js文件执行里面的脚本  requireDir('./tasks') 如果有这行代码代表到tasks文件夹下面的响应的js文件执行命令
    如果执行 gulp 会找到tasks里面的default.js文件执行命令
    如果执行 gulp script 会找到tasks里面的script.js文件执行命令
2-通过build.js将相关的命令串到一起gulp.task('build',gulpSequence('clean','css','pages','scripts',['browser','serve'])); 这段意思是依次执行clean，css，pages，scripts，browser,serve










***webpack构建工具
    前端的价值体现：体现在一下四点，可以不要把太多的时间花在提高业务能力，重点还是要放在搭建方面，前端搭建能力的提升有利于自身竞争力的提升，毕竟业务能力还是比较简单的，
        1-搭建前端工程      
        2-网络优化
        3-API定制
        4-nodejs层

***项目配置
    1.npm init 初始化项目 生成package.json，根据package.json就可以下载我们的包
    2.npm i webpack 下载webpack打包工具 按照下载完之后的提醒下载依赖项 (webpack的作用：处理依赖关系打包的将大量的资源打包成少量的资源，并且在打包过程当中还可以进行处理，将less转成css，把sass转成css，es6转成es5等等都可以做)
    3.新建文件夹src，在src文件夹里面新建index.html和，main.js
    4.进行webpack的配置，所以新建webpack.config.js配置文件，下面操作是在webpack.config.js里面进行配置
```js
       const path = require('path') 
       module.exports = {
           entry:path.join(__dirname,'src','main.js')  设置的入口文件，用webpack进行打包的时候会根据src里面的main.js进行打包处理
           output:{   设置的出口文件，原来项目目录里面没有dist文件夹，用webpack打包的时候会自动生成dist目录,然后会在dist目录下面的生成bundle.js,打包完成的代码都放在这个js文件里面
               path:path.join(__dirname,'dist'),
               filename:'bundle.js'
           }
       }
```
    5.创建css文件夹，此时就要对css进行打包，首先要将css文件模块导入到入口文件中,然后还需要进行css加载器的配置
```js
        在main.js入口文件中进行css导入
        import './index.css'

        module.exports = {
            module:{        配置加载规则的容器
                rules:[
                    {
                        test:/\.css$/,
                        use:["style-loader","css-loader"]
                    }
                ]
            }
        }

```
    6.打包完成之后会有一个"mode"警告指，配置文件里面的mode选项没有设置，webpack会自动以production来进行webpack的工作模式的设置，当然现在是处于开发阶段，所以现在要将mode设置为开发阶段(development)
```js
    module.export = {
        mode:'development' 在webpack配置的开始规定打包模式
    }
```
    7.创建less文件夹，此时就要对less进行打包，首先要将less文件模块导入到入口文件中,然后还需要进行less加载器的配置
```js
在main.js入口文件中进行less导入
    import './index.less'
     module.exports = {
            module:{        配置加载规则的容器
                rules:[
                    {
                        test:/\.less$/,
                        use:["style-loader","css-loader","less-loader"]
                    }
                ]
            }
        }
```
    8.对图片进行打包处理，在css文件里面background引入图片，需要在webpack.config.js里面进行图片的配置
```js
     module.exports = {    
            module:{        配置加载规则的容器
                rules:[     这样进行图片打包默认的会将图片转成bass64格式的字符串存到js当中来，问题是图片转成bass64格式之后文件的大小会比原来增大将近三分之一的体积，如果图片过大的话不是和用这样的打包方式，接下来对于图片比较大的(避免这样的打包方式)
                1-给他配置，限制当图片大小超过某个值的时候，这个图片就不通过bass64打包，而是直接将图片存到dist目录里面
                2-执行npm run build的时候会提示需要下载 file-loader 因为：带有限制转成文件存在的话需要下载file-loader，因为依赖file-loader
                    {
                        test:/\.(jpg)|(png)|(gif)|(jpeg)|(bmp)|(svg)$/,
                        use:[{
                            loader:"url-loader",
                            options:{
                                limit:100      这样配置就可以起到当图片大小大于100的时候，就不通过bass64打包，直接将图片进行保存
                            }
                        }]
                    }
                ]
            }
        }

```
    9.
        1-对字体进行打包，首先需要下载npm install bootstrap@3.1.1 - D 
        2-在main.js里面对bootstrap进行引用 import 
```js
     module.exports = {
            module:{        配置加载规则的容器
                rules:[
                    {
                        test:/\.(woff)|(eot)|(ttf)|(woff2)|(eot2)|(otf)$/,
                        use:["file-loader"]
                    }
                ]
            }
        }
```
    10.
        1-es6转换成es5代码的配置，需要先下载babel-loader - D  (babel的作用:依据转码规则对js代码进行转换操作，所以使用babel需要有转码规则否则babel完全不知道怎么工作，下载babel-preset-env转码规则，下载完之后需要在.babelrc里面进行配置 {"presets":["env"]}) 
```js
{
    "presets":[
        ["env",{
            "targets":{  target指的是目标平台就是代码，就是env最终把代码转换过来要在哪个平台上面运行
                "browsers":[">0.25%","not ie 11"]   这里指定是在broswer平台
            }
        }
        ]
    ]
}
``` 

        2-然后在webpack.config.js 里对babel进行配置如下
        3-执行npm run build时会报错，要求下载babel-core

```js
     module.exports = {
            module:{        配置加载规则的容器
                rules:[
                    {
                        test:/\.js$/,
                        use:["babel-loader"]
                    }
                ]
            }
        }
```
    11. 1-还可以引入一些插件实现某些功能，如使用插件实现自动将index.html添加到dist目录里面
        2-下载html-webpack-plugin
        3-然后在webpack.config.js里面引进来进行配置如下操作
```js
    const HtmlWebpackPlugin = require("html-webpack-plugin")
    module.exports = {
        plugins:[
            new HtmlWebpackPlugin({
                template:path.join(__dirname,'src','index.html')  代表将src目录下的index.html作为模板文件，webpack在打包的时候会自动把index.html复制到dist目录里面去，并且会自动引入bundle.js文件
            })
        ]
    }
```
    12.
        1-自动清空dist目录里面的文件的插件clean-webpack-plugin
        2-下载完之后在webpack.config.js里进行配置
        3-然后在webpack.config.js里面引进来进行配置如下操作
```js
    const CleanWebpackPlugin = require("clean-webpack-plugin")
    module.exports = {
        plugins:[
            new CleanWebpackPlugin({path.join(__dirname,'dist')})  代表清空dist目录，操作npm run build的时候是直接将老的dist目录删除之后然后又重新生成dist目录的
        ]
    }
```
    13.webpack-dev-server的配置  webpack-dev-server的作用：解决每次都要对整个文件重新打包的时候速度慢效率低的问题;并且他打包只会打包更改之后的内容
        1-下载webpack-dev-server
        2-第一种方式是在package.json里面scripts写
```js
    "script":{
        "dev":"webpack-dev-server --open --port 9999 --content-base ./src --hot" --open含义打包文成之后自动把浏览器打开； --port 端口号9999； --content-base ./src 指定哪个文件夹作为目录这里就是src里面的index.html所以这里是src文件 ； --hot热加载会有页面不会刷新的效果会局部替换
    }
```
        3-第二种方式就不需要在package.json里面传参了在webpack.config.js里面传参就可以了
```js
    const webpack = require("webpack")
    module.exports = {
        plugins:[
            new webpack.HotModuleReplacementPlugin()
        ]
        devServer:{
            open:true,
            contentBase:path.join(__dirname,'src'),
            port:9999,
            hot:true   第二种方式写hot热更新功能时需要引入插件webpack.HotModuleReplacementPlugin这个插件是webpack里面的一个插件如上
        }
    }
```
