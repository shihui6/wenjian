###经典五层模型
    客户端: 应用层->传输层->网络层->数据链路层->物理层
    服务端: 应用层->传输层->网络层->数据链路层->物理层

    ***下面三层的介绍
        1.物理层:主要作用是定义物理设备如何传输数据
            指硬件设备，如网络连出去之后，一条光缆把数据传输到对面的服务器上面。
        2.数据链路层:在通信的实体间建立数据链路连接
            物理可以把俩台机器链接在一起，软件服务通过物理设备创建电路连接，也就是这俩边可以传输数据，基本的电脑传输数据010101形式的
        3.网络层:为数据在结点之间传输创建逻辑链路
            如:我们的电脑要去访问百度服务器，如何去寻找百度服务器所在的地址


    ***传输层(TCP协议,UDP协议，TCP协议用的多，此协议更加可靠成熟):1.向用户提供可靠的端到端(End-to-End)服务
        此服务的概念：建立了自己的电脑到百度服务器的链接之后，他们俩端如何传输数据，传输数据的方式，都是在这层进行定义的；我们传输的数据可能很小也可能很大，如果传输的数据大，一次性不能把这么多数据传输过去，那么要分包分片，分包分片传输到那边之后，又要进行一个组装，这个组装的过程，定义组装的过程都是在传输层进行定义的；
    
    2.传输层向高层屏蔽了下层数据通信的细节 此概念：http协议实现是在TCP协议之上的，http协议要传输数据只需要在浏览器里面输入一个url，它就会自动的去发送相关的数据到服务器端，然后服务器端解析这些数据返回给浏览器，把页面显示出来
        比如：我们使用ajax发送post请求的时候，发送数据比较大的，一次性传输是传输不完的，那么他是如何可靠的传输给服务器，服务器返回的信息又如何可靠的被我们拿到；传输层把这些问题都给我们实现了，我们http协议层是不需要关心的。


    **应用层：
        1为应用软件提供了很多服务
            我们写网页的时候，通过http协议发送请求是非常方便的
        2构建于TCP协议之上
            http协议传输的方式最终都是要落实TCP协议上面
        3屏蔽网络传输相关细节
            TCP屏蔽了http协议如何去发送数据的细节一样

***HTTP/1.0版本
        1增加了很多命令
        2增加了status code和header
        3多字符集支持，多部分发送，权限，缓存等

***HTTP/1.1只在1.0版本上增加了一些功能
        1持久链接
        2pipeline:在同一个连接中发送多个请求，但是在服务端对于进来的请求，我们都是按照顺          序进行内容的返回，相当于串行。
        3增加了host和其他一些命令：关于host，有了host之后我们就可以在同一台物理服务器同时跑多个不同的web服务，比如说一个java的web服务，一个nodejs web服务，通过host字段表示都是请求到这台物理服务器上面，但是我们请求的是里面的哪个服务，是node还是java，这是通过host进行判断的

***HTTP2 
        1所有的数据以二进制传输(以帧进行传输)
        2同一个连接里面发送多个请求不再需要按照顺序来
        3头信息压缩以及推送等提高效率的功能

***HTTP的三次握手(在学习三次握手之前需要理解：客户端和服务器之间发送请求的时候，需要创建TCP connection，因为http不存在连接这个概念的，只有请求和响应这个概念；请求和响应都是数据包，他们之间要经过传输的通道的，这个通道就是从客户端到服务器端的连接，http请求是在这个连接的基础上面去发送的，这个连接就是TCP连接)
    三次握手顺序
    1.client发送创建连接的数据包的请求，发送到服务端(SYN=1,Seq=x)
    2.server接收到了数据包之后，就会开启一个TCP端口，返回给客户端(SYN=1,ACK=x+1,Seq=Y)
    3.client拿到SYN=1,ACK=x+1,Seq=Y之后，知道server允许打开通道创建连接了，再去发送ACK=Y+1,Seq=Z
    为什么要进行这三次握手呢？能够让客户端和服务器端因为网络传输延时，导致的 服务器开销的问题
    
***URI：是包含URL和URN统一的定义(统一资源标识符)

***URL：统一资源定位器,用来找资源所在的位置，访问它
    如：http://user:pass@host.com:80/path?query=string#hash
    1-http:// 协议：以什么样的协议去访问这个资源，比如还有ftp。通过http://协议访问资源
    2-user:pass@ 指:访问资源,需要有特定的身份(用户名和密码)进行访问(这种访问方式几乎用不到，只要知道有这么一个方式)
    3-host.com 指定位服务器资源在互联网中的位置(互联网中定位一台机器，最基础的是ip，而host也可以是ip，我们就可以通过ip去找)  host也可以是域名，通过DNS的服务解析成ip然后才能定位到所在的服务器
    4-:80 指 端口:通过ip地址找到的服务器上，存放了好多服务中的某一个web服务，整个http协议就是用来定位的(默认不带端口的情况下是8080端口)
    5-path 指 路由 web服务里面可能存放了很多的内容，具体如何找到这个内容，我们可以通过path进行定位(一般会在程序当中体现，也不会在URL中用到)
    6-hash 代表前面url请求找到了一个文档，如果这个文档非常的大，作为用户来讲只要查找里面的一个段落，不需要全部内容。hash就是代表这个文档里面的一个片段。hash也可以作为锚点定位的一个工具

***URN：永久统一资源定位符(URN指向了这个资源，即便是这个资源移动了位置，但也可以通过URN访问到这个资源，这也是URL所不具备的能力)，在资源移动之后还能被找到，目前还没有非常成熟的使用方案


***http报文
    1请求报文

    2响应报文

***http客户端
    指：只要是实现了发送标准的http请求的工具，那么他就是标准的http client
    例子：通过在git bash中  输入curl 地址  就可以发送请求，并且可以得到响应
    最简单的客户端就是浏览器

***CORS跨域请求的限制和解决    
    1 Access-Control-Allow-Origin:*  原理(在服务端头部设置代表允许跨域)
        设置'*'指所有的服务都可以访问,我们也可以设置特定的服务可以访问如:'http://www.baidu',这样就只能允许baidu这个服务可以访问，其他服务访问会报错

     浏览器报：'Access-Control-Allow-Origin'跨域的错误原理：浏览器在发送这个请求的时候，他并不知道这个服务是不是跨域的，所以他还是会发送请求，并且浏览器也会接受返回内容，只不过浏览器接受到返回内容的时候，他看到这里面没有Access-Control-Allow-Origin头并且为允许的情况下也就是设置为'*'，会把请求返回的内容忽略掉，然后在命令行里面给你报这个错(所以说浏览器请求已经发送了，内容也已经返回了，只不过浏览器在解析了这个返回的内容之后发现是不允许的，就帮你拦截掉了，这其实是浏览器提供的功能)


    2.用JSONP实现跨域 原理 (在相应的标签上写链接，浏览器是允许跨域的)
    浏览器是允许 link script img 标签,在标签上写路径加载内容的时候，他是允许跨域的.并不在乎服务器是否设置头.所以JSONP实现原理，通过script标签加载链接，然后这个连接去访问服务器的某一个请求，并且返回内容，因为服务器返回的内容是可控的，所以可以在服务器返回内容里面写一段可执行的js代码，然后再调用JSONP在发起请求之前给我们设置的一些内容，就达到了目的。

    ****CORS请求预处理
        1.允许请求的方法
        在跨域请求的时候，默认允许的方法只有 GET POST HEAD，其他的PUT DELET默认是不允许的，想要PUT和DELET被允许，需要使用预请求验证

        1)前端请求头部(我们自定义的请求头) X-Test-Cors:123 响应的服务器端要设置 Access-Control-Allow-Headers:X-Test-Cors
        2)想让所有的请求都被允许要设置Access-Control-Allow-Methods:POST,PUT,DELET
        3)Access-Control-Max-Age:1000 指在这种请求下面，允许这种方式进行跨域请求的最长时间,1000秒之内，不需要发送预请求来验证了，直接发正式的请求就可以了
        
        4)浏览器为什么要提供这些限制呢？
        因为在网页里面进行跨域操作的时候，这种操作是保证服务端的安全的，他不允许任何随便的人或者随随便便的方法，不希望一些跨域的请求导致服务器的数据被恶意的篡改。所以提供一些限制之后，我们就提供一些有利的判断，来判断一些请求是否要响应

        5)POST请求的特点：发post请求的时候会先发一个OPTIONS请求获得服务端的认可，然后在实际上的进行post请求，这是浏览器对于跨域请求的预请求的操作
        
        2.允许Content-Type也有限制
        text/plain  multipart/form-data  application/x-www-form-urlencoded这三个是我们使用form表单element的时候可以设置的三种数据类型，除了这三种Content-Type之外的类型，要使用预请求验证过之后才能进行发送(为了恶意数据的攻击所以要进行预请求的处理)

        3.其他限制
        请求头限制

***HTTP请求的缓存Cache-Control(在服务端设置)
        用法：服务端头部设置 'Cache-Control':'max-age=200,public'
        可缓存性 1.public 指在http请求的返回过程当中，我在Cache-Control设置了public代表这个http请求返回的内容所经过的任何路径当中包括一些中间的代理服务器，以及发出请求的浏览器都可以进行对返回内容的缓存的               操作(http经过的任何地方都可以进行缓存)
                2.private 代表发起请求的浏览器才可以进行缓存
                3.no-cache (本地和proxy服务器可以缓存，但是要用缓存需要服务器端进行一个验证) 说明：
                            可以在本地进行缓存，也可以在proxy服务器进行缓存，每次发送请求的时候都要去服务器进行验证，服务器返回告诉你可以使用本地缓存，才可以真正使用本地缓存，意思是他是需要经过服务器端的验证的
                关于no-cache的需要经过服务端验证的做法
        缓存到期 
                1.max-age=<seconds> 缓存多少秒过期，过期之后浏览器才会再起发送请求到服务端请求新的内容
                如：设置max-age=200，在200秒之内浏览器都会从缓存当中读取会忽略掉服务器，但请求的url变化之后即使在200秒内浏览器会重新从服务器中获取。运用：根据服务端内容是否改变，动态更改url的hash让浏览器重新向服务器发送请求
                2.s-maxage=<seconds> 会代替max-age=<seconds>只有在代理服务器中才会生效，也就是说在浏览器端还是会读取max-age的到期时间，如果在代理服务器设置了max-age和s-maxage他会读取s-maxage,因为s-maxage专门为代理服务器去设置的
                3.max-stale=<sconds> max-stale是发送请求这一方主动带的头 在缓存max-age过期了 在max-stale时间内，还可以使用过期的缓存，不需要去原服务器请求新的内容，max-stale在浏览器里面是用不到的，因为浏览器发送请求或者在静态资源请求过程中并不会主动设置这头，而这个只有在发起端设置才会有用，服务端返回的内容中设置他是没有任何作用的(对于max-stale了解即可基本上用不到) 
                4.Vary response头，指定发送请求的时候，指定的Vary的头相同的情况下才会去使用缓存
                    用法：服务端头部设置 'Vary':'X-Test-Cache'
                         浏览器头部设置 'X-Test-Cache':1
                    浏览器发送请求X-Test-Cache值为1，将会被服务端记录X-Test-Cache值为1的时候所携带的信息，并且使用相应的缓存

        重新验证
                1.must-revalidate 在max-age缓存过期了，就必须去原服务端发送请求，重新获取这部分数据，再来验证这个内容是否真的过期了，而不能直接使用本地缓存
                2.proxy-revalidate 跟must-revalidate差不多，只不过proxy-revalidate是用在浏览器缓存服务器当中的，就是指定缓存服务器当中的如果过期了就需要到原服务器上重新请求一遍，而不能直接使用本地的缓存

        其他  (仅仅是约束，而不是一定改变不了的)
                no-store本地和代理都不可以存储缓存，永远都要去服务器端拿新的内容
                no-transform 主要是用在proxy服务中的，告诉代理服务器不要随便改动我返回的内容

****资源验证
        从浏览器发送请求到查找缓存的过程原理：那张原理图
        用法：
            服务端设置：'Content-Control':'max-age=2000,no-cache'代表在2000内，但是我需要通过资源验证才可以使用缓存
            'Last-Modified':'123',
            'Etag':'777'
            浏览器下次请求会自动带上If-Modified-Since  If-None-Match去和Last-Modified Etag进行对比验证

        验证头
            1.Last-Modified:上次修改时间。给这个资源设置上次什么时候被修改的
            配合If-Modified-Since或者If-Unmodified-Since使用
            作用：对比上次修改时间来验证资源是否需要更新
            原理：下次浏览器要发送请求的时候，会把If-Modified-Since带到服务器上，然后服务器通过读取header里面的If-Modified-Since的值对比资源上次修改的时间(也就是last-Modified)，如果发现上次修改的时间和If-Modified-Since是一样的，说明还没有被重新修改过，那么服务器就可以直接告诉浏览器可以使用缓存的数据(这是验证浏览器是否可以使用缓存的过程)
            2.Etag (更加严格的验证) 配合If-Match或者If-None-Match使用
            服务器对比从浏览器拿到的IF-Match签名和服务器端现在的签名进行判断，如果签名是相同的就不需要返回相同的内容，就可以在缓存中直接使用。
            数据签名：给资源内容产生唯一的一个签名，如果数据进行了修改，那么签名也会变成新的签名，只要有任何的修改俩个签名就会不一样

***Cookie
        1.是服务端通过header设置Set-Cookie，保存到浏览器里面的一个内容，这个内容就叫cookie，保存了这个cookie之后，下次在同域的请求当中就会带上这个cookie；用户访问访问网站的会话当中，就可以通过cookie一直在传输的内容来保证返回的数据是给这个用户的
        设置cookie之后，浏览器下次请求就会自动带上
        cookie是键值对，可以设置多个
 
        2.cookie属性：
            max-age和expires设置过期时间  max-age和expires写法不一样 expires设置的是时间点
            Secure只在https的时候发送
            设置httpOnly就无法通过document.cookie访问cookie，这么做的原因考虑到安全性
                如：'set-Cookie':['id=123;HttpOnly']给id=123设置HttpOnly就可以限制访问cookie

            如果想要在一级域名下的所有的二级域名(test.com)都能够读到cookie，可以给对应的cookie设置domain=test.com  在同一个二级域名下面可以分享同一个cookie

***HTTP长链接
        长链接普及(长链接可以设置timeout：指在TCP上过了多长时间没有请求发送就自动关闭这个长链接,chrome里面可以有6个并发的链接) 因为到达了6个并发的限制之后，要是开始有10个并发，剩下来还有4的个并发，至少要等到其中一个并发完成之后，新的链接再进去

        具体操作：
        前端每次发送都会在request headers里面带有Connection:keep-alive,如果后端response headers里面也包含Connection:keep-alive，那么同一个域名的链接就可以进行TCP的长链接(要是后端Connection不返回keep-alive就形成不了长链接的条件)

***HTTP协议的数据协商
        概念：客户端发送给服务端请求的时候，客户端会在请求中限制要拿到的数据的格式，服务端根据请求的头信息进行区分，判断返回的数据格式

        分类：
            请求头中
            1、Accept:代表声明想要的数据类型 通过number-Type声明的限制
            2、Accept-Encoding:代表数据是个什么样的编码方式进行传输，主要是限制服务端如何进行数据的压缩，因为现在数据压缩方式的算法很多
                size：409B指数据传输经过压缩之后的数据大小包含http的headers，body，首行的信息，下面数字是body里面的解压之后展示在页面之后的大小。所以压缩的好处就是降低网络的开销提升性能
            3、Accept-Language:根据这个头判断展示的是中文还是英文，不同的地方展示的服务是不同的，比如说：国内希望展示中文
            4、User-Agent:可判断是返回pc端的页面还是移动端的页面和判断返回的页面适合哪些浏览器。因为pc端和移动端你的User-Agent是不同的

            返回头中
            1、Content-Type对应请求头中Accept,返回的值可选择Accept中的任意一个值进行返回，客户端根据返回的Content-Type的值判断数据如何展示
            2、Content-Encoding对应的Accept-Encoding,表示服务端是一个什么样的压缩方式，就可以通过Content-Encoding进行声明
            3、Content-Language对应Accept-Language，可判断根据请求返回你想要的语言还是没有根据请求返回需要的语言，可通过Content-Language来声明


***HTTP url的redirect 只有在服务端设置
            (通过url请求资源的时候，服务端数据位置发生了变化，可以通过在状态码302头部设置'Location':'新的资源地址')，这里302指的是临时重定向，301指的是永久重定向(所以要谨慎使用，除非用户清理浏览器缓存之后才会取消永久定向的结果)

            具体操作(服务端):if(request.url==='/'){
                response.writeHead(302,{
                    'location':'/new'   代表请求地址为'/'时，通过location会跳到'/new'上去
                })   
            }

***HTTP内容安全资源策略(CSP 指Content-Security-Policy)
    作用：
        限制资源获取
            从哪里获取或者请求发到哪个地方，这些都可以通过Content-Security-Policy来进行限制
        报告资源获取越权
            从网页中获取了不应该获取的资源的时候，给我们的服务进行报告，让服务端知道网页出现了没有预计到的情况，可以相应的做出调整

    限制方式：
        default-src限制全局的所有跟链接请求有关的作用范围
        制定资源类型(根据特定的资源类型，限制资源范围) 只要是网页上跟链接有关的都可以进行资源类型的限制
            资源类型：default-src(对全局所有的链接都有限制作用) connect-src(代表请求发向的目标进行限制) img-src(图片从哪几个网站上面进行加载对此进行限制) style-src(样式资源加载的样式) font-src frame-src script-src(脚本资源从网站的加载的限制) manifest-src
        用法：一般都是在服务端头部设置(还可以在meta标签中设置，但是一般不用) 如设置全局资源只允许请求自身资源(default-src限制对于form表单是无效的，需要通过form-src进行限制)：'Content-Security-Poclicy':'default-src \'self\';'form-src' \'self\''
            设置script脚本加载限制，只允许通过http或者https请求'Content-Security-Poclicy':'script-src http: https:'

        内容安全策略出现限制情况的时候可以主动向服务器申请发请求进行汇报的，用法：'Content-Security-Policy':'report-url /report' 要是出现限制情况会浏览器会自动发送csp-report相关的信息内容(此内容有block-url堵塞的url地址很详细的情况)

        'Content-Security-Policy-Report-Only':'report-url /report' 代表虽然检测到这个资源是我不想加载的，但是我还是加载了，只不过我只做一个report的工作，不强制他不能加载(内容已经加载过来了，不过浏览器检测到了不允许加载，所以他会做一个report的工作)

###nginx
        用nginx的原因：nginx是互联网界用的最多的web服务器，我们可以使用nodejs，python，java这些写http服务，那么为什么我们还是要用ngnix做web服务器呢？因为nginx是纯粹的做http协议的服务；而nodejs，java等更多的是实现业务逻辑的开发(编写代码，调取数据，动态的生成html)

        1、安装：https://nginx.org进行安装即可
        2、启动:在nginx安装目录启动git bash  启动代码 ./nginx.exe
        3、查看是否启动:在浏览器输入 localhost
        4、修改nginx配置，让nginx代理nodejs的服务；现在nginx用的最多的就是代理功能和缓存功能

        nginx里面配置
        nginx下面有个后缀名为conf的文件名(是nginx配置的主文件)在主文件里面通过include servers/*.conf(include是nginx常用的指令，来帮nginx导入一些配置)让我们有新的站点创建的时候可以单独创建一个配置文件，这样的话能更好的隔离

        5.关于配置文件conf的说明
            server{
                listen    80;
                server_name  test.com;

                location / {
                    proxy_pass http://127.0.0.1:8888;
                    proxy_set_header Host $host;
                }
            }
        server 代表启动一个服务
        listen 代表监听一个端口(80指监听的80端口)
        server_name 代表在浏览器访问的host name，会根据访问的host判断要把服务启动在什么地方，返回什么内容，代理到那个地方
        location /代表所有的请求
        proxy_pass 指要代理到哪个地方

***nginx作为代理能够进行缓存的功能(接下来是配置nginx缓存)
        说明：代理是在代理那层设置，所以每个新的请求都会经过代理，因为代理缓存已经缓存过一次了，只要第一个用户请求了之后就会在代理服务器中进行一个缓存，其他用户就可以直接使用代理缓存(对于通用的缓存能够进行更高效的缓存功能)

        1-缓存的配置
            proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m
            cache:缓存存放的目录
            levels=1:2 是否要创建2级文件夹  因为cache声明在这里的时候他可以用在不同的代理服务器里面，如果没有声明levels=1:2他会把所有的代理会放在同一个文件夹，因为没有声明levels=1:2就没有子目录，这就会导致随着缓存的越来越多，查找起来就会变的越来越慢
            keys_zone=my_cache:10m (这里的10代表内存大小10M ) 我们要执行一个代理缓存的功能，所以要查找这一个缓存，他就需要有一个地方去保存，一个url对应的缓存在哪个地方，那么这个关系是存在内存里面的，我们要设置内容大小来进行保存这里就是10M  my_cache是缓存的名字，我们可以在不同的服务里面配置不同的缓存，可以通过名字来指定使用哪个缓存
                用到缓存的服务里面的用法：
                server{
                    listen    80;
                    server_name  test.com;

                    location / {
                        proxy_cache my_cache;  #指定缓存的位置
                        proxy_pass http://127.0.0.1:8888;
                        proxy_set_header Host $host;
                    }
                }

***HTTPS(安全的HTTPSecurity)
        http为啥不安全：因为http整个定义都是明文传输的,可能会被别人拿到包，然后拿到隐私数据

    加密：  私钥
           公钥：是放在互联网上所有人都能拿到的一串加密的字符串，这个加密的字符串是用来加密传输的信息的。使用公钥进行加密的数据传输到服务器上，只有通过服务器的私钥进行解密才能把公钥加密过的数据解密出来，中间任何人拿不到私钥，因为私钥是放在服务器上不会放在互联晚上进行传输

    https的握手过程：
        1-客户端先生成一个随机数传输到服务端，中间会带有随机数和支持的加密套件(加密套件里面因为会有很多的加密方法)
        2-服务端拿到随机数之后先存着，然后服务端也生成一个随机数同时还有服务端证书(公钥)一起传输到客户端
        3-客户端拿到随机数之后也先存着，通过服务端传给他的公钥生成一个预主秘钥(生成过程当中也会有一个新的随机数)生成的随机数用公钥加密了，然后将数据传输给服务端，这个过程是不能被解析的(是没有办法被其他人拿到数据的)(因为使用的公钥进行加密)
        4-数据传输到服务器，服务器通过私钥进行解密拿到了预主秘钥(也就是之前在客户端的随机字符串)；然后客户端和服务端同时对三个数进行算法的操作生成主密钥(这里会涉及到一个加密套件，客户端和服务端会确定同时使用同一个加密套件对三个随机数进行算法的操作)
        5-最后一个随机数只有客户端和服务端他们自己知道的(中间人是拿不到的)，所以中间人是没办法破解的；那么后期传输的数据全部是通过主密钥进行传输的(因为俩边主密钥是一样的，所以俩边都能对加密的数据进行解密，所以中间的传输就变成了安全的传输)
