***数组和字符串相互转换
    1-数组转字符串   join(',')
    2-字符串转数组   split(',')
    关于数组的方法
        1-push
        2-pop  取出数组的最后一项
        3-shift 取出数组的第一个元素
        4-unshift 在数组的最前面插入项
        5-reverse 翻转数组
        6-sort  对数组进行排序，想按照其他标准进行排序，就需要提供比较函数
        7-cancat 用于俩个或多个数组进行拼接  A.concat(B) A和B都是数组
        8-splice  对数组进行删除或添加  splice(index,删除的项数，添加的项)
        9-slice 从已有的数组中返回选中的数组   slice(start,end)
        10-reduce Array.reduce((pre,cur,index,arr)=>{},[]) 后面的[]数组代表初始值还可以表示最终生成的数据格式。
    关于字符串的方法
        1-replace 字符串替换 replace(条件，替换体)
        2-substr  在字符串中抽取从start下标开始的指定数目的字符 substr(start,length)


***遍历数组的方法
    1-every 数组中所有的项满足返回true
    2-some  数组中只要有一项满足就返回true
    3-map   让数组中的每一项执行这个函数，返回每一项结果组成的数组
    4-filter让数组中的每一项执行，返回满足条件的项的数组
    5-forEach 提供一个函数，让数组中的每一项都执行这个函数，没有返回值v,是数组中的每一项，i是数组中的索引


***switch语句
    switch(表达式){
        case n:
        代码块,
        break;
    }
###说明Object.prototype.toString.call(obj)原理
***同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果为什么不一样？
    这是因为toStirng为Object的原型方法，而Array,function等类型作为Object的实例,都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识,调用的是对应的重启之后的toString方法(Function类型返回内容为函数体的字符串,Array类型返回元素组成的字符串...),而不会去调用Object上原型toString方法(返回对象的具体类型)，所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型，因此，想要得到对象的具体类型，应该调用Object原型toString方法。

    例子：Object.prototype.tostring.call('shihui')   返回: [object String]


***Object.keys()用法
    Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组
***Date.toISOString() 将Date转化成ISO格式的时间字符串


***async、await的使用
    做什么？用async和await来处理异步
    是什么？
        1-先说一下async的用法,它作为一个关键字放在函数前面，用于表示函数是一个异步函数，因为async就是异步的意思，异步函数也就意味着该函数的执行不会阻塞后面代码的执行
        2-await关键字是等待的意思，await后面可以放任何表达式，不过我们更多的是放一个返回promise对象的表达式。注意：await关键字只能在async里面使用。
            具体：代码执行到await时会等待，等到执行完毕之后，下面的代码才会继续执行。



***qs.stringify和JSON.stringify的使用和区别
    qs可通过npm install qs命令进行安装，是一个npm仓库所管理的包，而qs.stringify()将对象序列化成URL的形式，以&进行拼接
    qs.stringify和JSON.stringify实例对比
```js
    var a = {name:'hehe',age:10}
    qs.stringify(a) //'name=hehe&age=10'
    JSON.stringify(a) // '{"name":"hehe","age":10}'
```


***创建一个新的空白的文档片段
```js
let fragment = document.createDocumentFragment();
fragment是一个指向空DocumentFragment对象的引用
```
DocumentFragments 是DOM节点。它们不是主DOM树的一部分。通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。

因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。


###js高级函数的用法
```js
    // 这里的data是数组  arg是参数
    // 第一种写法
    const list = function (data){
        return function (...arg){
            data = data.map(function(item){
                return item + arg
            })
            return data
        }
    }
    //将第一种写法写成第二种写法的方式
    let list = (data)=>(...arg)=>{
        data = data.map(item=>item + arg)
        return data
    }
```