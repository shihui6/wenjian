**安装typescript
    1-有俩种主要的方式来获取typescript工具
        1-1：通过npm安装 (npm install -g typescript)
        1-2：安装vscode的typescript插件 (vscode2017和vscode2015 Update 3默认包含了TypeScript)

**编译代码
    在typescript中尽可能是用let来代替var
    1-概念：在.ts扩展名的命令行上运行typescript编译器
    2-用法：tsc + ts文件
    实例：

        ```ts
            tsc greeter.ts  //输出结果为一个greeter.js文件
        ```

**基础类型
    1-布尔值

    ```ts
        let isDone:boolen = false 
    ```

    2-数字
    概念：和JavaScript一样，typescript里的所有数字都是浮点数。这些浮点数的类型是number。除了支持十进制和十六进制字面量，typescript还支持ECMAScript2015中引入的二进制和八进制字面量

    ```ts
        let dec:number = 20
        let dec:number = 0x14 16进制表示法
        let dec:number = 0b10100  2进制表示法
        let dec:number = 0o24 8进制表示法
    ```

    3-字符串
        3-1概念：使用string表示文本数据类型
        3-2用法：
            3-2-1：可以使用双引号或单引号表示字符串
            3-2-2：使用模板字符串，定义多行文本和内嵌表达式。这种字符串是被反引号`包围
            实例：

            ```ts
                let name:string = 'bob'
                let sentence:string = `hello,my name ${name}`
            ```
    
    4-数组
        4-1：数组类型用法：
            4-1-1：在元素类型后面接上[]，表示由此类型元素组成的一个数组
            4-1-2：数组泛型，Array<元素类型>
            实例：

            ```ts
                let list:number[]=[1,2,3,4] 数字类型的数组
                let list:Array<number> = [1,2,3,4]  数组泛型
            ```

    5-元祖Tuple
        5-1：概念：
            5-1-1：元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同
            实例：

            ```ts
                let x:[string,number]  
                x=['hello',10]
            ```
            实例解释注意点：定义x数组，第一个数据是字符串第二个数字是数字，顺序类型严格要求

            5-1-2：当访问一个已知索引的元素，会得到正确的类型对应的值
            5-1-3：当访问一个越界元素，会使用联合类型替代
            实例：

            ```ts
                let x:[string,number]  
                x=['hello',10]
                x[3] = 'world'  //hello,字符串可以赋值给(string | number)类型，此类型为联合类型
                x[4] = true //会报错：因为布尔值，不是(string | number)类型
            ```
                实例解释：当添加一个联合类型里没有的类型，则会报错

    6-枚举
        6-1：概念：enum类型是对JavaScript标准数据类型的一个补充。使用枚举类型可以为一组数值赋予友好的名字
        6-2：用法：枚举类型提供的一个便利是你可以由枚举的值得到它的名字。
            6-2-1：实例：我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字

            ```ts
                enum Color {Red = 1, Green, Blue}
                let colorName: string = Color[2];
                alert(colorName);  // 显示'Green'因为上面代码里它的值是2 
            ```
            6-2-2：Color默认的对应的枚举值为0,1,2，可以通过点的方式取到枚举值，也可以通过枚举值找到对应的名字值、
            实例：

            ```ts
                enum Color{
                    Red,
                    Green,
                    Blue
                }
            ```

    7-any
        7-1：概念：在某些情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量
            实例：

            ```ts
                let list:any[] =  [1,'yee',false]
                let notSure:any = 4
                notSure = 'maybe'
            ```
            实例解释：any类型，编译器允许你在编译时可选择地包含或移除类型检查
        7-2：any类型和Object类型比较，你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法
            实例：

            ```ts
                let notSure: any = 4;
                notSure.ifItExists(); // okay, ifItExists might exist at runtime
                notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

                let prettySure: Object = 4;
                prettySure.toFixed(); // 报错: 类型对象上不存在toFixed()属性，即便它真的有这些方法
            ```

    8-void
        8-1：概念：
            8-1-1：某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void
            实例：

            ```ts
                function warn():void {   没有任何返回值的函数
                    console.log('this is my waring message')
                }
            ```
            8-1-2：声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null
            实例：

            ```ts
                let unusable: void = undefined;
            ```

    9-null和undefined
        概念：TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null

        ```ts  是所有类型的子类型
            let u:undefined = undefined
            let u:null = null
        ```
    
    10-never
        10-1：概念：
            10-1-1：never类型表示的是那些永不存在的值的类型
            10-1-2：必须是不能返回的或者是报错的或不能结束的
        10-2：用法：
            10-2-1：返回never的函数抛出异常

            ```ts
                function error(message: string): never {
                    throw new Error(message);
                }
            ```

            10-2-2：推断的返回值类型为never

            ```ts
                function fail() {
                    return error("Something failed");
                }
            ```
            10-2-3:返回never的函数必须存在无法达到的终点

            ```ts
            function infiniteLoop(): never {
                while (true) {
                }
            }
            ```

    11-类型断言(类型断言或者类型转换)
        11-1:概念：类型转换
        11-2:类型断言执行机制：告诉编译器，进行数据类型转换，不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用
        11-3：用法：类型断言有两种方式
            11-3-1：尖括号语法

            ```ts
            let someValue: any = "this is a string";
            let strLength: number = (<string>someValue).length;   //将someValue强制转换成string类型
            ```
            11-3-2：as语法

            ```ts
            let someValue: any = "this is a string";
            let strLength: number = (someValue as string).length; //将someValue强制转换成string类型
            ```

        注意点：当你在TypeScript里使用JSX时，只有as语法断言是被允许的



**接口
    概念：对值所具有的结构进行类型检查，为这些类型命名和为你的代码或第三方代码定义契约

    1-接口初探
        实例：

        ```ts
            interface LabelledValue {
                label: string;
            }
            function printLabel(labelledObj: LabelledValue) {
                console.log(labelledObj.label);
            }
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
        ```
        实例解释：LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表printLabel函数参数中有一个label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的

        注意点：类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以

    2-可选属性
        2-1：概念：接口里的属性不全都是必需的。有些是只在某些条件下存在，或者根本不存在。即给函数传入的参数对象中只有部分属性赋值了
        2-2：用法：带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号
        2-3：用可选属性的原因：
                2-3-1：对可能存在的属性进行预定义
                2-3-2：捕获引用了不存在的属性时的错误
            实例：

            ```ts
                interface SquareConfig {
                    color?:string;
                    width?:number
                }
                function createSquare(config:SquareConfig):Square {
                    let newSquare = {color:'white',area:100}
                    if(config.color){   
                        newSquare.color = config.clor  //报错：参数的属性中没有接口中定义的属性时会报错
                    }
                    return newSquare
                }
                let mySquare = createSquare(config:{color:'black'})

            ```
        
    3-只读属性
        3-1:概念：一些对象属性只能在对象初始化的时候修改其质
        3-2:用法：
            3-2-1：在属性名前用readonly来指定只读属性
            3-2-2：通过ReadonlyArray<T>指定只读
        3-3:实例：
            3-3-1:通过赋值一个对象字面量来构造一个Point，赋值后，x和y再也不能被改变了

            ```ts
                interface Point {   
                    readonly X:number
                    readonly y:number
                }
                let p1: Point = { x: 10, y: 20 };
                p1.x = 5; // error!
            ```
            3-3-2:TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改

            ```ts
                let a: number[] = [1, 2, 3, 4];
                let ro: ReadonlyArray<number> = a;
                ro[0] = 12; // error!
                ro.push(5); // error!
                ro.length = 100; // error!
                a = ro; // error!
            ```
                实例解释：ro赋值到一个普通数组也是不可以的，但是可以通过类型断言重写如

                ```ts
                    a = ro as number[]
                ```


    4-额外属性检查
        4-1概念：对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何'目标类型'不包含的属性时，会得到一个错误
        4-2用法：在接口中添加一个字符串索引签名，前提是能够确定这个对象可能具有某些做为特殊用途使用的额外属性

        实例：如果SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它

            ```ts
                interface SquareConfig {
                    color?: string;
                    width?: number;
                    [propName: string]: any;
                }
            ```
            实例解释：SquareConfig表示任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么


    5-函数类型
        5-1:概念：接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型
        5-2:用法：
            5-2-1:用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                } 
            ```
            5-2-2:对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                }
                let mySearch: SearchFunc;
                mySearch = function(src: string, sub: string): boolean {
                let result = src.search(sub);
                return result > -1;
                }
            ```
            5-2-3:不想指定类型

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                }
                let mySearch: SearchFunc;
                mySearch = function(src, sub) {
                    let result = src.search(sub);
                    return result > -1;
                }
            ```
                实例解释：TypeScript的类型系统会推断出参数类型,因为函数直接赋值给了SearchFunc类型变量。函数的参数和返回值类型是通过SearchFunc函数接口推断出来的


    6-可索引类型
        6-1：概念：与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型
        6-2：用法：
            6-2-1：可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型
            实例：我们定义了StringArray接口，它具有索引签名。这个索引签名表示了当用number去索引StringArray时会得到string类型的返回值

            ```ts
                interface StringArray {
                [index: number]: string;
                }

                let myArray: StringArray;
                myArray = ["Bob", "Fred"];

                let myStr: string = myArray[0];
            ```
            6-2-2：支持两种索引签名：字符串和数字
                注意点：可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型
                注意点解释：因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致

            6-2-3:当name的类型与字符串索引类型不匹配,类型检查器会给出一个错误提示

                ```ts
                    interface NumberDictionary {
                    [index: string]: number;
                    length: number;    // 可以，length是number类型
                    name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
                    }
                ```
                实例解释：字符串索引签名能够很好的描述dictionary(接口)模式，并且它们也会确保所有属性与其返回值类型相匹配。因为字符串索引声明了obj.property和obj["property"]两种形式都可以

            6-2-4：将索引签名设置为只读

                ```ts
                    interface ReadonlyStringArray {
                        readonly [index: number]: string;
                    }
                    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
                    myArray[2] = "Mallory"; // error!
                ```


    7-类类型
        7-1:实现接口
            概念：与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约
            实例：

            ```ts
                interface ClockInterface {
                    currentTime: Date;
                }

                class Clock implements ClockInterface {
                    currentTime: Date;
                    constructor(h: number, m: number) { }
                }
            ```
            7-1-1：在接口中描述一个方法，在类里实现它
            实例;在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样

            ```ts
                interface ClockInterface {
                    currentTime: Date;
                    setTime(d: Date);
                }

                class Clock implements ClockInterface {
                    currentTime: Date;
                    setTime(d: Date) {
                        this.currentTime = d;
                    }
                    constructor(h: number, m: number) { }
                }
            ```
            7-1-2:注意点：接口描述类的公共部分，而不是公共和私有两部分，它不会帮你检查类是否具有某些私有成员

        7-2：类静态部分与实例部分的区别
            概念说明：类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误

            概念解释：当一个类实现一个接口时，只对其实例部分进行类型检查。constructor存在于类的静态部分，所以不在检查范围内
            实例：

            ```ts
                interface ClockConstructor { 定义构造器的接口或者静态部分的接口
                    new (hour: number, minute: number): ClockInterface;
                }
                interface ClockInterface {  定义实例接口
                    tick();
                }
            
                function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
                    return new ctor(hour, minute);
                }
                class DigitalClock implements ClockInterface {
                    constructor(h: number, m: number) { }
                    tick() {
                        console.log("beep beep");
                    }
                }
                class AnalogClock implements ClockInterface {
                    constructor(h: number, m: number) { }
                    tick() {
                        console.log("tick tock");
                    }
                }

                let digital = createClock(DigitalClock, 12, 17);
                let analog = createClock(AnalogClock, 7, 32);
            ```
            实例执行机制：DigitalClock类作为参数传入createClock时被定义的接口ClockConstructor进行限制，后面执行中需要遵守ClockConstructor接口类型

            实例执行机制补充说明：由于类型编译器不会对静态成员进行类检查，当createClock参数ctor限定类型为ClockConstructor，当DigitalClock类传入的时，判断该参数在执行new操作之后返回的类型是否满足接口类型限制
    
    8-继承接口
        8-1概念：和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里
        8-2:实例：
            8-2-1:实现一个简单的接口继承

            ```ts
                interface Shape {
                    color: string;
                }

                interface Square extends Shape {
                    sideLength: number;
                }

                let square = <Square>{};
                square.color = "blue";
                square.sideLength = 10;
            ```
            8-2-2:实现一个接口可以继承多个接口，创建出多个接口的合成接口

            ```ts
                interface Shape {
                    color: string;
                }

                interface PenStroke {
                    penWidth: number;
                }

                interface Square extends Shape, PenStroke {
                    sideLength: number;
                }

                let square = <Square>{};
                square.color = "blue";
                square.sideLength = 10;
                square.penWidth = 5.0;
            ```

    9-混合类型
        概念：一个对象可以同时具有上面提到的多种类型
        实例：一个对象可以同时做为函数和对象使用，并带有额外的属性

        ```ts
            interface Counter {
                (start: number): string;
                interval: number;
                reset(): void;
            }

            function getCounter(): Counter {
                let counter = <Counter>function (start: number) { };
                counter.interval = 123;
                counter.reset = function () { };
                return counter;
            }

            let c = getCounter();
            c(10);
            c.reset();
            c.interval = 5.0;
        ```

    10-接口继承类
        10-1:概念：
            10-1-1：当接口继承了一个类类型时，它会继承类的成员但不包括其实现
            10-1-2：接口同样会继承到类的private和protected成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现
            实例：

            ```ts
                class Control {
                    private state: any;
                }
                interface SelectableControl extends Control {
                    select(): void;
                }
                class Button extends Control implements SelectableControl { 
                    select() { }
                }
                class TextBox extends Control {

                }
            ```
                实例解释：SelectableControl包含了Control的所有成员，包括私有成员state。因为state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。因为只有Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的

        

**类
    1-公有，私有与保护的修饰符
        1-1：public概念：在typescript里，成员都默认为public
             实例：明确的将每个成员标记成public。

            ```ts
                class Animal {
                    public name: string;
                    public constructor(theName: string) { this.name = theName; }
                    public move(distanceInMeters: number) {
                        console.log(`${this.name} moved ${distanceInMeters}m.`);
                    }
                }
            ```
        
        1-2:private
            定义：
                1-2-1：当成员被标记成private时，它就不能在声明它的类的外部访问
                实例：

                ```ts
                class Animal {
                    private name: string;
                    constructor(theName: string) { this.name = theName; }
                }
                new Animal("Cat").name; // 错误: 'name' 是私有的.
                ```
                实例解释：Animal类私有成员name，不能在类的外部访问哪怕是这个了的实例对象

                1-2-2：typescript使用的是结构性类型系统当我们比较两种不同的类型时，并不在乎它们从何而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的
                        1-2-2-1：注意点：当在比较带有private或protected成员的类型的时候，情况就不同了。如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样的一个private成员，并且它们都是来此同一处声明，我们才认为这两个类型是兼容的。对于protected成员也是这个规则
                        实例：

                        ```ts
                        class Animal {
                            private name: string;
                            constructor(theName: string) { this.name = theName; }
                        }
                        class Rhino extends Animal {
                            constructor() { super("Rhino"); }
                        }
                        class Employee {
                            private name: string;
                            constructor(theName: string) { this.name = theName; }
                        }
                        let animal = new Animal("Goat");
                        let rhino = new Rhino();
                        let employee = new Employee("Bob");
                        animal = rhino;   
                        animal = employee; // 错误: Animal 与 Employee 不兼容.
                        ```
                        实例解释：因为Animal和Rhino共享了来自Animal里的私有成员定义private name: string,因此它们是兼容的(才有它们的实例animal=rhino)；而Employee里也有一个私有成员name，但它明显不是Animal里面定义的那个，所以当把Employee赋值给Animal的时候，得到一个错误，说明它们的类型不兼容

        1-3：protected
             1-3-1：定义：
                1-3-1-1：protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问
                实例：

                ```ts
                class Person {
                    protected name: string;
                    constructor(name: string) { this.name = name; }
                }

                class Employee extends Person {
                    private department: string;

                    constructor(name: string, department: string) {
                        super(name)
                        this.department = department;
                    }

                    public getElevatorPitch() {
                        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
                    }
                }
                let howard = new Employee("Howard", "Sales");
                console.log(howard.getElevatorPitch());
                console.log(howard.name); // 报错，不能在实例中访问，可以在实例中访问方法，此方法可以访问该被protected的属性
                ```
                1-3-1-2：构造函数也可以被标记成protected。意味着这个类不能在包含它的类外被实例化，但是能被继承
                实例：

                ```ts
                class Person {
                    protected name: string;
                    protected constructor(theName: string) { this.name = theName; }  //Person构造函数是被保护的
                }
                // Employee 能够继承 Person
                class Employee extends Person {
                    private department: string;
                    constructor(name: string, department: string) {
                        super(name);
                        this.department = department;
                    }
                    public getElevatorPitch() {
                        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
                    }
                }
                let howard = new Employee("Howard", "Sales");
                let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的.
                ```

        1-4：readonly修饰符
                定义：readonly关键字将属性设置为只读。
                注意点：只读属性必须在声明时或构造函数里被初始化
                实例：

                ```ts
                    class Octopus {
                        readonly name: string;
                        readonly numberOfLegs: number = 8;
                        constructor (theName: string) {
                            this.name = theName;
                        }
                    }
                    let dad = new Octopus("Man with the 8 strong legs"); //构造函数时初始化name只读属性
                    dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
                ```
        
        1-5：参数属性
                1-5-1：概念：参数属性通过给构造函数参数添加一个访问限定符来声明
                1-5-2：作用：使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说也是一样
                实例：

                ```ts
                //没有用参数属性
                class Animal {
                    private name: string;
                    constructor(theName: string) { this.name = theName; }
                }
                // 使用了参数属性
                class Animal {
                    //在构造函数里使用private name: string参数来创建和初始化name成员。把声明和赋值合并至一处
                    constructor(private name: string) { }  
                    move(distanceInMeters: number) {
                        console.log(`${this.name} moved ${distanceInMeters}m.`);
                    }
                }
                ```

        1-6：存取器
                1-6-1：概念：typescript支持通过getters/setters来截取对对象成员的访问。
                1-6-2：作用：它能帮助你有效的控制对对象成员的访问
                实例：把一个简单的类改写成使用get和set

                ```ts
                // 没有使用存取器的例子
                class Employee {
                    fullName: string;
                }
                let employee = new Employee();
                employee.fullName = "Bob Smith";
                if (employee.fullName) {
                    console.log(employee.fullName);
                }
                // 对上面的例子使用存取器(先检查用户密码是否正确，然后再允许其修改员工信息)
                let passcode = "secret passcode";
                class Employee {
                    private _fullName: string;
                    get fullName(): string {
                        return this._fullName;
                    }
                    set fullName(newName: string) {
                        if (passcode && passcode == "secret passcode") {
                            this._fullName = newName;
                        }
                        else {
                            console.log("Error: Unauthorized update of employee!");
                        }
                    }
                }
                let employee = new Employee();
                employee.fullName = "Bob Smith";
                if (employee.fullName) {
                    alert(employee.fullName);
                }
                ```
                    事例使用存取器改写之后的解释：我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工
                1-6-3：注意点：
                    1-6-3-1：存取器要求编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3
                    1-6-3-2：只带有get不带有set的存取器自动被推断为readonly

        1-7：静态属性
            1-7-1:概念：
                1-7-1-1:实例成员：那些仅当类被实例化的时候才会被初始化的属性
                1-7-1-2:静态成员：这些属性存在于类本身上面而不是类的实例上
            1-7-2用法：使用static定义属性，在类中使用this调用该属性
            事例：

            ```ts
            class Grid {
                static origin = {x: 0, y: 0};
                calculateDistanceFromOrigin(point: {x: number; y: number;}) {
                    let xDist = (point.x - Grid.origin.x);
                    let yDist = (point.y - Grid.origin.y);
                    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
                }
                constructor (public scale: number) { }
            }

            let grid1 = new Grid(1.0);  // 1x scale
            let grid2 = new Grid(5.0);  // 5x scale

            console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
            console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
            ```

        1-8:抽象类
            1-8-1：概念：抽象类做为其它派生类的基类使用。它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节

            1-8-2：用法：abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法

            1-8-3：注意点：
                   1-8-3-1：抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。
                   1-8-3-2：抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含abstract关键字并且可以包含访问修饰符
                   1-8-3-3：抽象类无法实例化；接口可以理解为抽象类的子集
            事例：

            ```ts
                abstract class Department {
                    constructor(public name: string) {
                    }
                    printName(): void {
                        console.log('Department name: ' + this.name);
                    }
                    abstract printMeeting(): void; // 必须在派生类中实现
                }
                // 理解点：上面的抽象类实际上也是下面这种形式
                // interface Department {
                //     name:string;
                //     printName(): void 
                //     printMeeting(): void; 
                // }
        
                class AccountingDepartment extends Department {
                    constructor() {
                        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
                    }
                    printMeeting(): void {
                        console.log('The Accounting Department meets each Monday at 10am.');
                    }
                    generateReports(): void {
                        console.log('Generating accounting reports...');
                    }
                }
                // 允许创建一个对抽象类型的引用  
                // department: Department意思是department实现Department(类或抽象类可以当接口使用，将类转换成接口就是对象的形式)
                let department: Department; 
                department = new Department(); // 错误: 不能创建一个抽象类的实例
                department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
                department.printName();
                department.printMeeting();
                department.generateReports(); // 错误: 方法在声明的抽象类中不存在
            ```
            事例解释：抽象类和接口用法相似，但抽象类中可以包含成员的具体实现。Department意思是department实现Department(类或抽象类可以当接口使用，将类转换成接口就是对象的形式)


    2-高级技巧
        2-1：把类当做接口使用
            2-1-1:概念：类定义会创建两个东西：类的实例类型和一个构造函数
                事例：

                ```ts
                    class Greeter {
                        static standardGreeting = "Hello, there";
                        greeting: string;
                        greet() {
                            if (this.greeting) {
                                return "Hello, " + this.greeting;
                            }
                            else {
                                return Greeter.standardGreeting;
                            }
                        }
                    }
                    let greeter1: Greeter;
                    greeter1 = new Greeter();
                    console.log(greeter1.greet());

                    let greeterMaker: typeof Greeter = Greeter;
                    greeterMaker.standardGreeting = "Hey there!";

                    let greeter2: Greeter = new greeterMaker();
                    console.log(greeter2.greet());
                ```
                事例解释(let greeterMaker: typeOf Greeter = Greeter的解释)：创建了一个叫做greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用typeof Greeter(typeOf和定义接口类型的方式是一样的)，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。

            2-1-2:原因：因为类可以创建出类型，所以你能够在允许使用接口的地方使用类

            ```ts
            class Point {
                x: number;
                y: number;
            }
            interface Point3d extends Point {
                z: number;
            }
            let point3d: Point3d = {x: 1, y: 2, z: 3};
            ```


**函数
    1-函数类型
        1-1：为函数定义类型
            事例：

            ```ts
                function add(x: number, y: number): number {
                    return x + y;
                }

                let myAdd = function(x: number, y: number): number { return x + y; }
            ```
                事例解释：给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它
            
        1-2：书写完整的函数类型
            事例：

            ```ts
                let myAdd: (x:number, y:number) => number =
                    function(x: number, y: number): number { return x + y; }
            ```
            事例分析：
                第一步：函数类型包含两部分：参数类型和返回值类型。当写出完整函数类型的时候，这两部分都是需要的。以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。我们也可以这么写，看事例：
                    事例：

                    ```ts
                        let myAdd: (baseValue:number, increment:number) => number =
                            function(x: number, y: number): number { return x + y; }
                        // 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确
                    ```

                第二步：返回值类型。对于返回值，我们在函数和返回值类型之间使用(=>)符号，使之能够将函数类型和返回值类型区分开

                        注意点：返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空

        1-3：推断类型
            概念：在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型
            事例：

            ```ts
            // 赋值语句一边没有指定类型，但类型推断会自动将一边的类型添加上去
            let myAdd = function(x: number, y: number): number { return x + y; };

            // 添加上去之后=>定义的是返回值的类型
            let myAdd: (baseValue: number, increment: number) => number =
                function(x, y) { return x + y; };
            ```

    2-可选参数和默认参数
        2-1：可选参数：
                概念：在TypeScript里我们可以在参数名旁使用?实现可选参数的功能
                用法：可选参数必须跟在必须参数后面
                事例：让lastName为可选

                ```ts
                function buildName(firstName: string, lastName?: string) {
                    if (lastName)
                        return firstName + " " + lastName;
                    else
                        return firstName;
                }

                let result1 = buildName("Bob");  // works correctly now
                let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
                let result3 = buildName("Bob", "Adams");  // ah, just right
                ```
        
        2-2：默认参数
                概念：在typescript中，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时，默认参数类型跟默认值类型是一样的。

                用法：与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面，如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值
                事例：

                ```ts
                    function buildName(firstName = "Will", lastName: string) {
                        return firstName + " " + lastName;
                    }

                    let result1 = buildName("Bob");                  // error, too few parameters
                    let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
                    let result3 = buildName("Bob", "Adams");         // okay and returns "Bob Adams"
                    let result4 = buildName(undefined, "Adams");     // okay and returns "Will Adams"
                ```

    3-剩余参数
        概念：剩余参数会被当做个数不限的可选参数。可以一个都没有，同样也可以有任意个
        编译器创建剩余参数机制：编译器创建参数数组，名字是你在省略号（...）后面给定的名字，可以在函数体内使用这个数组
        事例：

        ```ts
            function buildName(firstName: string, ...restOfName: string[]) {
            return firstName + " " + restOfName.join(" ");
            }

            let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;
        ```

    4-this和箭头函数
        定义：在函数调用时，顶级的非方法调用会将this视为window，(在严格模式下this是undefined而不是window)
        事例：演示顶级的非方法调用

        ```ts
            let deck = {
                suits: ["hearts", "spades", "clubs", "diamonds"],
                cards: Array(52),
                createCardPicker: function() {
                    return function() {
                        let pickedCard = Math.floor(Math.random() * 52);
                        let pickedSuit = Math.floor(pickedCard / 13);
                    
                        return {suit: this.suits[pickedSuit], card: pickedCard % 13};
                    }
                }
            }

            let cardPicker = deck.createCardPicker();
            let pickedCard = cardPicker();

            alert("card: " + pickedCard.card + " of " + pickedCard.suit);
        ```
            事例解释顶级非方法调用：当cardPicker()被调用，返回一个函数，函数里面的this在不知道指向谁的情况下会指向window

        4-2：this参数
            概念：解决this指向性问题，之前this类型是any，而现在this类型被规定好了
            用法：this参数是个假的参数，它出现在参数列表的最前面
            事例：

            ```ts
                interface Card {
                    suit: string;
                    card: number;
                }
                interface Deck {
                    suits: string[];
                    cards: number[];
                    createCardPicker(this: Deck): () => Card;
                }
                let deck: Deck = {
                    suits: ["hearts", "spades", "clubs", "diamonds"],
                    cards: Array(52),
                    // NOTE: 现在，该函数明确指定其被调用方必须为Deck类型
                    //如果将这里改成this:void，ts编译器编译时会报错(因为this:void时，this是没有类型的，所以this.suits也就没有值了)
                    createCardPicker: function(this: Deck) {  
                        return () => {
                            let pickedCard = Math.floor(Math.random() * 52);
                            let pickedSuit = Math.floor(pickedCard / 13);

                            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
                        }
                    }
                }

                let cardPicker = deck.createCardPicker();
                let pickedCard = cardPicker();

                alert("card: " + pickedCard.card + " of " + pickedCard.suit);
            ```
            事例解析：现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此--noImplicitThis不会报错了

        4-3:this参数在回调函数里
            定义：给this定义类型，ts编译器会按照this的类型编译，否则编译不通过会报错
            事例：

            ```ts
                interface UIElement {
                        //接口将回调函数里的this定义为void类型
                    addClickListener(onclick: (this: void, e: Event) => void): void;
                }
                class Handler {
                    info: string;
                    onClickBad(this: Handler, e: Event) {
                        // oops, used this here. using this callback would crash at runtime
                        this.info = e.message;
                    }
                }
                let h = new Handler();
                let uiElement:UIElement;
                // 执行h.onClickBad时，编译器发现onClickBad第一个参数this:Handler类型，所以会报错
                uiElement.addClickListener(h.onClickBad); 
            ```
            事例结论：this被指定的类型，就必须按照所指定的类型操作，否则会报错

                
    5-重载
        概念：typescript里函数根据传入不同的参数而返回不同类型的数据
        事例：

        ```ts
            let suits = ["hearts", "spades", "clubs", "diamonds"];
            // 重载解释：根据参数x传入的是{suit: string; card: number; }类型还是number类型返回不同的数据类型就是重载
            function pickCard(x: {suit: string; card: number; }[]): number;
            function pickCard(x: number): {suit: string; card: number; };
            function pickCard(x): any {
                if (typeof x == "object") {
                    let pickedCard = Math.floor(Math.random() * x.length);
                    return pickedCard;
                }
                else if (typeof x == "number") {
                    let pickedSuit = Math.floor(x / 13);
                    return { suit: suits[pickedSuit], card: x % 13 };
                }
            }
            let pickedCard1 = myDeck[pickCard(myDeck)];
            alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);
            let pickedCard2 = pickCard(15);
            alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
        ```


**泛型
    1-类型变量：
        1-1概念：类型变量是一种特殊的变量，只用于表示类型而不是值
        1-2用法：用T代表类型变量
        事例：使用泛型之前

        ```ts
            function identity(arg: number): number {
                return arg;
            }
        ```
        事例：使用泛型之后

        ```ts
            function identity<T>(arg: T): T {
                return arg;
            }
        ```
        事例解释：我们给identity函数添加类型变量T，T捕获我们传入的类型，之后我们就可以用这个类型。称这样的函数为泛型函数。

        1-3泛型函数用法实例：
            第一种：传入所有参数，包含类型参数

            ```ts
                let output = identity<string>('mystring')
                // 明确的指定了T是string类型，并作为一个参数传入函数，使用了<>括起来，
            ```
            第二种：普遍方法，利用类型推论(编译器会根据传入的参数自动地帮助我们确定T的类型)

            ```ts
                let output = identity("myString");
                // 第二种没有使用尖括号（<>）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的
            ```

    2-使用泛型变量
        2-1注意点：使用泛型创建泛型函数时，编译器要求你在函数体内必须正确的使用这个通用的类型。也就是说，你必须把这些参数当做是任意或所有类型

        2-2事例：当T传入的类型不是所有参数都符合的会报错

        ```ts
            function loggingIdentity<T>(arg: T): T {
                console.log(arg.length);  // Error: T doesn't have .length
                return arg;
            }
            // 编译器会进行编译，当传入的参数是number类型时，number没有length属性，所以会报错
        ```
            2-2-1这样改之后就不会报错(增加了泛型的灵活性)

            ```ts
                function loggingIdentity<T>(arg: T[]): T[] {
                    console.log(arg.length);  // Array has a .length, so no more error
                    return arg;
                }
            ```

    3-泛型类型
        3-1概念：泛型函数和非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样
        3-2事例：定义泛型函数
        ```ts
            function identity<T>(arg: T): T {
                return arg;
            }

            let myIdentity: <T>(arg: T) => T = identity;
        ```
            3-2-1：可使用不同的泛型参数名，只要在数量上和使用方式上能对应就可以
                ```ts
                    function identity<T>(arg: T): T {
                        return arg;
                    }

                    let myIdentity: <U>(arg: U) => U = identity;
                ```

            3-2-2:可以使用带有调用签名的对象字面量来定义泛型函数
                ```ts
                    function identity<T>(arg: T): T {
                        return arg;
                    }

                    let myIdentity: {<T>(arg: T): T} = identity;
                ```
            3-2-3:注意点：带有调用签名的方式和普通方式对比
                ```ts
                    {<T>(arg: T): T} 和 <T>(arg: T) => T 对比，效果是一样的
                ```
        
        3-3：泛型作为接口
            3-3-1：事例：不指定接口泛型T的类型
            ```ts
                interface GenericIdentityFn {
                    <T>(arg: T): T;
                }
                function identity<T>(arg: T): T {
                    return arg;
                }
                let myIdentity: GenericIdentityFn = identity;
            ```
            3-3-2：事例：指定接口类型(把泛型参数当作整个接口的一个参数,这样我们就能清楚的知道使用的具体是哪个泛型类型,如Dictionary<string>而不只是Dictionary)，这样接口里的其它成员也能知道这个参数的类型了
            ```ts
                interface GenericIdentityFn<T> {
                    (arg: T): T;
                }
                function identity<T>(arg: T): T {
                    return arg;
                }
                let myIdentity: GenericIdentityFn<number> = identity
            ```

            3-3-3：注意点：除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间

    4-泛型类
        4-1：概念：泛型类看上去与泛型接口差不多。泛型类使用(<>)括起泛型类型，跟在类名后面
        4-2：事例：
            ```ts
            class GenericNumber<T> {
                zeroValue: T;
                add: (x: T, y: T) => T;
            }

            let myGenericNumber = new GenericNumber<number>();
            myGenericNumber.zeroValue = 0;
            myGenericNumber.add = function(x, y) { return x + y; };

            let stringNumeric = new GenericNumber<string>();
            stringNumeric.zeroValue = "";
            stringNumeric.add = function(x, y) { return x + y; };

            alert(stringNumeric.add(stringNumeric.zeroValue, "test"));
            ```
                事例解析：我们可以使用任何类型，不仅仅是number或string

        4-3：注意点：类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型

    5-泛型约束
        5-1：用法：定一个一个接口来描述约束条件，使用这个接口和extends关键字实现约束
                事例：
                ```ts
                    interface Lengthwise {
                        length: number;
                    }

                    function loggingIdentity<T extends Lengthwise>(arg: T): T {
                        console.log(arg.length); 
                        return arg;
                    }
                    // 我们需要传入符合约束类型的值，必须包含必须的属性
                    loggingIdentity({length:10,value:3})
                ```
        
        5-2:在泛型约束中使用类型参数
            事例：声明一个类型参数，且它被另一个类型参数所约束

            ```ts
                        // keyof T是索引类型查询操作符，对于任何类型的T，keyof T的结果为T上已知的公共属性名的联合
                function getProperty<T, K extends keyof T>(obj: T, key: K) {
                    return obj[key];
                }

                let x = { a: 1, b: 2, c: 3, d: 4 };

                getProperty(x, "a"); // okay
                getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
            ```
                事例解释：现在我们想要用属性名从对象里获取这个属性。并且要确保这个属性存在于对象obj上，因此我们需要在这两个类型之间使用约束


        5-3：在泛型里使用类类型
            事例：使用泛型创建工厂函数时，需要引用构造函数的类类型
            ```ts
                function create<T>(c: {new(): T; }): T {
                    return new c();
                }
            ```
            事例：原型属性推断并约束构造函数与类实例的关系
            ```ts
                class BeeKeeper {
                    hasMask: boolean;
                }
                class ZooKeeper {
                    nametag: string;
                }
                class Animal {
                    numLegs: number;
                }
                class Bee extends Animal {
                    keeper: BeeKeeper;
                }
                class Lion extends Animal {
                    keeper: ZooKeeper;
                }
                function createInstance<A extends Animal>(c: new () => A): A {
                    return new c();
                }
                createInstance(Lion).keeper.nametag;  // typechecks!
                createInstance(Bee).keeper.hasMask;   // typechecks!
            ```


**枚举
    概念：枚举能够给出一系列数值集合提供友好的名称，也就是说枚举表示的是一个命名元素的集合，因而它能能够使程序避免因编码的值而显得杂乱且难以维护

    1-枚举基础
        1-1:概念：默认情况下，枚举是基于0的，也就是说第一个值是0.后面的值依次递增。枚举里面的每一个值都可以指定显示，只要不出现重复的即可，没有被显示的值，都会在前一个值的基础上递增

        用法：
            实例：

            ```ts
                // 例子：不指定值默认情况下，枚举是基于0的，后面的值会递增
                enum Color {Red, Green, Blue}
                let c: Color = Color.Green;  // 1

                // 例子：当指定其中一个值时，只要不重复，没有被指定显示的值，会在前一个值的基础上递增
                enum Color {Red = 1, Green, Blue = 4}
                let c: Color = Color.Green;  // 2
            ```
            实例：向枚举传递一个数值，然后获取它对应的名称值。
            ```ts
                enum Color {Red = 1, Green, Blue}
                let colorName: string = Color[2];  // 'Green'
            ```

        1-2:枚举属性的值是被计算出来的，那么它后面一位的成员必须要初始化值

        ```ts
            const getValue = () => {
                return 0
            }

            enum List {
                A = getValue(), //A是被计算出来的
                B = 2,  // 此处必须要初始化值，不然编译不通过
                C
            }
        ```

    2-背后的JavaScript
        2-1概念：既然JavaScript中没有枚举类型，那么typescript是怎么编译枚举类型的，以使其成为一个合法的JavaScript数据类型。
        2-2原因：typescript将枚举类型编译成对象和数组的结合，这样JavaScript就可以认识了
        实例：

        ```ts
            enum Color {Red, Green, Blue}
            // 编译之后
            var Color = {};
            Color[Color['Red'] = 0] = 'Red';
            Color[Color['Green'] = 1] = 'Green';
            Color[Color['Blue'] = 2] = 'Blue';
            // 也可以写成
            var Color;
            (function (Color) {
                Color[Color["Red"] = 0] = "Red";
                Color[Color["Green"] = 1] = "Green";
                Color[Color["Blue"] = 2] = "Blue";
            })(Color || (Color = {}));
        ```

    3-const枚举
        适用场景：当我们不需要一个对象，但需要值的话，就可以使用常亮枚举
        原因：用const声明enum，在编译阶段会被删除
        ```ts
            const enum learn {
                math,
                language,
                sports
            }
            let r = learn.math
            // 经过typescript编译之后，就被删除,直接输出结果
            var r = 0
        ```

    
    4-数字枚举
        4-1概念：既可以用枚举的value来索引，又可以用枚举的key值来索引
            4-1-1:若无默认值，默认从0开始，一次递增
            ```ts
                enum learn {
                    math,
                    language,
                    sports
                }
                console.log(learn.math) //0
                console.log(learn.language) //1
                console.log(learn.sports) //2
            ```
            4-1-2:指定初始值，依次递增
            ```ts
                enum learn {
                    math=2
                    language,
                    sports
                }
                console.log(learn.math) //2
                console.log(learn.language) //3
                console.log(learn.sports) //4
            ```

    5-字符串枚举
        5-1：实例：
        ```ts
            enum learn {
                math = 0,
                fail = '失败'
            }
            // 编译之后
            var learn;
            (function(learn){
                learn[learn['math'] = 0] = 'math'
                learn['success'] = '\u6210\u529F!'
            })(learn || (learn = {}))
        ```
            5-1-1：实例反应的注意点：字符串枚举少了反向映射，就是普通的赋值，只有key和值，不可以通过value索引key值
            5-1-2：字符串的枚举，只要有一个字符串，所有的成员都得赋值
                    事例：
                        ```ts
                            enum learn {
                                success = '成功',
                                fail //如果fail不赋值，就会报错
                            }
                        ```

    6-异构枚举
        概念：混用字符串和数字枚举，不建议使用
        ```ts
            enum learn {
                math,
                success = '成功'
            }
        ```

    7-枚举成员
        7-1：成员是只读的，不可以修改
        ```ts
            enum learn {
                math =2,
                language,
                sports
            }
            learn.math  =2 //修改会报错
        ```
        7-2：枚举成员可以是常亮，也可以死活变量
        ```ts
            enum learn {
                a,
                b = 2,
                c = 1 + 3,
                e = '123'.length
            }
            learn.math  =2 //修改会报错
        ```
        7-3：枚举是在运行时存在的对象，可以传递给对象使用
        ```ts
            enum E {
                X,Y,Z
            }
            function f(obj:{X:number}):number{
                return obj.X
            }
            f(E) //返回1
        ```
    
    8-枚举合并
        概念：可以分开声明枚举，结果会自动合并，实际场景还是推荐写在一起，不推荐使用枚举合并
            
    9-外部枚举
        概念：外部枚举用来描述已经存在的枚举类型的形状
        ```ts
            declare enum Man {
                A,
                G,
                B,
                X
            }
            let man = [Man.A,Man.G,Man.B,Man.X]
            // 编译之后为
            let man = [Man.A,Man.G,Man.B,Man.X]
        ```


**类型推论
    概念：typescript里的类型推论。即，类型是在哪里如何被推断的

**类型兼容性
    1-介绍：TypeScript里的类型兼容性是基于结构类型的。结构类型是一种只使用其成员来描述类型的方式。这正好与名义类型形成对比(比如java和C都是名义类型语言)
        1-1：事例：
        ```ts
            interface Named {
                name: string;
            }

            class Person {
                name: string;
            }

            let p: Named;
                // OK, because of structural typing
            p = new Person();
        ```
            1-1-1：事例解析：在名义类型的语言，比如C#或Java中，这段代码会报错，因为Person类没有明确说明其实现了Named接口。这也是名义类型语言和结构类型语言的差别(结构类型语言，只要结果相同就可以了)

        1-2：typescript中使用结构类型语言的原因：JavaScript里广泛地使用匿名对象，例如函数表达式和对象字面量，所以使用结构类型系统来描述这些类型比使用名义类型系统更好

    2-typescript结构类型系统的基本原则：
        2-1：如果x要兼容y，那么y至少具有与x相同的属性
            事例：

            ```ts
                interface Named {
                    name: string;
                }
                let x: Named;
                // y's inferred type is { name: string; location: string; }
                let y = { name: 'Alice', location: 'Seattle' };
                x = y;
            ```
                事例执行机制：这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确

        2-2：检查函数参数时使用相同的规则：
            事例：

            ```ts
                interface Named {
                        name: string;
                }
                function greet(n: Named) {
                    console.log('Hello, ' + n.name);
                }
                let y = { name: 'Alice', location: 'Seattle' }
                greet(y); // OK
            ```
            事例执行机制：y有个额外的location属性，但这不会引发错误。只有目标类型（这里是Named）的成员会被一一检查是否兼容
        
        2-3：比较两个函数
            2-3-1：概念：在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的
            事例：我们从两个简单的函数入手，它们仅是参数列表略有不同

            ```ts
                let x = (a: number) => 0;
                let y = (b: number, s: string) => 0;

                y = x; // OK
                x = y; // Error
            ```
                事例的执行机制：事例中查看x是否能赋值给y，首先看它们的参数列表，x的每个参数必须能在y里找到对应类型的参数，所以可以赋值；因为y有个必需的第二个参数，但是x并没有，所以不允许赋值
            
            2-3-2：注意点：参数的名字相同与否无所谓，只看它们的类型

        2-4：比较返回值类型
            ```ts
                let x = () => ({name: 'Alice'});
                let y = () => ({name: 'Alice', location: 'Seattle'});

                x = y; // OK
                y = x; // Error, because x() lacks a location property
            ```
                事例解释：类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型

        2-5：类
            类的比较机制：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内

                ```ts
                    class Animal {
                        feet: number;
                        constructor(name: string, numFeet: number) { }
                    }
                    class Size {
                        feet: number;
                        constructor(numFeet: number) { }
                    }
                    let a: Animal;
                    let s: Size;
                    a = s;  // OK
                    s = a;  // OK
                ```

        2-6:泛型
            2-6-1：事例：
            ```ts
                interface Empty<T> {
                }
                let x: Empty<number>;
                let y: Empty<string>;

                x = y;  // OK, because y matches structure of x
            ```
                事例解释：因为typescript是结构性的类型系统，泛型给类型参数赋值number或者string，由于其内部没有内容，所以实际上还是如下
                    ```ts
                        interface Empty {}
                    ```
                事例加上内容如
                    ```ts
                        interface Empty<T> {
                            data:T
                        }
                        let x: Empty<number>;
                        let y: Empty<string>;
                        x = y //报错
                    ```
                        事例解析：给泛型类型参数赋值之后，其实是如下
                            ```ts
                                interface Empty {
                                    data:number
                                }
                                interface Empty {
                                    data:string
                                }
                            ```

            2-6-2:对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较
                事例：

                ```ts
                let identity = function<T>(x: T): T {
                    // ...
                }
                let reverse = function<U>(y: U): U {
                    // ...
                }
                identity = reverse;  // OK, because (x: any) => any matches (y: any) => any
                ```
                    事例解释：当没有给泛型的类型参数赋值时，会把所有泛型参数当成any比较



**高级类型
    1-交叉类型
        概念：交叉类型是将多个类型合并为一个类型。取两个类型的并集

            ```ts
                interface DogInterface {
                    run():void
                }
                interface CatInterface {
                    jump():void
                }
                    // 看上去和接口多继承很像，但有一点区别。继承可以有自己的属性，交叉不行。
                let pet: DogInterface & CatInterface = { 
                    run(){},
                    jump(){},
                };
            ```

    2-联合类型
        2-1：概念：声明的类型并不确定，可以是多个类型中的一个

            ```ts
                let a: number | string = "a"; // 类型限定
                let b: "a" | "b" | "c"; // 限定取值
                let c: 1 | 2 | 3 | "v"; // 限定取值
            ```
        2-2：事例：如果返回值值是联合类型，我们只能访问此联合类型的所有类型里的共有的成员
            ```ts
                interface Bird {
                    fly();
                    layEggs();
                }
                interface Fish {
                    swim();
                    layEggs();
                }
                function getSmallPet(): Fish | Bird {
                    // ...
                }
                let pet = getSmallPet();
                pet.layEggs(); // okay
            ```
                事例解释：返回值的类型，调用方法时，调用的方法必须在两个接口中都要有定义。因为，Bird具有一个fly成员，我们不确定一个Bird | Fish类型的变量是否有fly方法。如果变量在运行时是Fish类型，那么调用pet.fly()就出错了。所以在返回值类型使用联合类型，只能访问联合类型中的共有成员。
        

**类型保护和区分类型
    1-类型保护
        1-1：概念：类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。
        用法：定义一个函数，它的返回值是类型谓词
            ```ts
                function isFish(pet : Fish | Bird):pet is Fish {
                    return (<Fish>pet).swim !== undefined
                }
            ```
            实例解释：在这个例子中，pet is Fish就是类型谓词。谓词为parameterName is Type这种形式，parameterName必须是来自于当前函数签名里的一个参数名；
            1-1-1：类型谓词用法：
                    类型谓词判断参数是否是该类型，如果不是则返回false，反之true

                        ```ts
                            // 上面的isFish函数执行之后，我们就可以知道if分支里的pet是Fish类型；还清楚的知道else分支里，一定不是Fish类型
                            if (isFish(pet)) {
                                pet.swim();
                            }
                            else {
                                pet.fly();
                            }
                        ```

        1-2：typeOf类型保护
            1-2-1:typeOf作为类型保护的原理：typescript将typeOf识别为一个类型保护。也就是说可以直接在代码里检查类型

            1-2-2:限制：typeOf类型保护只有两种形式能被识别：typeOf v ==='typename'和 typeOf v !=='typename',typename必须是'number','string','boolean','symbol'。如果用typeOf去识别接口类型，则语言不会把表达式识别为类型保护

            事例：
            ```ts
                function padLeft(value: string, padding: string | number) {
                    if (typeof padding === "number") {
                        return Array(padding + 1).join(" ") + value;
                    }
                    if (typeof padding === "string") {
                        return padding + value;
                    }
                    throw new Error(`Expected string or number, got '${padding}'.`);
                }
            ```

        1-3：instanceOf类型保护
            概念：instanceOf类型保护是通过构造函数来细化类型的一种方式
            事例：
            ```ts
                interface Padder {
                    getPaddingString(): string
                }

                class SpaceRepeatingPadder implements Padder {
                    constructor(private numSpaces: number) { }
                    getPaddingString() {
                        return Array(this.numSpaces + 1).join(" ");
                    }
                }

                class StringPadder implements Padder {
                    constructor(private value: string) { }
                    getPaddingString() {
                        return this.value;
                    }
                }

                function getRandomPadder() {
                    return Math.random() < 0.5 ?
                        new SpaceRepeatingPadder(4) :
                        new StringPadder("  ");
                }

                // 类型为SpaceRepeatingPadder | StringPadder
                let padder: Padder = getRandomPadder();

                if (padder instanceof SpaceRepeatingPadder) {
                    padder; // 类型细化为'SpaceRepeatingPadder'
                }
                if (padder instanceof StringPadder) {
                    padder; // 类型细化为'StringPadder'
                }
            ```
            事例解释：instanceof左边是实例对象，右边是构造函数，检查实例对象是否在构造函数的原型上，来确认当前是在哪个类型上

    2-可以为null的类型
        2-1：概念：typescript具有两种特殊的类型，null和undefined，它们分别具有null和undefined的值
        2-2：用法：当你声明一个变量时，它不会自动地包含null或undefined。 你可以使用联合类型明确的包含它们
            实例：
            ```ts
                let s = "foo";
                s = null; // 错误, 'null'不能赋值给'string'
                let sn: string | null = "bar";
                sn = null; // 可以

                sn = undefined; // error, 'undefined'不能赋值给'string | null'
            ```
        2-3：注意点：TypeScript会把null和undefined区别对待。string | null，string | undefined和string | undefined | null是不同的类型
        
    3-可选参数和可选属性
        用法：可选属性会被自动地加上 | undefined
        事例1：
        ```ts
            function f(x: number, y?: number) {
                return x + (y || 0);
            }
            f(1, 2);
            f(1);
            f(1, undefined);
            f(1, null); // 错误, 'null'不能分配给number | undefined
        ```

        事例2：

        ```ts
            class C {
                a: number;
                b?: number;
            }
            let c = new C();
            c.a = 12;
            c.a = undefined; // error, 'undefined'不能分配给number
            c.b = 13;
            c.b = undefined; // ok
            c.b = null; // error, 'null'不能分配给number | undefined
        ```
                        
    4-类型保护和类型断言

    5-类型别名
        5-1：概念：类型别名会给一个类型起个新名字。类型别名有时和接口很像
        5-2：使用范围：作用域原始值，联合类型，元祖以及其它任何你需要手写的类型
        5-3：用法：
            5-3-1：实例：创建一个新名字来引用类型
            ```ts
                type Name = string;   //string类型别名Name  
                type NameResolver = () => string;   //函数类型别名 NameResolver
                type NameOrResolver = Name | NameResolver;  // 联合类型的类型别名是NameOrResolver
                function getName(n: NameOrResolver): Name {
                    if (typeof n === 'string') {
                        return n;
                    }
                    else {
                        return n();
                    }
                }
            ```

            5-3-2：实例：类型别名也可以是泛型-我们可以添加类型参数并且在别名声明的右侧传入
            ```ts
                type Container<T> = { value: T };
            ```

            5-3-3：实例：使用类型别名来在属性里引用自己
            ```ts
                type Tree<T> = {
                    value: T;
                    left: Tree<T>;
                    right: Tree<T>;
                }
            ```

            5-3-4：实例：与交叉类型使用
            ```ts
                type LinkedList<T> = T & { next: LinkedList<T> };

                interface Person {
                    name: string;
                }

                var people: LinkedList<Person>;
                var s = people.name;
                var s = people.next.name;
                var s = people.next.next.name;
                var s = people.next.next.next.name;
            ```

            5-3-5：实例：注意点：类型别名不能出现在声明右侧的任何地方
            ```ts
                type Yikes = Array<Yikes>; // error
            ```


    6-接口和类型别名的差别
            概念：接口和类型别名很多情况都相似，但也有区别的地方
        6-1：区别一：创建新的接口，可以在任何地方使用接口名字；类型别名不会创建新名字；比如：
                ```ts
                    type Alias = { num: number }  //鼠标悬停在Alias上，显示的是对象字面量
                    interface Interface {   //鼠标悬停在interface返回的是interface
                        num: number;
                    }
                ```

        6-2：类型别名不能被extends和implements
            解释：对象应该对于扩展是开发的，但是对于修改是封闭的，所以应该使用接口来替代类型别名

    7-字符串字面量类型
        7-1：概念：字符串字面量类型允许你指定字符串必须的固定值(字符串值)。在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合
        实例：

        ```ts
            type Easing = "ease-in" | "ease-out" | "ease-in-out";  //定义字符串字面量类型
            class UIElement {
                animate(dx: number, dy: number, easing: Easing) {  
                        //easing类型是字符串字面量类型只能从三种允许的字符中选择其一来做为参数传递，传入其他值会产生错误
                    if (easing === "ease-in") {
                        // ...
                    }
                    else if (easing === "ease-out") {
                    }
                    else if (easing === "ease-in-out") {
                    }
                    else {
                        // error! should not pass null or undefined.
                    }
                }
            }

            let button = new UIElement();
            button.animate(0, 0, "ease-in");
        ```

        7-2:字符串字面量类型可以区分函数重载
        ```ts
            // 使用'img'字符串字面量类型，参数tagName只能传入'img'，传入其他编译器在编译阶段会报错
            function createElement(tagName: "img"):void{ 
                console.log(tagName)
            };
        ```

    8-数字字面量类型
        8-1：事例：数字字面量类型,很少直接这样使用，到可以用于缩小范围调试
            ```ts
                function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {}
            ```

    9-可辨识联合
        概念：可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做可辨识联合的高级模式
        事例：

        ```ts
            // 首先声明三个将要联合的接口
            interface Square {
                kind: "square";
                size: number;
            }
            interface Rectangle {
                kind: "rectangle";
                width: number;
                height: number;
            }
            interface Circle {
                kind: "circle";
                radius: number;
            }
            // 将上面三个接口联合起来
            type Shape = Square | Rectangle | Circle;
            // 使用可辨识联合
            function area(s: Shape) {
                switch (s.kind) {
                    case "square": return s.size * s.size;
                    case "rectangle": return s.height * s.width;
                    case "circle": return Math.PI * s.radius ** 2;
                }
            }
        ```

    10-完整性检查
        方法：使用never类型，编译器用它来进行完整性检查
        事例：
        ```ts
        // 当传入参数不存在的类型为never
        function assertNever(x: never): never {
            throw new Error("Unexpected object: " + x);
        }
        function area(s: Shape) {
            switch (s.kind) {
                case "square": return s.size * s.size;
                case "rectangle": return s.height * s.width;
                case "circle": return Math.PI * s.radius ** 2;
                default: return assertNever(s); // error here if there are missing cases
            }
        }
        ```

    11-多态的this类型
        11-1：概念：多态的this类型表示的是某个包含类或接口的子类型。它能很容易的表现连贯接口间的继承
        11-2：事例：在每个操作之后都返回this类型

        ```ts
            class BasicCalculator {
                public constructor(protected value: number = 0) { }
                public currentValue(): number {
                    return this.value;
                }
                public add(operand: number): this {
                    this.value += operand;
                    return this;
                }
                public multiply(operand: number): this {
                    this.value *= operand;
                    return this;
                }
                // ... other operations go here ...
            }

            let v = new BasicCalculator(2)
                        .multiply(5)  
                        .add(1)
                        .currentValue();
        ```
            事例执行逻辑解释：实例方法返回this类型，调用mutiply方法，返回this也就是本实例对象，才可以继续调用下面的方法
    
    12-索引类型
        12-1：概念：使用索引类型，编译器就能够检查使用了动态属性名的代码
        12-2：涉及知识点：
                12-2-1：索引类型查询操作符：keyof T是索引类型查询操作符；对于任何类型T，keyof T的结果为T上已知的公共属性名的联合
                    实例：
                    ```ts
                        interface Person {
                            name: string;
                            age: number;
                        }
                        let personProps: keyof Person; // 'name' | 'age'
                    ```
                    事例知识点：keyof Person; 返回结果为 'name' | 'age'
                
                12-2-2：索引访问操作符：T[k]
                    ```ts
                        function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
                            return o[name]; // o[name] is of type T[K]
                        }
                    ```

    13-索引类型和字符串索引签名
        概念：keyof和T[K]与字符串索引签名进行交互。如果你有一个带有字符串索引签名的类型，那么keyof T会是string
        事例：
        ```ts
            interface Map<T> {
                [key: string]: T;
            }
            let keys: keyof Map<number>; // string
            let value: Map<number>['foo']; // number
        ```

    14-映射类型
        概念：typescript提供了从旧类型中创建新类型的一种方式叫映射类型。在映射类型里，新类型以相同的形式去转换旧类型里的每个属性。
        事例：最简单的映射类型和它的组成部分

        ```ts
            type Keys = 'option1' | 'option2';
            type Flags = { [K in Keys]: boolean };

            // 最终生成的结果为
            type Flags = {
                option1: boolean;
                option2: boolean;
            }
        ```
        事例执行机制：映射内部的语法与索引签名的语法类似，内部使用了for...in；映射通俗的说就是复制
        


