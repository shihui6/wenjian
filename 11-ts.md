**安装typescript
    1-有俩种主要的方式来获取typescript工具
        1-1：通过npm安装 (npm install -g typescript)
        1-2：安装vscode的typescript插件 (vscode2017和vscode2015 Update 3默认包含了TypeScript)

**编译代码
    在typescript中尽可能是用let来代替var
    1-概念：在.ts扩展名的命令行上运行typescript编译器
    2-用法：tsc + ts文件
    实例：

        ```ts
            tsc greeter.ts  //输出结果为一个greeter.js文件
        ```

**基础类型
    1-布尔值

    ```ts
        let isDone:boolen = false 
    ```

    2-数字
    概念：和JavaScript一样，typescript里的所有数字都是浮点数。这些浮点数的类型是number。除了支持十进制和十六进制字面量，typescript还支持ECMAScript2015中引入的二进制和八进制字面量

    ```ts
        let dec:number = 20
        let dec:number = 0x14 16进制表示法
        let dec:number = 0b10100  2进制表示法
        let dec:number = 0o24 8进制表示法
    ```

    3-字符串
        3-1概念：使用string表示文本数据类型
        3-2用法：
            3-2-1：可以使用双引号或单引号表示字符串
            3-2-2：使用模板字符串，定义多行文本和内嵌表达式。这种字符串是被反引号`包围
            实例：

            ```ts
                let name:string = 'bob'
                let sentence:string = `hello,my name ${name}`
            ```
    
    4-数组
        4-1：数组类型用法：
            4-1-1：在元素类型后面接上[]，表示由此类型元素组成的一个数组
            4-1-2：数组泛型，Array<元素类型>
            实例：

            ```ts
                let list:number[]=[1,2,3,4] 数字类型的数组
                let list:Array<number> = [1,2,3,4]  数组泛型
            ```

    5-元祖Tuple
        5-1：概念：
            5-1-1：元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同
            实例：

            ```ts
                let x:[string,number]  
                x=['hello',10]
            ```
            实例解释注意点：定义x数组，第一个数据是字符串第二个数字是数字，顺序类型严格要求

            5-1-2：当访问一个已知索引的元素，会得到正确的类型对应的值
            5-1-3：当访问一个越界元素，会使用联合类型替代
            实例：

            ```ts
                let x:[string,number]  
                x=['hello',10]
                x[3] = 'world'  //hello,字符串可以赋值给(string | number)类型，此类型为联合类型
                x[4] = true //会报错：因为布尔值，不是(string | number)类型
            ```
                实例解释：当添加一个联合类型里没有的类型，则会报错

    6-枚举
        6-1：概念：enum类型是对JavaScript标准数据类型的一个补充。使用枚举类型可以为一组数值赋予友好的名字
        6-2：用法：枚举类型提供的一个便利是你可以由枚举的值得到它的名字。
            6-2-1：实例：我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字

            ```ts
                enum Color {Red = 1, Green, Blue}
                let colorName: string = Color[2];
                alert(colorName);  // 显示'Green'因为上面代码里它的值是2 
            ```
            6-2-2：Color默认的对应的枚举值为0,1,2，可以通过点的方式取到枚举值，也可以通过枚举值找到对应的名字值、
            实例：

            ```ts
                enum Color{
                    Red,
                    Green,
                    Blue
                }
            ```

    7-any
        7-1：概念：在某些情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量
            实例：

            ```ts
                let list:any[] =  [1,'yee',false]
                let notSure:any = 4
                notSure = 'maybe'
            ```
            实例解释：any类型，编译器允许你在编译时可选择地包含或移除类型检查
        7-2：any类型和Object类型比较，你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法
            实例：

            ```ts
                let notSure: any = 4;
                notSure.ifItExists(); // okay, ifItExists might exist at runtime
                notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

                let prettySure: Object = 4;
                prettySure.toFixed(); // 报错: 类型对象上不存在toFixed()属性，即便它真的有这些方法
            ```

    8-void
        8-1：概念：
            8-1-1：某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void
            实例：

            ```ts
                function warn():void {   没有任何返回值的函数
                    console.log('this is my waring message')
                }
            ```
            8-1-2：声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null
            实例：

            ```ts
                let unusable: void = undefined;
            ```

    9-null和undefined
        概念：TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null

        ```ts  是所有类型的子类型
            let u:undefined = undefined
            let u:null = null
        ```
    
    10-never
        10-1：概念：
            10-1-1：never类型表示的是那些永不存在的值的类型
            10-1-2：必须是不能返回的或者是报错的或不能结束的
        10-2：用法：
            10-2-1：返回never的函数抛出异常

            ```ts
                function error(message: string): never {
                    throw new Error(message);
                }
            ```

            10-2-2：推断的返回值类型为never

            ```ts
                function fail() {
                    return error("Something failed");
                }
            ```
            10-2-3:返回never的函数必须存在无法达到的终点

            ```ts
            function infiniteLoop(): never {
                while (true) {
                }
            }
            ```

    11-类型断言(类型断言或者类型转换)
        11-1:概念：类型转换
        11-2:类型断言执行机制：告诉编译器，进行数据类型转换，不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用
        11-3：用法：类型断言有两种方式
            11-3-1：尖括号语法

            ```ts
            let someValue: any = "this is a string";
            let strLength: number = (<string>someValue).length;   //将someValue强制转换成string类型
            ```
            11-3-2：as语法

            ```ts
            let someValue: any = "this is a string";
            let strLength: number = (someValue as string).length; //将someValue强制转换成string类型
            ```

        注意点：当你在TypeScript里使用JSX时，只有as语法断言是被允许的



**接口
    概念：对值所具有的结构进行类型检查，为这些类型命名和为你的代码或第三方代码定义契约

    1-接口初探
        实例：

        ```ts
            interface LabelledValue {
                label: string;
            }
            function printLabel(labelledObj: LabelledValue) {
                console.log(labelledObj.label);
            }
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
        ```
        实例解释：LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表printLabel函数参数中有一个label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的

        注意点：类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以

    2-可选属性
        2-1：概念：接口里的属性不全都是必需的。有些是只在某些条件下存在，或者根本不存在。即给函数传入的参数对象中只有部分属性赋值了
        2-2：用法：带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号
        2-3：用可选属性的原因：
                2-3-1：对可能存在的属性进行预定义
                2-3-2：捕获引用了不存在的属性时的错误
            实例：

            ```ts
                interface SquareConfig {
                    color?:string;
                    width?:number
                }
                function createSquare(config:SquareConfig):Square {
                    let newSquare = {color:'white',area:100}
                    if(config.color){   
                        newSquare.color = config.clor  //报错：参数的属性中没有接口中定义的属性时会报错
                    }
                    return newSquare
                }
                let mySquare = createSquare(config:{color:'black'})

            ```
        
    3-只读属性
        3-1:概念：一些对象属性只能在对象初始化的时候修改其质
        3-2:用法：
            3-2-1：在属性名前用readonly来指定只读属性
            3-2-2：通过ReadonlyArray<T>指定只读
        3-3:实例：
            3-3-1:通过赋值一个对象字面量来构造一个Point，赋值后，x和y再也不能被改变了

            ```ts
                interface Point {   
                    readonly X:number
                    readonly y:number
                }
                let p1: Point = { x: 10, y: 20 };
                p1.x = 5; // error!
            ```
            3-3-2:TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改

            ```ts
                let a: number[] = [1, 2, 3, 4];
                let ro: ReadonlyArray<number> = a;
                ro[0] = 12; // error!
                ro.push(5); // error!
                ro.length = 100; // error!
                a = ro; // error!
            ```
                实例解释：ro赋值到一个普通数组也是不可以的，但是可以通过类型断言重写如

                ```ts
                    a = ro as number[]
                ```


    4-额外属性检查
        4-1概念：对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何'目标类型'不包含的属性时，会得到一个错误
        4-2用法：在接口中添加一个字符串索引签名，前提是能够确定这个对象可能具有某些做为特殊用途使用的额外属性

        实例：如果SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它

            ```ts
                interface SquareConfig {
                    color?: string;
                    width?: number;
                    [propName: string]: any;
                }
            ```
            实例解释：SquareConfig表示任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么


    5-函数类型
        5-1:概念：接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型
        5-2:用法：
            5-2-1:用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                } 
            ```
            5-2-2:对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                }
                let mySearch: SearchFunc;
                mySearch = function(src: string, sub: string): boolean {
                let result = src.search(sub);
                return result > -1;
                }
            ```
            5-2-3:不想指定类型

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                }
                let mySearch: SearchFunc;
                mySearch = function(src, sub) {
                    let result = src.search(sub);
                    return result > -1;
                }
            ```
                实例解释：TypeScript的类型系统会推断出参数类型,因为函数直接赋值给了SearchFunc类型变量。函数的参数和返回值类型是通过SearchFunc函数接口推断出来的


    6-可索引类型
        6-1：概念：与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型
        6-2：用法：
            6-2-1：可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型
            实例：我们定义了StringArray接口，它具有索引签名。这个索引签名表示了当用number去索引StringArray时会得到string类型的返回值

            ```ts
                interface StringArray {
                [index: number]: string;
                }

                let myArray: StringArray;
                myArray = ["Bob", "Fred"];

                let myStr: string = myArray[0];
            ```
            6-2-2：支持两种索引签名：字符串和数字
                注意点：可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型
                注意点解释：因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致

            6-2-3:当name的类型与字符串索引类型不匹配,类型检查器会给出一个错误提示

                ```ts
                    interface NumberDictionary {
                    [index: string]: number;
                    length: number;    // 可以，length是number类型
                    name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
                    }
                ```
                实例解释：字符串索引签名能够很好的描述dictionary(接口)模式，并且它们也会确保所有属性与其返回值类型相匹配。因为字符串索引声明了obj.property和obj["property"]两种形式都可以

            6-2-4：将索引签名设置为只读

                ```ts
                    interface ReadonlyStringArray {
                        readonly [index: number]: string;
                    }
                    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
                    myArray[2] = "Mallory"; // error!
                ```


    7-类类型
        7-1:实现接口
            概念：与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约
            实例：

            ```ts
                interface ClockInterface {
                    currentTime: Date;
                }

                class Clock implements ClockInterface {
                    currentTime: Date;
                    constructor(h: number, m: number) { }
                }
            ```
            7-1-1：在接口中描述一个方法，在类里实现它
            实例;在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样

            ```ts
                interface ClockInterface {
                    currentTime: Date;
                    setTime(d: Date);
                }

                class Clock implements ClockInterface {
                    currentTime: Date;
                    setTime(d: Date) {
                        this.currentTime = d;
                    }
                    constructor(h: number, m: number) { }
                }
            ```
            7-1-2:注意点：接口描述类的公共部分，而不是公共和私有两部分，它不会帮你检查类是否具有某些私有成员

        7-2：类静态部分与实例部分的区别
            概念说明：类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误

            概念解释：当一个类实现一个接口时，只对其实例部分进行类型检查。constructor存在于类的静态部分，所以不在检查范围内
            实例：

            ```ts
                interface ClockConstructor { 定义构造器的接口或者静态部分的接口
                    new (hour: number, minute: number): ClockInterface;
                }
                interface ClockInterface {  定义实例接口
                    tick();
                }
            
                function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
                    return new ctor(hour, minute);
                }
                class DigitalClock implements ClockInterface {
                    constructor(h: number, m: number) { }
                    tick() {
                        console.log("beep beep");
                    }
                }
                class AnalogClock implements ClockInterface {
                    constructor(h: number, m: number) { }
                    tick() {
                        console.log("tick tock");
                    }
                }

                let digital = createClock(DigitalClock, 12, 17);
                let analog = createClock(AnalogClock, 7, 32);
            ```
            实例执行机制：DigitalClock类作为参数传入createClock时被定义的接口ClockConstructor进行限制，后面执行中需要遵守ClockConstructor接口类型

            实例执行机制补充说明：由于类型编译器不会对静态成员进行类检查，当createClock参数ctor限定类型为ClockConstructor，当DigitalClock类传入的时，判断该参数在执行new操作之后返回的类型是否满足接口类型限制
    
    8-继承接口
        8-1概念：和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里
        8-2:实例：
            8-2-1:实现一个简单的接口继承

            ```ts
                interface Shape {
                    color: string;
                }

                interface Square extends Shape {
                    sideLength: number;
                }

                let square = <Square>{};
                square.color = "blue";
                square.sideLength = 10;
            ```
            8-2-2:实现一个接口可以继承多个接口，创建出多个接口的合成接口

            ```ts
                interface Shape {
                    color: string;
                }

                interface PenStroke {
                    penWidth: number;
                }

                interface Square extends Shape, PenStroke {
                    sideLength: number;
                }

                let square = <Square>{};
                square.color = "blue";
                square.sideLength = 10;
                square.penWidth = 5.0;
            ```

    9-混合类型
        概念：一个对象可以同时具有上面提到的多种类型
        实例：一个对象可以同时做为函数和对象使用，并带有额外的属性

        ```ts
            interface Counter {
                (start: number): string;
                interval: number;
                reset(): void;
            }

            function getCounter(): Counter {
                let counter = <Counter>function (start: number) { };
                counter.interval = 123;
                counter.reset = function () { };
                return counter;
            }

            let c = getCounter();
            c(10);
            c.reset();
            c.interval = 5.0;
        ```

    10-接口继承类
        10-1:概念：
            10-1-1：当接口继承了一个类类型时，它会继承类的成员但不包括其实现
            10-1-2：接口同样会继承到类的private和protected成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现
            实例：

            ```ts
                class Control {
                    private state: any;
                }
                interface SelectableControl extends Control {
                    select(): void;
                }
                class Button extends Control implements SelectableControl { 
                    select() { }
                }
                class TextBox extends Control {

                }
            ```
                实例解释：SelectableControl包含了Control的所有成员，包括私有成员state。因为state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。因为只有Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的

        

**类
    1-公有，私有与保护的修饰符
        1-1：public概念：在typescript里，成员都默认为public
             实例：明确的将每个成员标记成public。

            ```ts
                class Animal {
                    public name: string;
                    public constructor(theName: string) { this.name = theName; }
                    public move(distanceInMeters: number) {
                        console.log(`${this.name} moved ${distanceInMeters}m.`);
                    }
                }
            ```
        
        1-2:private
            定义：
                1-2-1：当成员被标记成private时，它就不能在声明它的类的外部访问
                实例：

                ```ts
                class Animal {
                    private name: string;
                    constructor(theName: string) { this.name = theName; }
                }
                new Animal("Cat").name; // 错误: 'name' 是私有的.
                ```
                实例解释：Animal类私有成员name，不能在类的外部访问哪怕是这个了的实例对象

                1-2-2：typescript使用的是结构性类型系统当我们比较两种不同的类型时，并不在乎它们从何而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的
                        1-2-2-1：注意点：当在比较带有private或protected成员的类型的时候，情况就不同了。如果其中一个类型里包含一个private成员，那么只有当另外一个类型中也存在这样的一个private成员，并且它们都是来此同一处声明，我们才认为这两个类型是兼容的。对于protected成员也是这个规则
                        实例：

                        ```ts
                        class Animal {
                            private name: string;
                            constructor(theName: string) { this.name = theName; }
                        }
                        class Rhino extends Animal {
                            constructor() { super("Rhino"); }
                        }
                        class Employee {
                            private name: string;
                            constructor(theName: string) { this.name = theName; }
                        }
                        let animal = new Animal("Goat");
                        let rhino = new Rhino();
                        let employee = new Employee("Bob");
                        animal = rhino;   
                        animal = employee; // 错误: Animal 与 Employee 不兼容.
                        ```
                        实例解释：因为Animal和Rhino共享了来自Animal里的私有成员定义private name: string,因此它们是兼容的(才有它们的实例animal=rhino)；而Employee里也有一个私有成员name，但它明显不是Animal里面定义的那个，所以当把Employee赋值给Animal的时候，得到一个错误，说明它们的类型不兼容

        1-3：protected
             1-3-1：定义：
                1-3-1-1：protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问
                实例：

                ```ts
                class Person {
                    protected name: string;
                    constructor(name: string) { this.name = name; }
                }

                class Employee extends Person {
                    private department: string;

                    constructor(name: string, department: string) {
                        super(name)
                        this.department = department;
                    }

                    public getElevatorPitch() {
                        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
                    }
                }
                let howard = new Employee("Howard", "Sales");
                console.log(howard.getElevatorPitch());
                console.log(howard.name); // 报错，不能在实例中访问，可以在实例中访问方法，此方法可以访问该被protected的属性
                ```
                1-3-1-2：构造函数也可以被标记成protected。意味着这个类不能在包含它的类外被实例化，但是能被继承
                实例：

                ```ts
                class Person {
                    protected name: string;
                    protected constructor(theName: string) { this.name = theName; }  //Person构造函数是被保护的
                }
                // Employee 能够继承 Person
                class Employee extends Person {
                    private department: string;
                    constructor(name: string, department: string) {
                        super(name);
                        this.department = department;
                    }
                    public getElevatorPitch() {
                        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
                    }
                }
                let howard = new Employee("Howard", "Sales");
                let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的.
                ```

        1-4：readonly修饰符
                定义：readonly关键字将属性设置为只读。
                注意点：只读属性必须在声明时或构造函数里被初始化
                实例：

                ```ts
                    class Octopus {
                        readonly name: string;
                        readonly numberOfLegs: number = 8;
                        constructor (theName: string) {
                            this.name = theName;
                        }
                    }
                    let dad = new Octopus("Man with the 8 strong legs"); //构造函数时初始化name只读属性
                    dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
                ```
        
        1-5：参数属性
                1-5-1：概念：参数属性通过给构造函数参数添加一个访问限定符来声明
                1-5-2：作用：使用private限定一个参数属性会声明并初始化一个私有成员；对于public和protected来说也是一样
                实例：

                ```ts
                //没有用参数属性
                class Animal {
                    private name: string;
                    constructor(theName: string) { this.name = theName; }
                }
                // 使用了参数属性
                class Animal {
                    //在构造函数里使用private name: string参数来创建和初始化name成员。把声明和赋值合并至一处
                    constructor(private name: string) { }  
                    move(distanceInMeters: number) {
                        console.log(`${this.name} moved ${distanceInMeters}m.`);
                    }
                }
                ```

        1-6：存取器
                1-6-1：概念：typescript支持通过getters/setters来截取对对象成员的访问。
                1-6-2：作用：它能帮助你有效的控制对对象成员的访问
                实例：把一个简单的类改写成使用get和set

                ```ts
                // 没有使用存取器的例子
                class Employee {
                    fullName: string;
                }
                let employee = new Employee();
                employee.fullName = "Bob Smith";
                if (employee.fullName) {
                    console.log(employee.fullName);
                }
                // 对上面的例子使用存取器(先检查用户密码是否正确，然后再允许其修改员工信息)
                let passcode = "secret passcode";
                class Employee {
                    private _fullName: string;
                    get fullName(): string {
                        return this._fullName;
                    }
                    set fullName(newName: string) {
                        if (passcode && passcode == "secret passcode") {
                            this._fullName = newName;
                        }
                        else {
                            console.log("Error: Unauthorized update of employee!");
                        }
                    }
                }
                let employee = new Employee();
                employee.fullName = "Bob Smith";
                if (employee.fullName) {
                    alert(employee.fullName);
                }
                ```
                    事例使用存取器改写之后的解释：我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工
                1-6-3：注意点：
                    1-6-3-1：存取器要求编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3
                    1-6-3-2：只带有get不带有set的存取器自动被推断为readonly

        1-7：静态属性
            1-7-1:概念：
                1-7-1-1:实例成员：那些仅当类被实例化的时候才会被初始化的属性
                1-7-1-2:静态成员：这些属性存在于类本身上面而不是类的实例上
            1-7-2用法：使用static定义属性，在类中使用this调用该属性
            事例：

            ```ts
            class Grid {
                static origin = {x: 0, y: 0};
                calculateDistanceFromOrigin(point: {x: number; y: number;}) {
                    let xDist = (point.x - Grid.origin.x);
                    let yDist = (point.y - Grid.origin.y);
                    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
                }
                constructor (public scale: number) { }
            }

            let grid1 = new Grid(1.0);  // 1x scale
            let grid2 = new Grid(5.0);  // 5x scale

            console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
            console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
            ```

        1-8:抽象类
            1-8-1：概念：抽象类做为其它派生类的基类使用。它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节

            1-8-2：用法：abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法

            1-8-3：注意点：
                   1-8-3-1：抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。
                   1-8-3-2：抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含abstract关键字并且可以包含访问修饰符
                   1-8-3-3：抽象类无法实例化；接口可以理解为抽象类的子集
            事例：

            ```ts
                abstract class Department {
                    constructor(public name: string) {
                    }
                    printName(): void {
                        console.log('Department name: ' + this.name);
                    }
                    abstract printMeeting(): void; // 必须在派生类中实现
                }
                // 理解点：上面的抽象类实际上也是下面这种形式
                // interface Department {
                //     name:string;
                //     printName(): void 
                //     printMeeting(): void; 
                // }
        
                class AccountingDepartment extends Department {
                    constructor() {
                        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
                    }
                    printMeeting(): void {
                        console.log('The Accounting Department meets each Monday at 10am.');
                    }
                    generateReports(): void {
                        console.log('Generating accounting reports...');
                    }
                }
                // 允许创建一个对抽象类型的引用  
                // department: Department意思是department实现Department(类或抽象类可以当接口使用，将类转换成接口就是对象的形式)
                let department: Department; 
                department = new Department(); // 错误: 不能创建一个抽象类的实例
                department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
                department.printName();
                department.printMeeting();
                department.generateReports(); // 错误: 方法在声明的抽象类中不存在
            ```
            事例解释：抽象类和接口用法相似，但抽象类中可以包含成员的具体实现。Department意思是department实现Department(类或抽象类可以当接口使用，将类转换成接口就是对象的形式)


    2-高级技巧
        2-1：把类当做接口使用
            2-1-1:概念：类定义会创建两个东西：类的实例类型和一个构造函数
                事例：

                ```ts
                    class Greeter {
                        static standardGreeting = "Hello, there";
                        greeting: string;
                        greet() {
                            if (this.greeting) {
                                return "Hello, " + this.greeting;
                            }
                            else {
                                return Greeter.standardGreeting;
                            }
                        }
                    }
                    let greeter1: Greeter;
                    greeter1 = new Greeter();
                    console.log(greeter1.greet());

                    let greeterMaker: typeof Greeter = Greeter;
                    greeterMaker.standardGreeting = "Hey there!";

                    let greeter2: Greeter = new greeterMaker();
                    console.log(greeter2.greet());
                ```
                事例解释(let greeterMaker: typeOf Greeter = Greeter的解释)：创建了一个叫做greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用typeof Greeter(typeOf和定义接口类型的方式是一样的)，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。

            2-1-2:原因：因为类可以创建出类型，所以你能够在允许使用接口的地方使用类

            ```ts
            class Point {
                x: number;
                y: number;
            }
            interface Point3d extends Point {
                z: number;
            }
            let point3d: Point3d = {x: 1, y: 2, z: 3};
            ```


**函数
    1-函数类型
        1-1：为函数定义类型
            事例：

            ```ts
                function add(x: number, y: number): number {
                    return x + y;
                }

                let myAdd = function(x: number, y: number): number { return x + y; }
            ```
                事例解释：给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它
            
        1-2：书写完整的函数类型
            事例：

            ```ts
                let myAdd: (x:number, y:number) => number =
                    function(x: number, y: number): number { return x + y; }
            ```
            事例分析：
                第一步：函数类型包含两部分：参数类型和返回值类型。当写出完整函数类型的时候，这两部分都是需要的。以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。这个名字只是为了增加可读性。我们也可以这么写，看事例：
                    事例：

                    ```ts
                        let myAdd: (baseValue:number, increment:number) => number =
                            function(x: number, y: number): number { return x + y; }
                        // 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确
                    ```

                第二步：返回值类型。对于返回值，我们在函数和返回值类型之间使用(=>)符号，使之能够将函数类型和返回值类型区分开

                        注意点：返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空

        1-3：推断类型
            概念：在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型
            事例：

            ```ts
            // 赋值语句一边没有指定类型，但类型推断会自动将一边的类型添加上去
            let myAdd = function(x: number, y: number): number { return x + y; };

            // 添加上去之后=>定义的是返回值的类型
            let myAdd: (baseValue: number, increment: number) => number =
                function(x, y) { return x + y; };
            ```

    2-可选参数和默认参数
        2-1：可选参数：
                概念：在TypeScript里我们可以在参数名旁使用?实现可选参数的功能
                用法：可选参数必须跟在必须参数后面
                事例：让lastName为可选

                ```ts
                function buildName(firstName: string, lastName?: string) {
                    if (lastName)
                        return firstName + " " + lastName;
                    else
                        return firstName;
                }

                let result1 = buildName("Bob");  // works correctly now
                let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
                let result3 = buildName("Bob", "Adams");  // ah, just right
                ```
        
        2-2：默认参数
                概念：在typescript中，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时，默认参数类型跟默认值类型是一样的。

                用法：与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面，如果带默认值的参数出现在必须参数前面，用户必须明确的传入undefined值来获得默认值
                事例：

                ```ts
                    function buildName(firstName = "Will", lastName: string) {
                        return firstName + " " + lastName;
                    }

                    let result1 = buildName("Bob");                  // error, too few parameters
                    let result2 = buildName("Bob", "Adams", "Sr.");  // error, too many parameters
                    let result3 = buildName("Bob", "Adams");         // okay and returns "Bob Adams"
                    let result4 = buildName(undefined, "Adams");     // okay and returns "Will Adams"
                ```

    3-剩余参数
        概念：剩余参数会被当做个数不限的可选参数。可以一个都没有，同样也可以有任意个
        编译器创建剩余参数机制：编译器创建参数数组，名字是你在省略号（...）后面给定的名字，可以在函数体内使用这个数组
        事例：

        ```ts
            function buildName(firstName: string, ...restOfName: string[]) {
            return firstName + " " + restOfName.join(" ");
            }

            let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;
        ```

    4-this和箭头函数
        定义：在函数调用时，顶级的非方法调用会将this视为window，(在严格模式下this是undefined而不是window)
        事例：演示顶级的非方法调用

        ```ts
            let deck = {
                suits: ["hearts", "spades", "clubs", "diamonds"],
                cards: Array(52),
                createCardPicker: function() {
                    return function() {
                        let pickedCard = Math.floor(Math.random() * 52);
                        let pickedSuit = Math.floor(pickedCard / 13);
                    
                        return {suit: this.suits[pickedSuit], card: pickedCard % 13};
                    }
                }
            }

            let cardPicker = deck.createCardPicker();
            let pickedCard = cardPicker();

            alert("card: " + pickedCard.card + " of " + pickedCard.suit);
        ```
            事例解释顶级非方法调用：当cardPicker()被调用，返回一个函数，函数里面的this在不知道指向谁的情况下会指向window

        4-2：this参数
            概念：解决this指向性问题，之前this类型是any，而现在this类型被规定好了
            用法：this参数是个假的参数，它出现在参数列表的最前面
            事例：

            ```ts
                interface Card {
                    suit: string;
                    card: number;
                }
                interface Deck {
                    suits: string[];
                    cards: number[];
                    createCardPicker(this: Deck): () => Card;
                }
                let deck: Deck = {
                    suits: ["hearts", "spades", "clubs", "diamonds"],
                    cards: Array(52),
                    // NOTE: 现在，该函数明确指定其被调用方必须为Deck类型
                    //如果将这里改成this:void，ts编译器编译时会报错(因为this:void时，this是没有类型的，所以this.suits也就没有值了)
                    createCardPicker: function(this: Deck) {  
                        return () => {
                            let pickedCard = Math.floor(Math.random() * 52);
                            let pickedSuit = Math.floor(pickedCard / 13);

                            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
                        }
                    }
                }

                let cardPicker = deck.createCardPicker();
                let pickedCard = cardPicker();

                alert("card: " + pickedCard.card + " of " + pickedCard.suit);
            ```
            事例解析：现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此--noImplicitThis不会报错了

        4-3:this参数在回调函数里
            定义：给this定义类型，ts编译器会按照this的类型编译，否则编译不通过会报错
            事例：

            ```ts
                interface UIElement {
                        //接口将回调函数里的this定义为void类型
                    addClickListener(onclick: (this: void, e: Event) => void): void;
                }
                class Handler {
                    info: string;
                    onClickBad(this: Handler, e: Event) {
                        // oops, used this here. using this callback would crash at runtime
                        this.info = e.message;
                    }
                }
                let h = new Handler();
                let uiElement:UIElement;
                // 执行h.onClickBad时，编译器发现onClickBad第一个参数this:Handler类型，所以会报错
                uiElement.addClickListener(h.onClickBad); 
            ```
            事例结论：this被指定的类型，就必须按照所指定的类型操作，否则会报错

                
    5-重载
        概念：typescript里函数根据传入不同的参数而返回不同类型的数据
        事例：

        ```ts
            let suits = ["hearts", "spades", "clubs", "diamonds"];
            // 重载解释：根据参数x传入的是{suit: string; card: number; }类型还是number类型返回不同的数据类型就是重载
            function pickCard(x: {suit: string; card: number; }[]): number;
            function pickCard(x: number): {suit: string; card: number; };
            function pickCard(x): any {
                if (typeof x == "object") {
                    let pickedCard = Math.floor(Math.random() * x.length);
                    return pickedCard;
                }
                else if (typeof x == "number") {
                    let pickedSuit = Math.floor(x / 13);
                    return { suit: suits[pickedSuit], card: x % 13 };
                }
            }
            let pickedCard1 = myDeck[pickCard(myDeck)];
            alert("card: " + pickedCard1.card + " of " + pickedCard1.suit);
            let pickedCard2 = pickCard(15);
            alert("card: " + pickedCard2.card + " of " + pickedCard2.suit);
        ```


**泛型
    1-类型变量：
        1-1概念：类型变量是一种特殊的变量，只用于表示类型而不是值
        1-2用法：用T代表类型变量
        事例：使用泛型之前

        ```ts
            function identity(arg: number): number {
                return arg;
            }
        ```
        事例：使用泛型之后

        ```ts
            function identity<T>(arg: T): T {
                return arg;
            }
        ```
        事例解释：我们给identity函数添加类型变量T，T捕获我们传入的类型，之后我们就可以用这个类型。称这样的函数为泛型函数。

        1-3泛型函数用法实例：
            第一种：传入所有参数，包含类型参数

            ```ts
                let output = identity<string>('mystring')
                // 明确的指定了T是string类型，并作为一个参数传入函数，使用了<>括起来，
            ```
            第二种：普遍方法，利用类型推论(编译器会根据传入的参数自动地帮助我们确定T的类型)

            ```ts
                let output = identity("myString");
                // 第二种没有使用尖括号（<>）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的
            ```

    2-使用泛型变量
        2-1注意点：使用泛型创建泛型函数时，编译器要求你在函数体内必须正确的使用这个通用的类型。也就是说，你必须把这些参数当做是任意或所有类型

        2-2事例：当T传入的类型不是所有参数都符合的会报错

        ```ts
            function loggingIdentity<T>(arg: T): T {
                console.log(arg.length);  // Error: T doesn't have .length
                return arg;
            }
            // 编译器会进行编译，当传入的参数是number类型时，number没有length属性，所以会报错
        ```
            2-2-1这样改之后就不会报错(增加了泛型的灵活性)

            ```ts
                function loggingIdentity<T>(arg: T[]): T[] {
                    console.log(arg.length);  // Array has a .length, so no more error
                    return arg;
                }
            ```

    3-泛型类型
        3-1概念：泛型函数和非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样
        3-2事例：定义泛型函数
        ```ts
            function identity<T>(arg: T): T {
                return arg;
            }

            let myIdentity: <T>(arg: T) => T = identity;
        ```
            3-2-1：可使用不同的泛型参数名，只要在数量上和使用方式上能对应就可以
                ```ts
                    function identity<T>(arg: T): T {
                        return arg;
                    }

                    let myIdentity: <U>(arg: U) => U = identity;
                ```

            3-2-2:可以使用带有调用签名的对象字面量来定义泛型函数
                ```ts
                    function identity<T>(arg: T): T {
                        return arg;
                    }

                    let myIdentity: {<T>(arg: T): T} = identity;
                ```
            3-2-3:注意点：带有调用签名的方式和普通方式对比
                ```ts
                    {<T>(arg: T): T} 和 <T>(arg: T) => T 对比，效果是一样的
                ```
        
        3-3：泛型作为接口
            3-3-1：事例：不指定接口泛型T的类型
            ```ts
                interface GenericIdentityFn {
                    <T>(arg: T): T;
                }
                function identity<T>(arg: T): T {
                    return arg;
                }
                let myIdentity: GenericIdentityFn = identity;
            ```
            3-3-2：事例：指定接口类型(把泛型参数当作整个接口的一个参数,这样我们就能清楚的知道使用的具体是哪个泛型类型,如Dictionary<string>而不只是Dictionary)，这样接口里的其它成员也能知道这个参数的类型了
            ```ts
                interface GenericIdentityFn<T> {
                    (arg: T): T;
                }
                function identity<T>(arg: T): T {
                    return arg;
                }
                let myIdentity: GenericIdentityFn<number> = identity
            ```

            3-3-3：注意点：除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间

    4-泛型类
        4-1：概念：泛型类看上去与泛型接口差不多。泛型类使用(<>)括起泛型类型，跟在类名后面
        4-2：事例：
            ```ts
            class GenericNumber<T> {
                zeroValue: T;
                add: (x: T, y: T) => T;
            }

            let myGenericNumber = new GenericNumber<number>();
            myGenericNumber.zeroValue = 0;
            myGenericNumber.add = function(x, y) { return x + y; };

            let stringNumeric = new GenericNumber<string>();
            stringNumeric.zeroValue = "";
            stringNumeric.add = function(x, y) { return x + y; };

            alert(stringNumeric.add(stringNumeric.zeroValue, "test"));
            ```
                事例解析：我们可以使用任何类型，不仅仅是number或string

        4-3：注意点：类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型

    5-泛型约束
        5-1：用法：定一个一个接口来描述约束条件，使用这个接口和extends关键字实现约束
                事例：
                ```ts
                    interface Lengthwise {
                        length: number;
                    }

                    function loggingIdentity<T extends Lengthwise>(arg: T): T {
                        console.log(arg.length); 
                        return arg;
                    }
                    // 我们需要传入符合约束类型的值，必须包含必须的属性
                    loggingIdentity({length:10,value:3})
                ```
        
        5-2:在泛型约束中使用类型参数
            事例：声明一个类型参数，且它被另一个类型参数所约束
            ```ts
                function getProperty<T, K extends keyof T>(obj: T, key: K) {
                    return obj[key];
                }

                let x = { a: 1, b: 2, c: 3, d: 4 };

                getProperty(x, "a"); // okay
                getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
            ```
                事例解释：现在我们想要用属性名从对象里获取这个属性。并且要确保这个属性存在于对象obj上，因此我们需要在这两个类型之间使用约束


        5-3：在泛型里使用类类型
            事例：使用泛型创建工厂函数时，需要引用构造函数的类类型
            ```ts
                function create<T>(c: {new(): T; }): T {
                    return new c();
                }
            ```
            事例：原型属性推断并约束构造函数与类实例的关系
            ```ts
                class BeeKeeper {
                    hasMask: boolean;
                }
                class ZooKeeper {
                    nametag: string;
                }
                class Animal {
                    numLegs: number;
                }
                class Bee extends Animal {
                    keeper: BeeKeeper;
                }
                class Lion extends Animal {
                    keeper: ZooKeeper;
                }
                function createInstance<A extends Animal>(c: new () => A): A {
                    return new c();
                }
                createInstance(Lion).keeper.nametag;  // typechecks!
                createInstance(Bee).keeper.hasMask;   // typechecks!
            ```


