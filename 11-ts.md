***基础类型
    布尔值
```ts
    let isDone:boolen = false 
```
    数字
```ts
    let dec:number = 20
    let dec:number = 0x14 16进制表示法
    let dec:number = 0b10100  2进制表示法
    let dec:number = 0o24 8进制表示法
```
    字符串
```ts
    let name:string = 'bob'
```
    数组
```ts
    let list:number[]=[1,2,3,4] 数字类型的数组
    let list:Array<number> = [1,2,3,4]  数组泛型
```
    元祖Tuple
```ts
    let x:[string,number]  
    x=['hello',10]
    定义x数组，第一个数据是字符串第二个数字是数字，顺序类型严格要求
```
    枚举
```ts
    enum Color{
        Red,
        Green,
        Blue
    }
    Color默认的对应的枚举值为0,1,2，可以通过点的方式取到枚举值，也可以通过枚举值找到对应的名字值
```
    any
```ts
    用了any类型了 typescript就不做类型检查了
    let list:any[] =  [1,'yee',false]
    let notSure:any = 4
    notSure = 'maybe'
```
    void
```ts
    表示没有任何类型
    function warn():void {   没有任何返回值的函数
        console.log('this is my waring message')
    }
```
    null和undefined
```ts  是所有类型的子类型
    let u:undefined = undefined
    let u:null = null
```
    never和object
```ts
    never类型 必须是不能返回的或者是报错的或不能结束的
    never类型 是任何元素的子类型，其他元素不能赋值给never 
    function error(message:string): never {

    }

    object类型 
    declare function create(o:object | null):void;

```
    类型推断(类型断言或者类型转换)
```ts
    let someValue:any = 'this is a string'
    将any类型强制转换成string类型 第一种语法：<string>
    let strlength:number = (<string>somevalue).length  用<string>someValue 就将someValue强制转换成string类型
    第二种语法 强制转换成string类型
    (someValue as string)
```



***接口
    值所对应的结构进行类型检查，会检查我们的类型和某种结构匹配
    接口的作用：为类型命名和为代码定义契约
    1-接口初探
```ts
    interface LabelledValue {
    label: string;
    }

    function printLabel(labelledObj: LabelledValue) {
    console.log(labelledObj.label);
    }

    let myObj = {size: 10, label: "Size 10 Object"};
    printLabel(myObj);
    一个参数，并要求这个对象参数有一个名为label类型为string的属性
    类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以
```

    2-可选属性
```ts
    interface Square {
        color:string,
        area:number
    }
    interface SquareConfig {
        color?:string,    问号表示这个属性是可选属性可以有也可以没有
        width?:number
    }
    function createSquare(config:SquareConfig):Square {
        let newSquare = {color:'white',area:100}
        if(config.color){
            newSquare.color = config.color
        }
        return newSquare
    }
    let mySquare = createSquare(config:{color:'black'})

```
    3-只读属性
```ts
方法一：
    interface Point {   
        readonly X:number  定义接口的时候属性前面加上readonly就可以了
        readonly y:number
    }
方法二：
    可以通过赋值一个对象字面量来构造一个Point，赋值后x,y再也不能被改变
    let p1:Point = {x:10,y:20} p1是创建出来的只读属性
    所以不可以修改p1
方法三：
    ***泛型只读数组 rea
    let a:number[] = [1,2,3,4]
    let rea:ReadonlyArray<number> = a
    rea as number[] 
    然后rea就不可以修改了
    可以通过断言改变只读数组的类型，其他方法不行
```
    4-额外属性检查
    5-函数类型
```ts
    对函数的参数名来说和接口定义的属性参数不一定一样，只要保证对应的参数类型是一样的就可以了
    interface SeachFunc {
        (source:string,subString:string):boolen
    }
    let mySearch:SearchFunc  
    mySearch = function(src:string,sub:string):boolen{  
        let result = src.search(sub)
        return result > 1
    }
```
    6-可索引类型
```ts   
    可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型
    TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型
    interface StringArray {
        数字的索引
        [index:number]:string  
    }
    let myArray:StringArray
    myArray = ['bob','fred']
    let myStr:string = myArray[0]


```
    7-类类型
```ts
    interface ClockConstructor { 定义构造器的接口或者静态部分的接口
        new (hour: number, minute: number): ClockInterface;
    }
    interface ClockInterface {  定义实例接
        tick();
    }

    function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
        return new ctor(hour, minute);
    }
implements ColocInterface 这个意思--->不是DiaitalClock本身（类的静态部分）应该符合接口规则
而是 --->类 DigitalClock 实例化出来的对象（类的实例部分）应该满足这个接口的规则
    class DigitalClock implements ClockInterface {
        constructor(h: number, m: number) { }
        tick() {
            console.log("beep beep");
        }
    }
    class AnalogClock implements ClockInterface {
        constructor(h: number, m: number) { }
        tick() {
            console.log("tick tock");
        }
    }

    let digital = createClock(DigitalClock, 12, 17);
    let analog = createClock(AnalogClock, 7, 32);
```
    8-继承接口
```ts
    interface Square {
        color:string
    }
    interface PenStroke {
        penwidth:number
    }

    interface Shape extends Square,PenStroke{
        sidewidth:number
    }

    let suar = {} as Shape
    suar.color = 'red'
    suar.penwidth = 10
    suar.sidewidth = 80
```
    9-混合类型

    10-接口继承类



***类
    继承 
```ts
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}
class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}
let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");
sam.move();
tom.move(34);
这个例子演示了如何在子类里写父类的方法，snake类和horse类都创建了move方法，它们重写了从animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。注意即使tom被声明为animal类型，但因为他的值是hourse，调用tom.move(34)时,它会调用hourse里重写的方法

```

    公有，私有与保护的修饰符
```ts
    默认为public


    设置私有private
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal("Goat");
let rhino = new Rhino();
let employee = new Employee("Bob");

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
因为animal和Rhino共享了来自animal里面私有成员定义 private name:string,因此它们是兼容。
当把Employee赋值给animal的时候，得到一个错误，说它们的类型不兼容，尽管employee里也有一个私有成员name，但它明显不是animal里面定义的那个

问题：构造函数被标记成protected，这意味着这个类不能在包含它的类外被实例化，但是能被继承
```

    readonly修饰符
```ts
    class Outpus{
        readonly name:string;
        readonly numberoflegs:number = 8;
        constructor (theName:string){
            this.name = theName
        }
    }
    let dad = new Outpus('strong')
    dad.name = 'week'   这里就会报一个错，name是只读的
```

    参数属性
```ts
    class Octpus{
        readonly numberofleg:number = 0;
        constructor(readonly name:string){

        }
    }
    仅仅将原来的name属性直接写到了狗仔函数的参数当中
```

    存取器
```ts
let passcode = "secret passcode";
class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }
    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}
let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
存取器的要求你将编译器设置为输出ES5或更高，不支持降级到ES3，其次，只带有get不带有set的存取器自动推断为readonly。类似于拦截器的原理
```

    静态属性
```ts
class Grid {
    constructor(public scale: number) { }
}
编译之后  留意构造函数上的转变
var Grid = /** @class */ (function () {
    function Grid(scale) {
        this.scale = scale;
    }
    return Grid;
}());
```


    ***类型推论
```ts
    最佳通用类型

let x={0,1,null}
为了推断x类型，我们需要考虑所有元素的类型，这里有俩种选择：number和null。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型

有些时候没有一个候选类型可以作为通用类型，如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型；
```

```ts
    上下文类型

    函数表达式有明确的参数类型注解，那么上下文类型被忽略。
```


    ***高级类型
```ts
    交叉类型
    把俩个类型通过extend拼接到一起，我们称之为交叉类型

```

```ts
    联合类型
    几种类型之一，用 | 表示

interface Bird {
    fly()
    layEagg()
}
interface Fish{
    swim()
    layEagg()
}
function getSmallPet():Fish | Bird{

}
let pet = getSmallPet()
pet.layEagg() pet只能访问Bird和Fish的公有部分layEagg,访问其的会报错。因为不知道类型是Bird还是FIsh
```

```ts
    类型保护

    1-通过类型谓词进行保护  类型谓词是parameterName is Type这种形式
function isFish(pet:Fish | Bird):pet is Fish {
    return (<Fish>pet).swim !==undefined
}
if(isFish(pet)){
    传入pet，是Fish类型的进入，进入else肯定是Bird类型
}else{}

    2-通过typeof类型保护
function padLeft(value:string,padding:string | number){
    if(typeof padding === 'number'){

    }
    if(typeof padding === 'string'){

    }
}


    3-instanceof 类型保护
    跟原型上差不多
```


    可以为null的类型

###数组解构
```js
// 1-作用于函数参数
function f([first,second]:[number,number]){
    console.log(first)
    console.log(second)
}
// 2-在数组里使用...语法创建剩余变量
let [first,...rest] = [1,2,3,4]
console.log(rest) // [2,3,4]
// 可忽略你不关心的尾随元素
let [first] = [1,2,3,4]
console.log(first) // [1]
```

###对象解构
```js
// 1-解构可以用于函数声明和默认值
type C = {a:string,b?number}
function f({a,b}:C):void{

}
function f({a,b=0}:{a:''}):void{

}
f({a:'yes'}) //不会报错，且有输出结果
f()  //不会报错且会根据a和b的默认值计算
```

###数组和对象的展开
```js
// 1-对象解构展开
// 展开操作符与解构相反，它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象
let defaults = {food:'spicy',price:'$$',ambiance:'noisy'}
let search = {...defaults,food:'rich'} //search的值为 {food:'rich',price:'$$',ambiance:'noisy'}  出现在展开对象后面的属性会覆盖前面的属性

// 2-对象展开的限制  它仅包含对象自身的可枚举属性。大体上是展开一个对象实例时，丢失其方法
class C{
    p=12;
    m(){

    }
}
let c = new C()
let clone = {...c}
clone.p  //ok
clone.m() // 报错，无法找到m方法。其方法已经丢失
```

###接口
```js
// 1-可选属性：接口里的属性不全是必需的，有些是只在某些条件下存在，或者根本不存在。可选属性在应用'option bags'模式时很常用，即给函数传入的参数对象中只有部分属性赋值
interface SquareConfig {
    color?:string,
    width?:number
}
function createSquare(config:SquareConfig):{color:string,area:number}{}
let mySquare = createSquare({color:'black'})

// 2-只读属性：一些对象属性只能在对象刚刚创建的时候修改其值，以后被定义的值就不允许变了
interface Point{
    readonly x:number;
    readonly y:number
}
let p1: Point = {x:10,y:20}
p1.x = 5 //报错，不可被修改

// ReadonlyArray<T> 定义数组的时候具有只读的功能
// TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此确保数组创建后也不能被改变
let a:number[] = [1,2,3,4]
let ro:ReadonlyArray<number> = a
ro[0] = 12 //报错，不可被赋值
a = ro // 报错，a和ro都不可被赋值了


// 3-额外属性检查
// 3-1 情景：传入的参数在定义的接口中不存在，怎么处理不会报错
// 3-1-1绕开接口的类型检查，使用类型断言
let mySquare = createSquare({width:100,opcity:0.5} as SquareConfig);
// 3-1-2 最佳的方式通过字符串索引签名 只要传入的参数不是color和width，那么就无所谓它们的类型是什么了都会绕过检查
interface SquareConfig {
    color?:string;
    width?:number;
    [propName:string]:any  //字符串索引的用法
}
// 3-1-3 将这个对象赋值给另外一个变量，因为squareOptions不会经过额外属性检查，所以编译器不会报错
let squareOptions = {colour:'red',width:100}
let mySquare = createSquare(squareOptions)


// 4-函数类型
// 对于函数类型来说，函数的参数名不需要与接口里定义的名字相匹配，因为函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容即可，如
interface SearchFunc {
    (source:string,subString:string):boolean
}
let mySearch:SearchFunc
mySearch = function(src:string,sub:string):boolean {
    return true
}

// 5-可索引类型 ：描述那些能够"通过索引得到"的类型。可索引类型具有一个 索引签名，描述了对象索引的类型，还有相应的索引返回值类型。
// 问题：数字索引的返回值必须是字符串索引返回值类型的子类型

// 6-类类型 ：ts也能够用它来明确强制一个类去符合某种契约
// 6-1类静态部分与实例部分的区别：当操作类和接口的时候，只要知道类是具有俩种类型的：静态部分的类型和实例部分的类型。注意，当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：是因为当一个类实现一个接口时，只对其实例部分进行类型检查。所以我们要定义俩个接口分别对静态部分和实例部分进行定义


interface ClockConstructor {
    new(hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}
 
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}
 
class DigitalClock implements ClockInterface {
    constructor(private h: number, private m: number) { }
    tick() {
        console.log("beep beep" + "time:" + this.h + ":" + this.m);
    }
}
 
class AnalogClock implements ClockInterface {
    constructor(private h: number, private m: number) { }
    tick() {
        console.log("tick tock" + "time:" + this.h + ":" + this.m);
    }
}
 
class DummyClock implements ClockInterface {
    constructor() { }
    tick() {
        console.log("wooooo...");
    }
}
componentDidMount() {
        let digital = createClock(DigitalClock, 12, 17);
        let analog = createClock(AnalogClock, 7, 32);
        let dummy = createClock(DummyClock, 10, 20);
 
        digital.tick();
        analog.tick();
        dummy.tick();
}


// 7-继承接口：
// 7-1和类一样，接口也可以相互继承，这让我们能够从一个接口里复制成员到另外一个接口里，可以更灵活地将接口分割到可重用的模块里
// 7-2：一个接口可以继承多个接口，创建多个接口的合成接口
interface Shape {
    color:string;
}
interface PenStroke {
    penWidth:number;
}
interface Square extends Shape,PenStroke {
    sideLength:number;
}

// 8-混合接口：一个对象可以同时作为函数和对象使用，并带有额外的属性

// 9-接口继承类：

```


###类
<!-- 1-继承 -->
```js
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
// 这个例子展示了最基本的继承:类从基类中继承了属性和方法，这里，Dog是一个派生类，它派生字Animal基类，通过extends关键字。派生类通常被称为子类，基类通常被称作超类


class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
// 上面例子注意点：派生类包含了一个构造函数，它必须调用super(),它会执行基类的构造函数。而且在构造函数访问this属性之前，我们一定要调用super()。这个是Typescript强制执行的一条重要规则
// 即使tom被声明为Animal类型，但因为它的值为Horse，调用了tom.mov(34)时，它会调用Horse里重写的方法
```
<!-- 公共，私有与受保护的修饰符 -->
```js
// 1-在typescript里，成员默认的为public
// 2-private私有
// 当成员被标记成private时，它就不能在声明它的类的外部访问，比如
class Animal {
    private name:string;
    constructor(theName:string){this.name = theName}
}
new Animal("cat").name //错误，'name'是私有制的 实例化之后访问会出错
// 3-protected
// 3-1：当构造函数被标记成protected时，这意味着这个类不能在包含它的类外被实例化，如
class Person {
    protected name:string;
    protected constructor(theName:string){this.name = theName}
}
new Person() //错误，'person'的构造函数是被保护的
// 4-readonly修饰符
// 可以使用readonly关键字将设置为只读，只读属性必须在声明时或构造函数里被初始化
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs"); //初始化操作
dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
// 5-存取器
// typescript支持通过getters/setters来截取对对象成员的访问。它能有效的控制对对象成员的访问权限，如 当只有密码正确才能对以下成员进行更改访问
let passcode = "secret passcode";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
// 6-静态属性：该属性存在于类的本身而不是实例上，通过类的本身就可以访问
// 7-抽象类
// 7-1抽象方法必须在派生类中实现
// 7-2不能创建抽象类的实例
abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
```


###函数
```js
// 1-函数类型
// 1-1为函数定义类型
function add(x:number,y:number):number{
    return x + y
}
let myadd = function(x:number,y:number):number{
    return x + y
}
// 1-2书写完整的函数类型 (将上面俩个函数类型结合)
let myAdd: (baseValue: number, increment: number) => number =
    function(x: number, y: number): number { return x + y; };
// 1-3类型推断  尝试上面这个例子的时候，会发现你在赋值语句的一边指定类型但是另一边没有类型的话，Typescript编译器会自动识别出类型
let myAdd = function(x:number,y:number):number{return x + y}
let myAdd: (baseValue:number,increament:number)=>number=function(x,y){return x + y}
// 这叫做"按上下文归类，是类型推断的一种，它帮助我们更好地为程序指定类型"
// 1-4可选参数和默认参数   
// 1-4-1跟JavaScript不一样，在typescript里我们可以在参数名旁使用?实现可选参数的功能,但是可选参数必须跟在必须参数后面
// 1-4-2在Typescript里，为参数提供一个默认值，默认参数和可选蚕食共享参数类型(默认参数和可选参数的参数类型是一样的)
// 1-4-3与可选参数不同的是，默认参数可以写在必须参数前面，在不传值时必须传入undefined来获取默认值
```

```js
// 2-剩余参数   剩余参数会被当做个数不限的可选参数。可以一个都没有，同样也可以有任意个。编译器创建参数数组，名字是你省略号(...)后面的给定的名字，你可以在函数体内使用这个数组
function buildName(firstName:string,...restofName:string[]){
    return firstName + '' + restofName.join(' ')
}
let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie")
```