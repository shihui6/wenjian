**安装typescript
    1-有俩种主要的方式来获取typescript工具
        1-1：通过npm安装 (npm install -g typescript)
        1-2：安装vscode的typescript插件 (vscode2017和vscode2015 Update 3默认包含了TypeScript)

**编译代码
    在typescript中尽可能是用let来代替var
    1-概念：在.ts扩展名的命令行上运行typescript编译器
    2-用法：tsc + ts文件
    实例：

        ```ts
            tsc greeter.ts  //输出结果为一个greeter.js文件
        ```

**基础类型
    1-布尔值

    ```ts
        let isDone:boolen = false 
    ```

    2-数字
    概念：和JavaScript一样，typescript里的所有数字都是浮点数。这些浮点数的类型是number。除了支持十进制和十六进制字面量，typescript还支持ECMAScript2015中引入的二进制和八进制字面量

    ```ts
        let dec:number = 20
        let dec:number = 0x14 16进制表示法
        let dec:number = 0b10100  2进制表示法
        let dec:number = 0o24 8进制表示法
    ```

    3-字符串
        3-1概念：使用string表示文本数据类型
        3-2用法：
            3-2-1：可以使用双引号或单引号表示字符串
            3-2-2：使用模板字符串，定义多行文本和内嵌表达式。这种字符串是被反引号`包围
            实例：

            ```ts
                let name:string = 'bob'
                let sentence:string = `hello,my name ${name}`
            ```
    
    4-数组
        4-1：数组类型用法：
            4-1-1：在元素类型后面接上[]，表示由此类型元素组成的一个数组
            4-1-2：数组泛型，Array<元素类型>
            实例：

            ```ts
                let list:number[]=[1,2,3,4] 数字类型的数组
                let list:Array<number> = [1,2,3,4]  数组泛型
            ```

    5-元祖Tuple
        5-1：概念：
            5-1-1：元祖类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同
            实例：

            ```ts
                let x:[string,number]  
                x=['hello',10]
            ```
            实例解释注意点：定义x数组，第一个数据是字符串第二个数字是数字，顺序类型严格要求

            5-1-2：当访问一个已知索引的元素，会得到正确的类型对应的值
            5-1-3：当访问一个越界元素，会使用联合类型替代
            实例：

            ```ts
                let x:[string,number]  
                x=['hello',10]
                x[3] = 'world'  //hello,字符串可以赋值给(string | number)类型，此类型为联合类型
                x[4] = true //会报错：因为布尔值，不是(string | number)类型
            ```
                实例解释：当添加一个联合类型里没有的类型，则会报错

    6-枚举
        6-1：概念：enum类型是对JavaScript标准数据类型的一个补充。使用枚举类型可以为一组数值赋予友好的名字
        6-2：用法：枚举类型提供的一个便利是你可以由枚举的值得到它的名字。
            6-2-1：实例：我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字

            ```ts
                enum Color {Red = 1, Green, Blue}
                let colorName: string = Color[2];
                alert(colorName);  // 显示'Green'因为上面代码里它的值是2 
            ```
            6-2-2：Color默认的对应的枚举值为0,1,2，可以通过点的方式取到枚举值，也可以通过枚举值找到对应的名字值、
            实例：

            ```ts
                enum Color{
                    Red,
                    Green,
                    Blue
                }
            ```

    7-any
        7-1：概念：在某些情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用any类型来标记这些变量
            实例：

            ```ts
                let list:any[] =  [1,'yee',false]
                let notSure:any = 4
                notSure = 'maybe'
            ```
            实例解释：any类型，编译器允许你在编译时可选择地包含或移除类型检查
        7-2：any类型和Object类型比较，你可能认为Object有相似的作用，就像它在其它语言中那样。 但是Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法
            实例：

            ```ts
                let notSure: any = 4;
                notSure.ifItExists(); // okay, ifItExists might exist at runtime
                notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

                let prettySure: Object = 4;
                prettySure.toFixed(); // 报错: 类型对象上不存在toFixed()属性，即便它真的有这些方法
            ```

    8-void
        8-1：概念：
            8-1-1：某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void
            实例：

            ```ts
                function warn():void {   没有任何返回值的函数
                    console.log('this is my waring message')
                }
            ```
            8-1-2：声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null
            实例：

            ```ts
                let unusable: void = undefined;
            ```

    9-null和undefined
        概念：TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null

        ```ts  是所有类型的子类型
            let u:undefined = undefined
            let u:null = null
        ```
    
    10-never
        10-1：概念：
            10-1-1：never类型表示的是那些永不存在的值的类型
            10-1-2：必须是不能返回的或者是报错的或不能结束的
        10-2：用法：
            10-2-1：返回never的函数抛出异常

            ```ts
                function error(message: string): never {
                    throw new Error(message);
                }
            ```

            10-2-2：推断的返回值类型为never

            ```ts
                function fail() {
                    return error("Something failed");
                }
            ```
            10-2-3:返回never的函数必须存在无法达到的终点

            ```ts
            function infiniteLoop(): never {
                while (true) {
                }
            }
            ```

    11-类型断言(类型断言或者类型转换)
        11-1:概念：类型转换
        11-2:类型断言执行机制：告诉编译器，进行数据类型转换，不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用
        11-3：用法：类型断言有两种方式
            11-3-1：尖括号语法

            ```ts
            let someValue: any = "this is a string";
            let strLength: number = (<string>someValue).length;   //将someValue强制转换成string类型
            ```
            11-3-2：as语法

            ```ts
            let someValue: any = "this is a string";
            let strLength: number = (someValue as string).length; //将someValue强制转换成string类型
            ```

        注意点：当你在TypeScript里使用JSX时，只有as语法断言是被允许的



**接口
    概念：对值所具有的结构进行类型检查，为这些类型命名和为你的代码或第三方代码定义契约

    1-接口初探
        实例：

        ```ts
            interface LabelledValue {
                label: string;
            }
            function printLabel(labelledObj: LabelledValue) {
                console.log(labelledObj.label);
            }
            let myObj = {size: 10, label: "Size 10 Object"};
            printLabel(myObj);
        ```
        实例解释：LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表printLabel函数参数中有一个label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的

        注意点：类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以

    2-可选属性
        2-1：概念：接口里的属性不全都是必需的。有些是只在某些条件下存在，或者根本不存在。即给函数传入的参数对象中只有部分属性赋值了
        2-2：用法：带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号
        2-3：用可选属性的原因：
                2-3-1：对可能存在的属性进行预定义
                2-3-2：捕获引用了不存在的属性时的错误
            实例：

            ```ts
                interface SquareConfig {
                    color?:string;
                    width?:number
                }
                function createSquare(config:SquareConfig):Square {
                    let newSquare = {color:'white',area:100}
                    if(config.color){   
                        newSquare.color = config.clor  //报错：参数的属性中没有接口中定义的属性时会报错
                    }
                    return newSquare
                }
                let mySquare = createSquare(config:{color:'black'})

            ```
        
    3-只读属性
        3-1:概念：一些对象属性只能在对象初始化的时候修改其质
        3-2:用法：
            3-2-1：在属性名前用readonly来指定只读属性
            3-2-2：通过ReadonlyArray<T>指定只读
        3-3:实例：
            3-3-1:通过赋值一个对象字面量来构造一个Point，赋值后，x和y再也不能被改变了

            ```ts
                interface Point {   
                    readonly X:number
                    readonly y:number
                }
                let p1: Point = { x: 10, y: 20 };
                p1.x = 5; // error!
            ```
            3-3-2:TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改

            ```ts
                let a: number[] = [1, 2, 3, 4];
                let ro: ReadonlyArray<number> = a;
                ro[0] = 12; // error!
                ro.push(5); // error!
                ro.length = 100; // error!
                a = ro; // error!
            ```
                实例解释：ro赋值到一个普通数组也是不可以的，但是可以通过类型断言重写如

                ```ts
                    a = ro as number[]
                ```


    4-额外属性检查
        4-1概念：对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。如果一个对象字面量存在任何'目标类型'不包含的属性时，会得到一个错误
        4-2用法：在接口中添加一个字符串索引签名，前提是能够确定这个对象可能具有某些做为特殊用途使用的额外属性

        实例：如果SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它

            ```ts
                interface SquareConfig {
                    color?: string;
                    width?: number;
                    [propName: string]: any;
                }
            ```
            实例解释：SquareConfig表示任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么


    5-函数类型
        5-1:概念：接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型
        5-2:用法：
            5-2-1:用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                } 
            ```
            5-2-2:对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                }
                let mySearch: SearchFunc;
                mySearch = function(src: string, sub: string): boolean {
                let result = src.search(sub);
                return result > -1;
                }
            ```
            5-2-3:不想指定类型

            ```ts
                interface SearchFunc {
                (source: string, subString: string): boolean;
                }
                let mySearch: SearchFunc;
                mySearch = function(src, sub) {
                    let result = src.search(sub);
                    return result > -1;
                }
            ```
                实例解释：TypeScript的类型系统会推断出参数类型,因为函数直接赋值给了SearchFunc类型变量。函数的参数和返回值类型是通过SearchFunc函数接口推断出来的


    6-可索引类型
        6-1：概念：与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型
        6-2：用法：
            6-2-1：可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型
            实例：我们定义了StringArray接口，它具有索引签名。这个索引签名表示了当用number去索引StringArray时会得到string类型的返回值

            ```ts
                interface StringArray {
                [index: number]: string;
                }

                let myArray: StringArray;
                myArray = ["Bob", "Fred"];

                let myStr: string = myArray[0];
            ```
            6-2-2：支持两种索引签名：字符串和数字
                注意点：可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型
                注意点解释：因为当使用number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用100（一个number）去索引等同于使用"100"（一个string）去索引，因此两者需要保持一致

            6-2-3:当name的类型与字符串索引类型不匹配,类型检查器会给出一个错误提示

                ```ts
                    interface NumberDictionary {
                    [index: string]: number;
                    length: number;    // 可以，length是number类型
                    name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
                    }
                ```
                实例解释：字符串索引签名能够很好的描述dictionary(接口)模式，并且它们也会确保所有属性与其返回值类型相匹配。因为字符串索引声明了obj.property和obj["property"]两种形式都可以

            6-2-4：将索引签名设置为只读

                ```ts
                    interface ReadonlyStringArray {
                        readonly [index: number]: string;
                    }
                    let myArray: ReadonlyStringArray = ["Alice", "Bob"];
                    myArray[2] = "Mallory"; // error!
                ```


    7-类类型
```ts
    interface ClockConstructor { 定义构造器的接口或者静态部分的接口
        new (hour: number, minute: number): ClockInterface;
    }
    interface ClockInterface {  定义实例接
        tick();
    }

    function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
        return new ctor(hour, minute);
    }
implements ColocInterface 这个意思--->不是DiaitalClock本身（类的静态部分）应该符合接口规则
而是 --->类 DigitalClock 实例化出来的对象（类的实例部分）应该满足这个接口的规则
    class DigitalClock implements ClockInterface {
        constructor(h: number, m: number) { }
        tick() {
            console.log("beep beep");
        }
    }
    class AnalogClock implements ClockInterface {
        constructor(h: number, m: number) { }
        tick() {
            console.log("tick tock");
        }
    }

    let digital = createClock(DigitalClock, 12, 17);
    let analog = createClock(AnalogClock, 7, 32);
```
    8-继承接口
```ts
    interface Square {
        color:string
    }
    interface PenStroke {
        penwidth:number
    }

    interface Shape extends Square,PenStroke{
        sidewidth:number
    }

    let suar = {} as Shape
    suar.color = 'red'
    suar.penwidth = 10
    suar.sidewidth = 80
```
    9-混合类型

    10-接口继承类



***类
    继承 
```ts
class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}
class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}
let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");
sam.move();
tom.move(34);
这个例子演示了如何在子类里写父类的方法，snake类和horse类都创建了move方法，它们重写了从animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。注意即使tom被声明为animal类型，但因为他的值是hourse，调用tom.move(34)时,它会调用hourse里重写的方法

```

    公有，私有与保护的修饰符
```ts
    默认为public


    设置私有private
class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super("Rhino"); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal("Goat");
let rhino = new Rhino();
let employee = new Employee("Bob");

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
因为animal和Rhino共享了来自animal里面私有成员定义 private name:string,因此它们是兼容。
当把Employee赋值给animal的时候，得到一个错误，说它们的类型不兼容，尽管employee里也有一个私有成员name，但它明显不是animal里面定义的那个

问题：构造函数被标记成protected，这意味着这个类不能在包含它的类外被实例化，但是能被继承
```

    readonly修饰符
```ts
    class Outpus{
        readonly name:string;
        readonly numberoflegs:number = 8;
        constructor (theName:string){
            this.name = theName
        }
    }
    let dad = new Outpus('strong')
    dad.name = 'week'   这里就会报一个错，name是只读的
```

    参数属性
```ts
    class Octpus{
        readonly numberofleg:number = 0;
        constructor(readonly name:string){

        }
    }
    仅仅将原来的name属性直接写到了狗仔函数的参数当中
```

    存取器
```ts
let passcode = "secret passcode";
class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }
    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}
let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
存取器的要求你将编译器设置为输出ES5或更高，不支持降级到ES3，其次，只带有get不带有set的存取器自动推断为readonly。类似于拦截器的原理
```

    静态属性
```ts
class Grid {
    constructor(public scale: number) { }
}
编译之后  留意构造函数上的转变
var Grid = /** @class */ (function () {
    function Grid(scale) {
        this.scale = scale;
    }
    return Grid;
}());
```


    ***类型推论
```ts
    最佳通用类型

let x={0,1,null}
为了推断x类型，我们需要考虑所有元素的类型，这里有俩种选择：number和null。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型

有些时候没有一个候选类型可以作为通用类型，如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型；
```

```ts
    上下文类型

    函数表达式有明确的参数类型注解，那么上下文类型被忽略。
```


    ***高级类型
```ts
    交叉类型
    把俩个类型通过extend拼接到一起，我们称之为交叉类型

```

```ts
    联合类型
    几种类型之一，用 | 表示

interface Bird {
    fly()
    layEagg()
}
interface Fish{
    swim()
    layEagg()
}
function getSmallPet():Fish | Bird{

}
let pet = getSmallPet()
pet.layEagg() pet只能访问Bird和Fish的公有部分layEagg,访问其的会报错。因为不知道类型是Bird还是FIsh
```

```ts
    类型保护

    1-通过类型谓词进行保护  类型谓词是parameterName is Type这种形式
function isFish(pet:Fish | Bird):pet is Fish {
    return (<Fish>pet).swim !==undefined
}
if(isFish(pet)){
    传入pet，是Fish类型的进入，进入else肯定是Bird类型
}else{}

    2-通过typeof类型保护
function padLeft(value:string,padding:string | number){
    if(typeof padding === 'number'){

    }
    if(typeof padding === 'string'){

    }
}


    3-instanceof 类型保护
    跟原型上差不多
```


    可以为null的类型

###数组解构
```js
// 1-作用于函数参数
function f([first,second]:[number,number]){
    console.log(first)
    console.log(second)
}
// 2-在数组里使用...语法创建剩余变量
let [first,...rest] = [1,2,3,4]
console.log(rest) // [2,3,4]
// 可忽略你不关心的尾随元素
let [first] = [1,2,3,4]
console.log(first) // [1]
```

###对象解构
```js
// 1-解构可以用于函数声明和默认值
type C = {a:string,b?number}
function f({a,b}:C):void{

}
function f({a,b=0}:{a:''}):void{

}
f({a:'yes'}) //不会报错，且有输出结果
f()  //不会报错且会根据a和b的默认值计算
```

###数组和对象的展开
```js
// 1-对象解构展开
// 展开操作符与解构相反，它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象
let defaults = {food:'spicy',price:'$$',ambiance:'noisy'}
let search = {...defaults,food:'rich'} //search的值为 {food:'rich',price:'$$',ambiance:'noisy'}  出现在展开对象后面的属性会覆盖前面的属性

// 2-对象展开的限制  它仅包含对象自身的可枚举属性。大体上是展开一个对象实例时，丢失其方法
class C{
    p=12;
    m(){

    }
}
let c = new C()
let clone = {...c}
clone.p  //ok
clone.m() // 报错，无法找到m方法。其方法已经丢失
```

###接口
```js
// 1-可选属性：接口里的属性不全是必需的，有些是只在某些条件下存在，或者根本不存在。可选属性在应用'option bags'模式时很常用，即给函数传入的参数对象中只有部分属性赋值
interface SquareConfig {
    color?:string,
    width?:number
}
function createSquare(config:SquareConfig):{color:string,area:number}{}
let mySquare = createSquare({color:'black'})

// 2-只读属性：一些对象属性只能在对象刚刚创建的时候修改其值，以后被定义的值就不允许变了
interface Point{
    readonly x:number;
    readonly y:number
}
let p1: Point = {x:10,y:20}
p1.x = 5 //报错，不可被修改

// ReadonlyArray<T> 定义数组的时候具有只读的功能
// TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此确保数组创建后也不能被改变
let a:number[] = [1,2,3,4]
let ro:ReadonlyArray<number> = a
ro[0] = 12 //报错，不可被赋值
a = ro // 报错，a和ro都不可被赋值了


// 3-额外属性检查
// 3-1 情景：传入的参数在定义的接口中不存在，怎么处理不会报错
// 3-1-1绕开接口的类型检查，使用类型断言
let mySquare = createSquare({width:100,opcity:0.5} as SquareConfig);
// 3-1-2 最佳的方式通过字符串索引签名 只要传入的参数不是color和width，那么就无所谓它们的类型是什么了都会绕过检查
interface SquareConfig {
    color?:string;
    width?:number;
    [propName:string]:any  //字符串索引的用法
}
// 3-1-3 将这个对象赋值给另外一个变量，因为squareOptions不会经过额外属性检查，所以编译器不会报错
let squareOptions = {colour:'red',width:100}
let mySquare = createSquare(squareOptions)


// 4-函数类型
// 对于函数类型来说，函数的参数名不需要与接口里定义的名字相匹配，因为函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容即可，如
interface SearchFunc {
    (source:string,subString:string):boolean
}
let mySearch:SearchFunc
mySearch = function(src:string,sub:string):boolean {
    return true
}

// 5-可索引类型 ：描述那些能够"通过索引得到"的类型。可索引类型具有一个 索引签名，描述了对象索引的类型，还有相应的索引返回值类型。
// 问题：数字索引的返回值必须是字符串索引返回值类型的子类型

// 6-类类型 ：ts也能够用它来明确强制一个类去符合某种契约
// 6-1类静态部分与实例部分的区别：当操作类和接口的时候，只要知道类是具有俩种类型的：静态部分的类型和实例部分的类型。注意，当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：是因为当一个类实现一个接口时，只对其实例部分进行类型检查。所以我们要定义俩个接口分别对静态部分和实例部分进行定义


interface ClockConstructor {
    new(hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}
 
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}
 
class DigitalClock implements ClockInterface {
    constructor(private h: number, private m: number) { }
    tick() {
        console.log("beep beep" + "time:" + this.h + ":" + this.m);
    }
}
 
class AnalogClock implements ClockInterface {
    constructor(private h: number, private m: number) { }
    tick() {
        console.log("tick tock" + "time:" + this.h + ":" + this.m);
    }
}
 
class DummyClock implements ClockInterface {
    constructor() { }
    tick() {
        console.log("wooooo...");
    }
}
componentDidMount() {
        let digital = createClock(DigitalClock, 12, 17);
        let analog = createClock(AnalogClock, 7, 32);
        let dummy = createClock(DummyClock, 10, 20);
 
        digital.tick();
        analog.tick();
        dummy.tick();
}


// 7-继承接口：
// 7-1和类一样，接口也可以相互继承，这让我们能够从一个接口里复制成员到另外一个接口里，可以更灵活地将接口分割到可重用的模块里
// 7-2：一个接口可以继承多个接口，创建多个接口的合成接口
interface Shape {
    color:string;
}
interface PenStroke {
    penWidth:number;
}
interface Square extends Shape,PenStroke {
    sideLength:number;
}

// 8-混合接口：一个对象可以同时作为函数和对象使用，并带有额外的属性

// 9-接口继承类：

```


###类
<!-- 1-继承 -->
```js
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
// 这个例子展示了最基本的继承:类从基类中继承了属性和方法，这里，Dog是一个派生类，它派生字Animal基类，通过extends关键字。派生类通常被称为子类，基类通常被称作超类


class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log("Galloping...");
        super.move(distanceInMeters);
    }
}

let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");

sam.move();
tom.move(34);
// 上面例子注意点：派生类包含了一个构造函数，它必须调用super(),它会执行基类的构造函数。而且在构造函数访问this属性之前，我们一定要调用super()。这个是Typescript强制执行的一条重要规则
// 即使tom被声明为Animal类型，但因为它的值为Horse，调用了tom.mov(34)时，它会调用Horse里重写的方法
```
<!-- 公共，私有与受保护的修饰符 -->
```js
// 1-在typescript里，成员默认的为public
// 2-private私有
// 当成员被标记成private时，它就不能在声明它的类的外部访问，比如
class Animal {
    private name:string;
    constructor(theName:string){this.name = theName}
}
new Animal("cat").name //错误，'name'是私有制的 实例化之后访问会出错
// 3-protected
// 3-1：当构造函数被标记成protected时，这意味着这个类不能在包含它的类外被实例化，如
class Person {
    protected name:string;
    protected constructor(theName:string){this.name = theName}
}
new Person() //错误，'person'的构造函数是被保护的
// 4-readonly修饰符
// 可以使用readonly关键字将设置为只读，只读属性必须在声明时或构造函数里被初始化
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs"); //初始化操作
dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.
// 5-存取器
// typescript支持通过getters/setters来截取对对象成员的访问。它能有效的控制对对象成员的访问权限，如 当只有密码正确才能对以下成员进行更改访问
let passcode = "secret passcode";

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode && passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}

let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}
// 6-静态属性：该属性存在于类的本身而不是实例上，通过类的本身就可以访问
// 7-抽象类
// 7-1抽象方法必须在派生类中实现
// 7-2不能创建抽象类的实例
abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
```


###函数
```js
// 1-函数类型
// 1-1为函数定义类型
function add(x:number,y:number):number{
    return x + y
}
let myadd = function(x:number,y:number):number{
    return x + y
}
// 1-2书写完整的函数类型 (将上面俩个函数类型结合)
let myAdd: (baseValue: number, increment: number) => number =
    function(x: number, y: number): number { return x + y; };
// 1-3类型推断  尝试上面这个例子的时候，会发现你在赋值语句的一边指定类型但是另一边没有类型的话，Typescript编译器会自动识别出类型
let myAdd = function(x:number,y:number):number{return x + y}
let myAdd: (baseValue:number,increament:number)=>number=function(x,y){return x + y}
// 这叫做"按上下文归类，是类型推断的一种，它帮助我们更好地为程序指定类型"
// 1-4可选参数和默认参数   
// 1-4-1跟JavaScript不一样，在typescript里我们可以在参数名旁使用?实现可选参数的功能,但是可选参数必须跟在必须参数后面
// 1-4-2在Typescript里，为参数提供一个默认值，默认参数和可选蚕食共享参数类型(默认参数和可选参数的参数类型是一样的)
// 1-4-3与可选参数不同的是，默认参数可以写在必须参数前面，在不传值时必须传入undefined来获取默认值
```

```js
// 2-剩余参数   剩余参数会被当做个数不限的可选参数。可以一个都没有，同样也可以有任意个。编译器创建参数数组，名字是你省略号(...)后面的给定的名字，你可以在函数体内使用这个数组
function buildName(firstName:string,...restofName:string[]){
    return firstName + '' + restofName.join(' ')
}
let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie")
```